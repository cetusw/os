#### **Дайте определение CPU burst и I/O burst. Почему ключевым фактором для классификации CPU-bound/I/O-bound считается длина CPU burst? ⭐**:

**CPU burst** — это период времени, в течение которого процесс выполняет вычисления, используя центральный процессор. **I/O burst** — это период, когда процесс блокируется в ожидании завершения операции ввода-вывода.

**Ключевым фактором** классификации считается именно **длина CPU burst**, так как она определяет характер нагрузки на систему. Процессы с длинными вычислительными интервалами и редкими запросами к устройствам называются **CPU-bound** (вычислительные), а процессы с очень короткими всплесками активности CPU и частым ожиданием ввода-вывода — **I/O-bound** (зависящие от ввода-вывода).

---

#### **Приведите примеры типичных CPU-bound и I/O-bound задач в современных ОС и объясните их поведение через bursts. ⭐⭐**:

- **CPU-bound задачи:** Примерами служат **рендеринг видео, научные вычисления или современные игры**. Поведение таких задач характеризуется редкими обращениями к диску и **длительными периодами (bursts)** непрерывной загрузки ядер процессора для обработки данных.
- **I/O-bound задачи:** К ним относятся **веб-серверы** (ожидающие сетевых пакетов), **текстовые редакторы** (ждущие нажатия клавиш) или программы для работы с базами данных. Их поведение — это бесконечные серии **коротких всплесков активности** CPU, необходимых для постановки задачи устройству ввода-вывода, за которыми следуют долгие паузы ожидания.

---

#### **Почему ускорение CPU в исторической перспективе «делает процессы более I/O-bound»? Какие технологические причины лежат в основе? ⭐⭐**:

Это происходит из-за **технологического разрыва** в скоростях развития компонентов. Согласно **закону Мура**, количество транзисторов и производительность CPU удваиваются каждые два года, в то время как быстродействие механических накопителей (HDD) практически не росло десятилетиями. В результате те вычисления, которые раньше занимали много времени (длинный CPU burst), теперь выполняются мгновенно, и процесс снова «замирает» в ожидании сравнительно **медленных операций ввода-вывода**, становясь типичным I/O-bound.

---

#### **Объясните, почему для производительности системы важно «смешивать» CPU-bound и I/O-bound процессы (баланс CPU и устройств). ⭐⭐**:

Для достижения максимальной производительности планировщик должен поддерживать **баланс загрузки** ресурсов. Если в системе запущены процессы обоих типов, то пока I/O-bound задачи ожидают диск или сеть, CPU-bound процессы могут полезно использовать освободившийся процессор. Это позволяет держать **все компоненты системы** (ядра CPU, дисковые контроллеры, сетевые адаптеры) занятыми одновременно, повышая общую пропускную способность.

---

#### **Что будет происходить с загрузкой CPU и диска, если в памяти окажутся только CPU-bound задачи, а затем только I/O-bound? Почему это плохо? ⭐⭐**:

- **Только CPU-bound:** Процессор будет загружен на 100%, однако все устройства ввода-вывода будут простаивать впустую.
- **Только I/O-bound:** Возникнет ситуация, когда все процессы заблокированы в ожидании своих данных; при этом **CPU будет простаивать**, а очередь к диску станет критически длинной.

Оба сценария плохи, так как **неэффективно используются дорогостоящие ресурсы** компьютера, что приводит к резкому падению общего количества завершенных задач в час.

---

#### **Как выбор алгоритма планирования может улучшать «параллелизм» CPU и I/O в системе? Приведите пример стратегии для I/O-bound процессов. ⭐⭐⭐**:

Алгоритм планирования может искусственно повышать **параллелизм**, предоставляя приоритет тем, кто быстрее освобождает процессор.

**Пример стратегии:** Динамическое повышение приоритета для **I/O-bound процессов**. Как только I/O-bound поток завершает ожидание данных, его следует запустить немедленно; он выполнит свой крошечный CPU burst (наносекунды) и отправит **следующий запрос** устройству ввода-вывода. Это позволяет диску работать без пауз, пока вычислительные задачи «доедают» остатки процессорного времени.

---

#### **Перечислите основные события, в которых ОС может принять решение о перепланировании (создание, завершение, блокировка, I/O interrupt, таймер). Почему этих событий достаточно? ⭐⭐**:

Перепланирование происходит при:

1. **Создании** нового процесса (нужно решить, запускать ли «ребенка» или оставить «родителя»).
2. **Завершении** текущего процесса (нужно выбрать следующего кандидата).
3. **Блокировке** процесса на I/O или семафоре (процесс больше не может занимать CPU).
4. **Прерывании ввода-вывода** (ранее заблокированный процесс стал готов к работе).
5. Периодическом **прерывании таймера** (истек квант времени).

Этих событий достаточно, потому что они охватывают все возможные моменты, когда либо **CPU становится свободен**, либо **состояние готовности процессов** в системе изменяется.

---

#### **В чём принципиальная разница между preemptive и nonpreemptive планированием? Какие риски есть у каждого подхода? ⭐⭐**:

- **Nonpreemptive (невытесняющее):** Процесс владеет CPU до тех пор, пока не отдаст его добровольно или не заблокируется на I/O. _Риск:_ один длинный процесс (или зависший цикл) может **парализовать всю систему**, не давая шанса другим.
- **Preemptive (вытесняющее):** ОС выделяет фиксированный квант времени (**time slice**), по истечении которого аппаратно прерывает процесс и передает CPU другому. _Риск:_ слишком частые переключения увеличивают **накладные расходы** на сохранение контекста, снижая общую эффективность.

---

#### **Почему наличие периодических прерываний таймера критично для вытесняющего планирования? Что произойдёт, если таймера нет? ⭐⭐**:

Прерывания таймера являются единственным надежным способом для ОС **вернуть себе контроль** над процессором без согласия работающей программы. Если таймера нет (или он отключен), система превращается в невытесняющую: планировщик будет ждать, пока программа сама вызовет системный вызов или завершится. Это делает невозможным работу интерактивных систем, так как любая вычислительная задача вызовет **«замораживание» интерфейса**.

---

#### **Объясните почему вытесняющая многозадачность важна не только для приложений, но и для ядра (preemptive kernel). ⭐⭐**:

**Вытесняющее ядро** позволяет прервать поток, выполняющий системный вызов или код драйвера, если в системе появилась более важная задача. Это критично для **отзывчивости**: без этой функции высокоприоритетный процесс реального времени был бы вынужден ждать, пока закончится длинная сервисная процедура внутри ядра. Такое решение значительно повышает **стабильность и предсказуемость** поведения системы под нагрузкой.

---

#### **Приведите пример ситуации, когда невытесняющее планирование может выглядеть привлекательным, и объясните, чем это может обернуться в реальной системе. ⭐⭐⭐**:

**Ситуация:** Пакетные системы обработки данных (например, расчет зарплат или банковских отчетов). Здесь невытесняющее планирование кажется привлекательным, так как оно **минимизирует переключения контекста**, позволяя процессору работать на 100% над полезной задачей.

**Чем обернется:** В реальной системе это приводит к **«эффекту конвоя»**: одна огромная задача по расчету годового отчета заблокирует выполнение десятков мелких запросов (например, печать чека), которые могли бы завершиться за миллисекунды, но будут ждать часами. Кроме того, если в коде задачи случится бесконечный цикл, систему придется **перегружать аппаратно**, так как программно перехватить управление будет невозможно.