#### **Что делает систему «реального времени» отличной от просто «быстрой» системы? Почему «правильный ответ слишком поздно» может считаться ошибкой? ⭐⭐**:

Система реального времени (RT-система) отличается тем, что **время является ключевым параметром** её работы. В отличие от просто «быстрых» систем, где важна средняя производительность, в RT-системах результат должен быть выдан в строго определённый временной интервал. Если ответ получен позже установленного срока (дедлайна), он считается ошибочным, так как может привести к катастрофическим последствиям в физическом мире (например, робот промахнётся при сварке детали).

#### **Приведите по 2–3 примера hard real-time и soft real-time систем и объясните, что именно является дедлайном в каждом примере. ⭐⭐**:

- **Hard Real-Time (жёсткие дедлайны):**
    1. **Промышленный робот на конвейере:** сварка должна произойти в точные миллисекунды, пока деталь находится в нужной позиции.
    2. **Авионика / Автопилот:** расчёт траектории и команда рулям должны поступить мгновенно для стабилизации полёта.
    3. **Медицинское оборудование:** например, аппарат ИВЛ должен подавать кислород в строго заданном ритме.
- **Soft Real-Time (мягкие дедлайны):**
    1. **Потоковое видео:** кадр должен быть декодирован вовремя, чтобы избежать «фризов», но пропуск одного кадра допустим.
    2. **Смартфон:** отклик на нажатие иконки должен быть быстрым для комфорта пользователя, но задержка не фатальна.

#### **В чём ключевое различие между hard real-time и soft real-time с точки зрения последствий пропуска дедлайна? ⭐⭐**:

- В **hard real-time** пропуск дедлайна недопустим и может вызвать **необратимые повреждения** системы или привести к аварии.
- В **soft real-time** периодический пропуск сроков нежелателен, но **приемлем** и не вызывает фатальных последствий для системы.

#### **Почему для мультимедиа-систем важна не только скорость, но и предсказуемость (jitter)? Как планировщик может влиять на качество аудио/видео? ⭐⭐⭐**:

Предсказуемость критична для поддержания **ритмичности** воспроизведения. **Jitter** (джиттер) — это вариация времени задержки; если аудиопроцесс работает неритмично, возникают неприятные «провалы» в звуке. Планировщик должен гарантировать выполнение мультимедийных задач через равные промежутки времени, чтобы синхронизация аудио и видео не нарушалась.

#### **Объясните, почему в некоторых real-time системах вытеснение «иногда не требуется». При каких предпосылках это возможно? ⭐⭐⭐**:

Вытеснение может не требоваться, если все задачи в системе **заранее определены**, контролируются и имеют малую длительность. В таких условиях процессы могут работать кооперативно: каждый поток выполняет свою короткую работу и добровольно передает управление, что упрощает логику ядра и снижает накладные расходы.

#### **Сравните периодические и непериодические события в real-time системах. Чем они отличаются с точки зрения планирования и гарантий? ⭐⭐**:

- **Периодические события:** происходят регулярно через фиксированные интервалы (например, опрос датчиков раз в 100 мс). Их нагрузку легко рассчитать заранее и дать **строгие гарантии** выполнения.
- **Непериодические события:** возникают случайно (например, тревожный сигнал или нажатие кнопки пользователем). Их сложнее планировать, так как они могут наложиться на выполнение критических периодических задач, создавая пиковые нагрузки.

#### **Раскройте смысл условия планируемости ($\sum (C_i/P_i) \le 1$). Что означают $C_i$ и $P_i$ физически и как интерпретировать сумму? ⭐⭐**:

- $C_i$ — время обработки события $i$ (CPU burst).
- $P_i$ — период появления события $i$. Отношение $C_i/P_i$ — это доля процессорного времени, которую потребляет данная задача. **Сумма всех таких отношений** представляет собой общую загрузку CPU всеми задачами реального времени. Условие $\le 1$ означает, что суммарные требования к процессору не превышают 100% его мощности.

#### **Почему при $\sum (C_i/P_i) > 1$ система принципиально не может быть запланирована? Какие стратегии остаются в таком случае? ⭐⭐⭐**:

Если сумма больше 1, значит, задачам требуется **больше времени, чем физически доступно** на процессоре. В таком случае дедлайны неизбежно будут пропущены. **Стратегии:**

1. Увеличить мощность (частоту) CPU.
2. Оптимизировать код задач для уменьшения $C_i$.
3. Отказаться от некоторых задач или перевести их в разряд soft real-time.

#### **В приведённом примере (Периоды: 100/200/500 мс и время обработки 50/30/100 мс) объясните, почему система считается планируемой? ⭐⭐**:

Расчёт нагрузки: $50/100 + 30/200 + 100/500 = 0.5 + 0.15 + 0.2 = \mathbf{0.85}$. Поскольку $0.85 \le 1$, процессор загружен на 85%, и у него есть запас в 15% времени, что позволяет успешно выполнять все задачи в срок.

#### **В каких реальных ситуациях допущение «накладные расходы на переключение контекста можно игнорировать» становится неверным? ⭐⭐⭐**:

Это допущение ложно, когда в системе очень **много коротких задач** с высокой частотой выполнения. Если время переключения контекста сопоставимо с временем обработки задачи ($C_i$), суммарные потери времени на работу ядра ОС станут критическими и приведут к срыву дедлайнов.

#### **Предложите метод, как учитывать накладные расходы при оценке планируемости. ⭐⭐⭐**:

В формулу планируемости к времени обработки каждой задачи $C_i$ нужно добавить фиксированное время переключения контекста $S$ и время обработки прерывания таймера. Уточнённая формула: $\sum ((C_i + S) / P_i) \le 1$. Это позволит более реалистично оценить доступный ресурс CPU.

#### **Почему добавление непериодических задач усложняет гарантии дедлайнов даже при выполнении условия для периодических задач? ⭐⭐⭐**:

Непериодические задачи вносят фактор **неопределённости**. Даже если периодические задачи загружают CPU на 80%, внезапное появление тяжелой непериодической задачи может мгновенно поднять нагрузку выше 100% в конкретный момент времени, вызывая задержку выполнения критических задач и пропуск их дедлайнов.

#### **В чём разница между static и dynamic scheduling в RT-системах? Какие сведения нужны «заранее» в статическом варианте? ⭐⭐**:

- **Static (статическое):** график выполнения всех задач рассчитывается полностью **до запуска** системы. Требует точного знания всех задач, их длительностей ($C_i$) и периодов ($P_i$) заранее.
- **Dynamic (динамическое):** решения о запуске задач принимаются планировщиком **во время работы** (на лету) на основе текущих приоритетов или дедлайнов.

#### **Приведите пример сценария, где статическое планирование предпочтительнее, и объясните, почему. ⭐⭐**:

Пример: **система управления полётом самолёта**. Здесь важна абсолютная предсказуемость и надежность. Все задачи известны заранее, и статический график позволяет математически доказать отсутствие конфликтов и пропусков дедлайнов ещё на этапе проектирования.

#### **Приведите пример сценария, где динамическое планирование неизбежно. ⭐⭐**:

Пример: **система управления сложным промышленным роботом**, работающим рядом с людьми. Робот должен мгновенно реагировать на внезапные изменения в окружении (например, человек зашел в зону работы). Такие события невозможно вписать в жесткий статический график заранее.

#### **Какие риски и ограничения появляются при статическом планировании, если «идеальная информация» недоступна или ошибочна? ⭐⭐⭐**:

Главный риск — **крах расписания**. Если реальное время выполнения задачи $C_i$ окажется больше запланированного, вся цепочка последующих задач сдвинется, что приведет к массовому пропуску дедлайнов. Статические системы крайне **негибкие**: любое изменение в коде требует полного пересчета и перепроверки всего расписания.

#### **Как бы вы объяснили компромисс «предсказуемость vs гибкость» между static и dynamic scheduling на уровне архитектуры? ⭐⭐⭐**:

- **Архитектура со статическим планированием** выбирает **максимальную предсказуемость** ценой отсутствия гибкости. Она идеальна для критических систем, где изменения не планируются (авиация, АЭС).
- **Архитектура с динамическим планированием** дает **гибкость** и способность адаптироваться к меняющейся нагрузке, но дает лишь вероятностную или менее жесткую предсказуемость (мультимедиа, общие задачи ОС).