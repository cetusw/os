#### **Почему мьютекс называют «упрощённым семафором»? В каких задачах семафор принципиально сильнее мьютекса? ⭐⭐**:

**Мьютекс** называют упрощённым семафором, потому что он предназначен исключительно для обеспечения **взаимного исключения** (mutual exclusion) и не требует возможности подсчёта ресурсов,. В то время как семафор может принимать любые неотрицательные значения, мьютекс находится только в двух состояниях: **заблокирован** (1) или **разблокирован** (0),.

**Семафор принципиально сильнее мьютекса в задачах:**

- **Упорядочивания событий (Ordering):** Например, в задаче производителя-потребителя семафоры `empty` и `full` контролируют порядок — нельзя брать данные из пустого буфера,.
- **Управления ограниченным количеством ресурсов:** Счётный семафор может позволить одновременно работать $K$ процессам, тогда как мьютекс — только одному,.

---

#### **Какие ошибки синхронизации мьютекс предотвращает, а какие не предотвращает? ⭐⭐**:

Мьютекс эффективно предотвращает **гонки данных (data races)** внутри критических секций, гарантируя, что только один поток одновременно манипулирует разделяемой памятью,.

Однако мьютекс **не предотвращает**:

- **Логические состояния гонки (race conditions):** Если сама архитектура программы ошибочна (например, два процесса одновременно решают занять одну и ту же ячейку в спулере печати до того, как сработает блокировка), мьютекс лишь сделает саму ошибку «упорядоченной»,.
- **Нарушение инвариантов:** Если поток аварийно завершается внутри критической секции, не освободив мьютекс, данные могут остаться в промежуточном (некорректном) состоянии, а остальные потоки окажутся в состоянии вечного ожидания,.

---

#### **Объясните, почему «достаточно 1 бита», но на практике состояние мьютекса хранится как целое число/слово. ⭐⭐**:

Концептуально для хранения состояния «занят/свободен» действительно достаточно **одного бита**,. Однако на практике используются целые числа (32 или 64 бита) по нескольким причинам:

1. **Архитектурная эффективность:** Процессоры работают с машинными словами гораздо быстрее, чем с отдельными битами,.
2. **Атомарные инструкции:** Стандартные инструкции синхронизации, такие как **TSL** или **XCHG**, оперируют ячейками памяти размером со слово,.
3. **Дополнительная информация:** В это же слово ОС может записывать идентификатор владельца мьютекса или информацию об очереди ожидающих потоков,.

---

#### **Разберите реализацию mutex_lock через TSL: что происходит при конкуренции, и почему используется thread_yield()? ⭐⭐**:

Реализация `mutex_lock` начинается с выполнения атомарной инструкции **TSL** (Test and Set Lock), которая считывает значение переменной мьютекса в регистр и устанавливает её в 1,.

- **При конкуренции:** Если поток видит, что мьютекс уже был равен 1 (занят), он не может войти в критическую секцию,.
- **Использование `thread_yield()`:** Вместо того чтобы крутиться в бесконечном цикле (активное ожидание), поток вызывает `thread_yield()`, чтобы добровольно отдать остаток своего кванта времени планировщику,. Это позволяет запуститься другим потокам, включая того, кто должен освободить замок,.

---

#### **Чем подход mutex_lock + yield отличается от чистого спинлока? Когда yield ухудшает ситуацию? ⭐⭐⭐**:

- **Отличие:** Чистый спинлок использует **активное ожидание (busy waiting)**, занимая CPU на 100%, пока замок не освободится,. Подход с `yield` переводит поток в состояние готовности (ready), освобождая процессор для полезной работы других задач,.
- **Когда `yield` хуже:** Если время критической секции крайне мало (считанные такты), затраты на **переключение контекста**, неизбежное при `yield`, будут во много раз выше, чем цена короткого активного ожидания в спинлоке,. Также `yield` неэффективен, если в системе больше нет готовых к работе потоков,.

---

#### **Зачем нужен trylock()? Приведите пример алгоритма, где trylock позволяет избежать дедлока или улучшить latency. ⭐⭐**:

Примитив `trylock()` пытается захватить блокировку и немедленно возвращает результат (успех/неудача), не блокируя поток,.

**Пример (избежание дедлока):** Если алгоритму нужны два мьютекса ($A$ и $B$), поток может захватить $A$, а затем вызвать `trylock(B)`,. Если $B$ занят, поток **освобождает** уже захваченный $A$ и пробует снова через некоторое время, вместо того чтобы встать в вечное ожидание и создать дедлок с другим потоком, который держит $B$ и ждёт $A$,. Это также улучшает **latency**, позволяя потоку выполнять другую работу, пока ресурс занят.

---

#### **Почему мьютексы «естественно» работают для потоков, но требуют дополнительных механизмов для процессов? ⭐⭐**:

Потоки одного процесса делят общее **адресное пространство**, поэтому переменная мьютекса «видна» всем нитям напрямую в памяти,. Процессы же **изолированы** друг от друга: адрес `0x42` в одном процессе физически не совпадает с тем же адресом в другом,. Для координации процессов ОС должна создать область памяти, доступную обоим, или управлять объектом синхронизации в пространстве ядра,.

---

#### **Какие способы межпроцессного мьютекса возможны: ядровые объекты, shared memory, файлы? ⭐⭐⭐**:

1. **Объекты ядра (например, в Windows):** Мьютекс хранится в памяти ОС, доступ осуществляется через системные вызовы и **HANDLE**,. _Плюс:_ высокая надёжность. _Минус:_ медленно из-за переходов в режим ядра.
2. **Shared Memory (общая память):** Переменная мьютекса размещается в сегменте памяти, отображённом в оба процесса,. _Плюс:_ максимальная скорость (уровень потоков). _Минус:_ требует аппаратной поддержки атомарности (TSL/XCHG).
3. **Файлы (Lock-файлы):** Использование системного вызова для блокировки файла или его создания,. _Плюс:_ персистентность (сохраняется после перезагрузки). _Минус:_ очень медленно из-за работы с дисковой подсистемой.

---

#### **Какие свойства должен иметь мьютекс, чтобы быть безопасным для межпроцессной синхронизации? ⭐⭐⭐**:

Для безопасности в межпроцессной среде мьютекс должен:

- Обладать **атомарностью операций**: проверка и установка должны быть неделимыми на аппаратном уровне,.
- Обеспечивать **корректное поведение при сбое:** если процесс, владеющий мьютексом, аварийно завершается (terminated), ОС должна иметь механизм автоматического освобождения замка, чтобы не заблокировать систему навсегда,.
- Быть **защищённым от подмены:** только авторизованные процессы должны иметь право манипулировать данным замком,.

---

#### **Почему «мьютекс в user space» обычно быстрее, чем ядровая блокировка, и в каких случаях это перестаёт быть правдой? ⭐⭐⭐**:

Блокировка в пользовательском пространстве (например, через библиотеку потоков) быстрее, так как не требует **системного вызова** и переключения процессора в режим ядра, что экономит сотни тактов,.

Это **перестаёт быть правдой**, когда возникает высокая **конкуренция (contention)**,. Если поток в user space не может захватить замок и просто делает `yield`, он тратит ресурсы на бесполезные переключения,. В таких случаях эффективнее использовать **futex** (Linux), который работает в user space только пока нет конфликтов, но мгновенно передаёт управление ядру для организации очереди сна, если ресурс занят,.