#### **Что такое адресное пространство процесса, и почему «несколько процессов в памяти» требуют аппаратной поддержки? ⭐⭐**:

**Адресное пространство процесса** представляет собой абстракцию набора адресов памяти, которые процесс может использовать для чтения и записи данных,. Оно включает в себя исполняемый код программы, данные и стек,. В современных системах это пространство изолировано: адрес `28` в одном процессе логически не связан с тем же адресом в другом процессе,.

**Необходимость аппаратной поддержки** при размещении нескольких программ в памяти обусловлена двумя факторами:

1. **Защита:** Без аппаратного контроля ошибка в одной программе может привести к перезаписи данных другого процесса или кода самой операционной системы,,.
2. **Релокация (перемещение):** Поскольку ОС должна иметь возможность загрузить программу в любой свободный участок физической памяти, требуется механизм динамического отображения программных адресов на реальные физические адреса,.

**Иллюзия изоляции в памяти:**

```
Физическая память (RAM)
+-----------------------+
|  Операционная система | (защищено)
+-----------------------+
|  Процесс А (0...Max)  | <--- Аппаратная граница (Limit)
+-----------------------+
|  Свободная область    |
+-----------------------+
|  Процесс Б (0...Max)  | <--- Базовый адрес (Base)
+-----------------------+
```

Аппаратные средства (регистры базы и границы или MMU) гарантируют, что процесс А физически не сможет «дотянуться» до памяти процесса Б.

---

#### **Как процессор и ОС вместе обеспечивают, что процесс не может читать/писать память другого процесса? (Опишите на уровне идеи.) ⭐⭐⭐**:

Изоляция обеспечивается за счет совместной работы программного обеспечения (ОС) и аппаратных блоков (процессора и **MMU**),,.

**Основные идеи механизма:**

1. **Создание таблиц отображения (ОС):** Операционная система создает и управляет специальными структурами данных — **таблицами страниц**, в которых прописано, какой виртуальный адрес процесса соответствует какому физическому адресу в оперативной памяти,.
2. **Трансляция «на лету» (Процессор/MMU):** При каждой попытке программы обратиться к памяти процессор передает виртуальный адрес в блок **MMU (Memory Management Unit)**,. MMU проверяет таблицу страниц: если для этого адреса нет записи или у процесса нет прав доступа (например, попытка записи в страницу «только для чтения»), аппаратура генерирует исключение — **page fault** или **segmentation fault**,,.
3. **Привилегированное управление:** Только ОС в режиме ядра имеет право изменять таблицы страниц и регистры (такие как `CR3` в x86), определяющие текущую карту памяти,,.

```
Процесс (User Mode) -> Виртуальный адрес -> [ MMU ] -> Физический адрес -> RAM
                                             ^
                                             |
                                     [ Таблица страниц ] (настроена ОС)
```

Если процесс пытается указать адрес вне своей «карты», MMU блокирует операцию еще до того, как она затронет физическую память,.

---

#### **Что такое режим пользователя и режим ядра, и почему системные вызовы требуют перехода между ними? ⭐⭐**:

Для обеспечения стабильности современные процессоры поддерживают как минимум два режима работы,,.

- **Режим пользователя (User mode):** В этом режиме программе доступно только подмножество инструкций процессора,. Ей запрещено напрямую управлять вводом-выводом, изменять таблицы памяти или отключать прерывания,,.
- **Режим ядра (Kernel mode / Supervisor mode):** В этом режиме ОС имеет полный доступ ко всему оборудованию и может выполнять любые инструкции,,.

**Причина перехода при системных вызовах:** Поскольку прикладным программам запрещено напрямую общаться с «железом» в целях безопасности, они должны запрашивать услуги у ОС,. Когда программе нужно прочитать файл или выделить память, она выполняет инструкцию-ловушку (**trap**), которая переключает процессор из пользовательского режима в режим ядра и передает управление коду ОС,,. Это позволяет ОС проверить правомочность запроса перед тем, как выполнить опасную операцию с оборудованием,.

---

#### **Почему ранние системы могли обходиться без защиты памяти, и какие компромиссы это накладывало на надёжность? ⭐⭐**:

Ранние компьютеры (первое и второе поколения, а также первые микрокомпьютеры) проектировались для выполнения **одной программы за раз**,,.

**Причины отсутствия защиты:**

- **Ограниченность ресурсов:** Память была крайне мала (например, 128 КБ в IBM 7094), и аппаратные схемы защиты считались слишком дорогими и сложными,.
- **Отсутствие многозадачности:** Поскольку в памяти находилась только одна программа и сама ОС, считалось достаточным, что программист полностью контролирует машину,.

**Компромиссы в надёжности:** Любая ошибка (баг) в прикладной программе могла привести к затиранию кода операционной системы в памяти,. Это вызывало немедленный крах всей системы, требующий физической перезагрузки. Безопасность данных также была минимальной: пользовательский код мог беспрепятственно читать системные пароли или данные предыдущих запусков, если они оставались в RAM.

---

#### **Почему во встраиваемых системах защита памяти иногда отсутствует и сегодня: когда это оправдано, а когда — нет? ⭐⭐⭐**:

Многие современные микроконтроллеры и встраиваемые устройства (например, в микроволновых печах или смарт-картах) до сих пор работают без аппаратной защиты памяти,,.

**Когда это оправдано:**

1. **Фиксированный софт:** Программное обеспечение «зашито» в ПЗУ (ROM) на заводе, и пользователь не может устанавливать сторонние приложения,.
2. **Экономия:** Отсутствие MMU упрощает конструкцию чипа, снижает его стоимость и энергопотребление,.
3. **Полное доверие:** Все программные компоненты написаны одним производителем и тщательно протестированы на совместимость, что исключает конфликт интересов между «разными пользователями»,.

**Когда это НЕ оправдано:** В системах, требующих выхода в интернет (IoT), запуска кода от разных поставщиков (современные камеры с приложениями) или высокой отказоустойчивости (медицинская техника, авиация),,. В таких случаях отсутствие изоляции делает систему уязвимой для хакеров: взлом одного компонента дает полный контроль над всем устройством,.

---

#### **Объясните идею виртуальной памяти: какие иллюзии она создаёт для процесса и какие задачи решает для ОС? ⭐⭐**:

**Виртуальная память** — это техника, которая отделяет логические адреса, используемые программой, от физических адресов оперативной памяти,.

**Создаваемые иллюзии:**

1. **Непрерывность:** Процесс видит свою память как единый линейный массив от 0 до максимума, даже если физически его данные разбросаны кусками по всей RAM,.
2. **Безграничность:** Программе кажется, что ей доступен огромный объем памяти (например, все 4 ГБ в 32-битной системе), даже если физической RAM в компьютере всего 512 МБ,,.

**Задачи, решаемые для ОС:**

- **Эффективное использование ресурсов:** ОС может держать в памяти только активные части программ, выгружая неиспользуемые на диск,,.
- **Изоляция:** Каждый процесс работает в своем «пузыре», не имея физической возможности обратиться к чужим данным,.
- **Упрощение загрузки:** Программу можно загрузить в любой свободный фрагмент RAM, просто обновив таблицу страниц в MMU,.

---

#### **Что такое swap и в каких случаях его использование помогает, а в каких — «убивает» производительность? ⭐⭐**:

**Swap (подкачка)** — это область на жестком диске или SSD, которая используется операционной системой для временного хранения содержимого оперативной памяти, которое не помещается в физическую RAM,,.

**Когда swap помогает:**

- **Запуск тяжелых приложений:** Позволяет системе не выдавать ошибку «недостаточно памяти» при открытии множества вкладок браузера или больших файлов, вытесняя фоновые, неактивные задачи на диск,.
- **Стабилизация системы:** Дает ОС время на перераспределение ресурсов вместо немедленного завершения процессов через OOM Killer,.

**Когда swap «убивает» производительность:** Это происходит при **thrashing** (метании) — ситуации, когда суммарный объем активно используемых данных всех программ превышает физическую RAM,. Система начинает тратить почти всё время процессора на бесконечное перемещение страниц между диском и памятью,. Так как диск в тысячи раз медленнее RAM, компьютер перестает реагировать на действия пользователя («зависает»),.

---

#### **Как связаны «страницы памяти», подкачка и то, что программа может адресовать больше, чем физическая RAM? ⭐⭐⭐**:

Эта связь реализуется через механизм **страничной организации (paging)**.

1. **Разбиение:** Все виртуальное адресное пространство программы делится на блоки фиксированного размера — **страницы** (например, по 4 КБ),. Физическая память тоже делится на такие же блоки — **фреймы**,.
2. **Отображение:** ОС ведет таблицу страниц, где для каждой виртуальной страницы указано: находится ли она в RAM (фрейме) или выгружена на диск (**подкачка**),,.
3. **Принцип работы:** Когда программа обращается к адресу, MMU проверяет таблицу. Если страница в RAM — доступ мгновенный. Если страницы нет в памяти (**бит присутствия равен 0**), возникает прерывание,. ОС приостанавливает программу, находит свободный фрейм, загружает туда страницу с диска и возобновляет работу программы,.

Благодаря этому процессу программа может иметь размер в 10 ГБ на компьютере с 2 ГБ RAM: она просто обращается к нужным 2 ГБ в данный момент, а остальные 8 ГБ «ждут своего часа» в файле подкачки на диске,,.

---

#### **Как бы вы интерпретировали вывод `free -h` и `vmstat`: какие поля укажут на активную подкачку и дефицит памяти? ⭐⭐⭐**:

В Linux эти инструменты позволяют диагностировать состояние подсистемы памяти.

**Интерпретация `free -h`:**

- **Mem / free:** Если это значение близко к нулю, физическая память почти исчерпана.
- **Mem / available:** Самый важный показатель; показывает, сколько памяти реально можно отдать процессам без ухода в жесткий своп.
- **Swap / used:** Если здесь значение растет и не равно 0, значит, часть данных уже вытеснена на диск.

**Интерпретация `vmstat`:**

- **si (swap-in):** Количество данных, считываемых из свопа в секунду.
- **so (swap-out):** Количество данных, записываемых в своп.
- **Дефицит памяти:** Если значения в колонках `si` и `so` постоянно высоки (активное перемещение данных), это верный признак нехватки RAM и снижения производительности из-за подкачки.
- **Колонка b (blocked):** Если здесь много процессов, это часто означает, что они «застряли» в ожидании медленного диска при подкачке страниц.

---

#### **Почему виртуальная память упрощает код прикладных программ, а не только «даёт больше памяти»? Приведите пример. ⭐⭐⭐**:

Виртуальная память избавляет программиста от необходимости управлять физическим размещением данных и фрагментацией,,.

**Причины упрощения:**

1. **Линейность:** Программа всегда видит «чистое» и непрерывное адресное пространство, начиная с адреса 0, независимо от того, насколько фрагментирована реальная RAM,.
2. **Отсутствие релокации вручную:** Разработчику не нужно пересчитывать адреса переходов (`JMP`) в коде в зависимости от того, куда загружена программа; MMU делает это автоматически,.
3. **Динамическая загрузка:** Можно использовать общие библиотеки (DLL/Shared Objects), которые загружаются в память в единственном экземпляре и отображаются в адресные пространства разных процессов по разным виртуальным адресам,,.

**Пример:** В эпоху до виртуальной памяти программисты использовали **оверлеи (overlays)** — они вручную разбивали программу на куски и писали сложный код, который выгружал одну часть функций из памяти, чтобы загрузить другую. С виртуальной памятью программист просто пишет код любого размера, а ОС сама решает, какие функции подгрузить с диска именно сейчас, делая этот процесс абсолютно прозрачным для приложения,.