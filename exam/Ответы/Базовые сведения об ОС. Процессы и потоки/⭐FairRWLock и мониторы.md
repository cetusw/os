#### **В чём идея writer-preferred RWLock и как она предотвращает starvation писателей? ⭐⭐**:

Идея **writer-preferred RWLock** (честной реализации Reader-Writer Lock) заключается в том, что при появлении хотя бы одного ожидающего писателя «ворота закрываются» для всех новых читателей. В стандартных реализациях, таких как `std::shared_mutex`, возможна ситуация **голодания (starvation) писателей**: если поток читателей непрерывен (новые приходят до того, как ушли старые), замок всегда будет находиться в разделяемом состоянии, и писатель никогда не получит эксклюзивный доступ. Writer-preferred политика принудительно заставляет новых читателей ждать в очереди, пока все текущие читатели закончат работу и накопившиеся писатели не выполнят свои задачи.

---

#### **Какие поля нужны FairRWLock и какие инварианты они должны соблюдать? ⭐⭐⭐**:

Для реализации **FairRWLock** (на примере архитектуры из источников) требуются следующие поля:

1. **`std::mutex m_mutex`**: для защиты внутренних переменных состояния.
2. **`std::condition_variable m_readers` и `m_writers`**: отдельные условные переменные для очередей читателей и писателей.
3. **`int m_numActiveReaders`**: счетчик активных читателей.
4. **`int m_numWaitingWriters`**: счетчик писателей, стоящих в очереди.
5. **`bool m_isWriterActive`**: флаг, указывающий, выполняет ли сейчас работу писатель.

**Ключевые инварианты:**

- Если `m_isWriterActive == true`, то `m_numActiveReaders` обязан быть равен 0.
- Если `m_numActiveReaders > 0`, то `m_isWriterActive` обязан быть `false`.
- Читатели могут войти только если `m_isWriterActive == false` **И** `m_numWaitingWriters == 0`.

---

#### **Почему в lock_shared() читатели должны ждать не только active_writer == false, но и waiting_writers == 0? ⭐⭐⭐**:

Это критическое условие для предотвращения голодания писателей. Если читатели будут проверять только отсутствие активного писателя, они смогут постоянно заходить в критическую секцию друг за другом, «перепрыгивая» через стоящего в очереди писателя. Требование **`m_numWaitingWriters == 0`** гарантирует, что если писатель уже выразил намерение (встал в очередь), ни один новый читатель не будет допущен в систему, пока писатель не завершит работу.

---

#### **Объясните логику пробуждений: почему в unlock() иногда будим писателя, а иногда всех читателей? ⭐⭐⭐**:

В методе `unlock()` (завершение работы писателя) логика пробуждения строится на приоритетах:

1. **Приоритет писателям:** Если есть хотя бы один ожидающий писатель (`m_numWaitingWriters > 0`), мы вызываем `m_writers.notify_one()`. Это позволяет одному писателю выйти из ожидания, сохраняя эксклюзивность доступа.
2. **Пробуждение читателей:** Если ожидающих писателей нет, мы вызываем `m_readers.notify_all()`, разрешая **всем** накопившимся читателям войти одновременно, так как они не блокируют друг друга при чтении.

---

#### **Какие типичные ошибки приводят к дедлоку или «зависанию» в RWLock? ⭐⭐⭐**:

К сбоям в работе RWLock обычно приводят следующие ошибки проектирования:

- **Неверные условия ожидания:** если в `lock_shared()` забыть проверку `m_numWaitingWriters`, возникнет голодание писателей.
- **Ошибки сигнализации:** использование `notify_one()` вместо `notify_all()` для читателей приведет к тому, что проснется только один читатель, а остальные останутся «висеть», хотя ресурс свободен.
- **«Наивный апгрейд»:** попытка перейти из `shared_lock` в `unique_lock` без промежуточного освобождения мьютекса почти всегда ведет к **дедлоку**, так как два читателя могут одновременно ждать освобождения друг друга для записи.

---

#### **Почему мониторы появились как реакция на «опасность семафоров»? Какие классы ошибок они уменьшают? ⭐⭐**:

Работа с семафорами и мьютексами напрямую крайне сложна и опасна: малейшая ошибка в порядке вызовов `down()` и `up()` или пропущенный вызов приводят к дедлокам, которые трудно воспроизвести. Мониторы (предложенные Хоаром и Бринч Хансеном) — это более высокоуровневый механизм, объединяющий данные и процедуры их обработки в защищенный модуль. Они уменьшают количество ошибок **взаимного исключения**, так как компилятор или рантайм берет на себя автоматическую блокировку при входе в процедуры монитора и освобождение при выходе.

---

#### **Что означает «только один поток активен в мониторе» и как это реализуется на практике? ⭐⭐**:

Это означает, что в любой момент времени код внутри процедур монитора может исполнять только одна нить. На практике это реализуется рантаймом языка или компилятором через **неявный мьютекс**, который захватывается перед началом выполнения любой публичной функции объекта-монитора и автоматически отпускается по завершении (даже при исключениях).

---

#### **Сравните семантику сигнализации Хоара и Бринч Хансена: кто продолжает выполнение после signal() и почему это важно. ⭐⭐⭐**:

Эта разница определяет состояние системы в момент передачи управления:

- **Семантика Хоара:** После вызова `signal()` пробужденный поток выполняется **немедленно**, а сигнализирующий поток приостанавливается. Это гарантирует, что условие, на котором ждал поток, не изменится.
- **Семантика Бринч Хансена (принята в Java и C++):** Поток, вызвавший `signal()`, обязан немедленно выйти из монитора (или продолжить выполнение до выхода), и только после освобождения монитора проснется ждущий поток. Это проще в реализации и эффективнее, но требует от пробужденного потока повторной проверки условия в цикле `while` из-за риска «ложных пробуждений».

---

#### **Почему даже в мониторах сигналы condition variables «не копятся»? Какие последствия это имеет для дизайна? ⭐⭐⭐**:

В отличие от семафоров, условные переменные в мониторах **не имеют памяти** о прошлых сигналах: если `signal()` вызван, когда в очереди нет ожидающих потоков, сигнал просто бесследно исчезает. **Последствие для дизайна:** Программист не может полагаться только на факт сигнала. Необходимо всегда иметь **переменную состояния** (например, `count`), которую поток проверяет перед сном, и использовать цикл `while` для ожидания, чтобы убедиться, что условие все еще истинно после пробуждения.

---

#### **Как модель монитора в Java отличается от «классического» монитора с отдельными condition variables? ⭐⭐⭐**:

В «классическом» мониторе (как в Concurrent Pascal) можно объявить несколько независимых условных переменных (например, отдельно `full` и `empty`). В Java модель упрощена:

- У каждого объекта есть только **одна** встроенная очередь ожидания и одна пара методов `wait()` / `notify()`.
- Для пробуждения конкретного класса потоков (например, только потребителей) в Java часто приходится использовать `notifyAll()`, что будит всех подряд, снижая производительность, тогда как в классическом мониторе можно подать точечный сигнал на нужную переменную.

---

#### **Какие проблемы появляются при IPC через сообщения в распределённой среде: потери, дубликаты, порядок, подмена отправителя? ⭐⭐**:

При переходе от общей памяти к обмену сообщениями (особенно через сеть) возникают новые вызовы:

1. **Потеря данных:** Сообщение или подтверждение (ACK) может не дойти.
2. **Дубликаты:** Если ACK потерялся, отправитель пришлет копию сообщения.
3. **Нарушение порядка:** Пакеты могут идти разными путями и прийти не в той последовательности, в которой были отправлены.
4. **Безопасность:** Риск подмены отправителя (spoofing) требует механизмов аутентификации.

---

#### **Зачем нужны ACK + ретрансляции и почему это сразу приводит к необходимости sequence numbers? ⭐⭐⭐**:

Чтобы гарантировать доставку, получатель должен отправить подтверждение (**ACK**). Если отправитель не получил ACK за определенное время, он выполняет **ретрансляцию** (повторную отправку). Это неизбежно порождает проблему дубликатов: если первое сообщение дошло, а ACK потерялся, получатель увидит сообщение второй раз. Для того чтобы отличить новое сообщение от повтора старого, используются **sequence numbers** (порядковые номера) — получатель запоминает номер последнего обработанного сообщения и игнорирует дубликаты.

---

#### **Чем отличается адресация «процесс → процесс» от mailboxes? Как mailboxes помогают масштабировать систему? ⭐⭐**:

- **Процессная адресация:** Отправитель явно указывает PID получателя (`send(procA, msg)`). Это создает тесную связь между компонентами.
- **Mailboxes (почтовые ящики):** Сообщения отправляются в промежуточный буфер (ящик), из которого получатель их забирает. **Масштабируемость:** Почтовые ящики позволяют реализовать модель «много-ко-многим». Несколько потребителей могут читать из одного ящика, что позволяет легко добавлять новые вычислительные узлы без перенастройки отправителей.

---

#### **Сравните rendezvous (без буфера) и буферизированный обмен: какие плюсы/минусы? ⭐⭐⭐**:

- **Rendezvous (Рандеву):** Прямая передача без буфера. `send` блокируется, пока не встретится с `receive`.
    - _Плюсы:_ Максимальная простота реализации, отсутствие затрат памяти на очереди.
    - _Минусы:_ Низкая пропускная способность из-за жесткой синхронизации (lockstep).
- **Буферизированный обмен:** Сообщения копятся в очереди.
    - _Плюсы:_ Гибкость, высокая пропускная способность (throughput), так как отправитель не ждет моментального приема.
    - _Минусы:_ Сложность управления памятью, риск переполнения буферов и задержки (latency) при больших очередях.

---

#### **Объясните producer–consumer без общей памяти через «пустые/полные» сообщения: какой инвариант делает систему корректной? ⭐⭐⭐**:

В этой модели вместо ячеек памяти используются сообщения.

1. **Инициализация:** Потребитель отправляет производителю $N$ «пустых» сообщений.
2. **Производитель:** Берет «пустое», наполняет данными и шлет «полное» потребителю.
3. **Потребитель:** Берет «полное», извлекает данные и возвращает «пустое» производителю.

**Ключевой инвариант:** Общее количество сообщений в системе (пустых + полных) всегда равно **$N$** (емкости воображаемого буфера). Это гарантирует, что производитель никогда не создаст больше данных, чем может обработать потребитель, даже без доступа к общей памяти.