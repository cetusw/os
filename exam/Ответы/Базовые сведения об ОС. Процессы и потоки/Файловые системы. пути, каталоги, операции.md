#### **Почему файловая система считается ключевой абстракцией ОС, и какие детали устройств она скрывает? ⭐⭐**:

Файловая система является критически важной абстракцией, поскольку она превращает «ужасный» и сложный интерфейс физических носителей данных в «красивую» и удобную модель для пользователя и программиста. Основная задача этой абстракции — скрыть особенности работы аппаратного обеспечения, такие как перемещение головок диска, ожидание поворота шпинделя и управление секторами.

**Детали, которые скрывает файловая система:**

- **Физическая адресация:** Вместо оперирования номерами цилиндров, головок и секторов (как в SATA-дисках, описание интерфейса которых занимает сотни страниц), программист работает с именованными файлами.
- **Тип носителя:** ОС предоставляет единый интерфейс для работы с HDD (магнитными пластинами) и SSD (флэш-памятью), несмотря на их принципиально разное внутреннее устройство.
- **Фрагментация и размещение:** Пользователю не нужно знать, в каких именно физических блоках диска расположены части его данных — ФС сама отслеживает занятые и свободные блоки.

**Модель абстракции:**

```
+-----------------------+
|  Прикладная программа | <--- Видит "Файл.txt"
+-----------------------+
|   Файловая система    | <--- Транслирует имя в блоки
+-----------------------+
|   Драйвер диска       | <--- Командует контроллеру
+-----------------------+
|   Физический диск     | <--- Сектор 1024, Головка 2
+-----------------------+
```

---

#### **Объясните разницу между абсолютным и относительным путём и роль текущего рабочего каталога процесса. ⭐**:

Для поиска файла в иерархической структуре ОС использует концепцию путей.

- **Абсолютный путь:** Задаёт точное местоположение файла, начиная от корня системы. Он всегда начинается с разделителя (например, `/` в UNIX) и не зависит от того, где сейчас находится пользователь. Пример: `/Faculty/Prof.Brown/Courses/CS101`.
- **Относительный путь:** Указывается относительно **текущего рабочего каталога (CWD)** процесса. Если рабочий каталог — `/Faculty/Prof.Brown`, то относительный путь к файлу будет просто `Courses/CS101`.
- **Роль рабочего каталога:** Каждому процессу сопоставлен свой CWD, что позволяет программистам не вводить длинные абсолютные пути при каждом обращении к файлам. Процесс может менять свой рабочий каталог с помощью системного вызова `chdir`.

---

#### **Как устроена иерархия каталогов как «дерево», и какие преимущества даёт по сравнению с одноуровневой директорией? ⭐⭐**:

В иерархической системе каталоги организованы в виде дерева, где корень (root) является отправной точкой, а ветви могут содержать как файлы, так и другие вложенные каталоги.

**Преимущества перед одноуровневой системой:**

1. **Группировка данных:** Файлы можно распределять по темам, проектам или пользователям (например, отдельный каталог для каждого курса студента).
2. **Отсутствие конфликтов имен:** В одноуровневой системе все файлы на диске должны иметь уникальные имена. В дереве два файла с именем `data.txt` могут спокойно существовать в разных ветвях (например, в `/Project1/data.txt` и `/Project2/data.txt`).
3. **Масштабируемость:** Дерево позволяет эффективно управлять миллионами файлов, в то время как плоский список становится нечитаемым и медленным при росте их числа.

---

#### **Почему операции `open/read/write/close` считаются «минимальным набором» для работы с данными? Что строится поверх них? ⭐⭐**:

Этот набор системных вызовов обеспечивает полный жизненный цикл доступа к данным файла.

- `open`: Находит файл на диске, проверяет права доступа и возвращает **файловый дескриптор** для быстрой работы.
- `read/write`: Позволяют перемещать байты между памятью процесса и носителем.
- `close`: Освобождает ресурсы ОС, когда работа закончена.

**Что строится поверх них:** На базе этих примитивов создаются высокоуровневые библиотеки (например, `iostream` в C++), базы данных (DBMS), системы управления контентом и даже сама сетевая передача данных в UNIX-системах.

---

#### **Чем отличается удаление файла от удаления каталога (`rm` vs `rmdir`), и почему каталог нельзя удалить, пока он не пуст? ⭐⭐**:

- **Удаление файла (`rm` / `unlink`):** Удаляет имя файла из каталога. Если это была последняя ссылка на файл, ОС освобождает блоки данных на диске.
- **Удаление каталога (`rmdir`):** Удаляет саму структуру директории из ФС.

**Почему каталог должен быть пуст:** ОС запрещает удаление непустых каталогов, чтобы предотвратить **случайную потерю целых деревьев данных** и гарантировать целостность файловой системы. Если бы это было разрешено, ссылки на файлы внутри этого каталога могли бы стать «висячими», что привело бы к несогласованности структур данных на диске. Для удаления каталога с содержимым используются рекурсивные утилиты (например, `rm -r`), которые сначала поочередно удаляют все файлы внутри.

---

#### **Что такое монтирование и почему модель «единое дерево» отличается от «букв дисков» в Windows? ⭐⭐**:

**Монтирование** — это процесс присоединения файловой системы внешнего устройства (USB-флешки, диска) к общему дереву каталогов в определенной точке (mount point).

**Различия моделей:**

- **Модель «Буквы дисков» (Windows):** Каждое устройство существует как отдельная иерархия со своей корневой буквой (`C:`, `D:`). Это заставляет прикладные программы учитывать физическое расположение данных (на каком диске лежит файл), что создает зависимость от оборудования.
- **Модель «Единое дерево» (UNIX/VFS):** Все устройства интегрируются в одну общую иерархию. Например, флешка может быть смонтирована в `/mnt/usb`. Приложению не важно, находится ли файл на жестком диске или на USB — путь выглядит единообразно. Это делает систему гибче и позволяет подменять физические носители прозрачно для софта.

---

#### **Объясните роль `/dev` и смысл «специальных файлов»: что это даёт ОС и приложениям? ⭐⭐**:

Каталог `/dev` содержит **специальные файлы**, которые являются программными интерфейсами для физических устройств.

- **Блочные специальные файлы:** Используются для устройств с произвольным доступом (диски, SSD). Программа может открыть `/dev/sda` и прочитать конкретный блок данных в обход ФС.
- **Символьные специальные файлы:** Моделируют устройства, работающие с потоком байтов (клавиатуры, принтеры, терминалы).

**Что это даёт:** Это реализует принцип унификации: приложения могут работать с оборудованием, используя те же системные вызовы (`read`, `write`), что и для обычных файлов. ОС это позволяет централизованно управлять правами доступа к «железу» через стандартную модель прав ФС.

---

#### **Что такое pipe в терминах потока данных: почему он выглядит как файл, но ведёт себя иначе? ⭐⭐**:

**Канал (pipe)** — это псевдофайл, служащий для межпроцессного взаимодействия (IPC), соединяющий стандартный вывод одного процесса со стандартным вводом другого.

**Почему выглядит как файл:** Для процесса чтение из канала и запись в него ничем не отличаются от вызовов `read(fd, ...)` и `write(fd, ...)` для обычного файла на диске.

**Почему ведет себя иначе:** В отличие от обычного файла, данные в канале не сохраняются на диске навсегда. Если процесс-читатель запрашивает данные, а процесс-писатель еще ничего не отправил, читатель будет **заблокирован** до появления данных. Как только данные вычитаны, они удаляются из буфера канала.

---

#### **Зачем существуют `/dev/stdout` и `/dev/null`: какие практические сценарии они упрощают? ⭐**:

Это специальные файлы-интерфейсы для управления потоками данных в системе.

- **`/dev/stdout`:** Позволяет программе обращаться к своему стандартному выводу как к файлу.
    - _Сценарий:_ Утилита ожидает имя выходного файла в качестве аргумента. Чтобы вывести результат прямо в терминал, ей можно передать путь `/dev/stdout`.
- **`/dev/null`:** Это «черная дыра» системы. Всё, что записано в него, мгновенно исчезает, а чтение из него всегда возвращает конец файла (EOF).
    - _Сценарий:_ Вам нужно запустить программу, но вы не хотите видеть её сообщения об ошибках. Вы перенаправляете вывод ошибок: `myprog 2> /dev/null`. Также он используется демонами для закрытия стандартных потоков при переходе в фоновый режим.