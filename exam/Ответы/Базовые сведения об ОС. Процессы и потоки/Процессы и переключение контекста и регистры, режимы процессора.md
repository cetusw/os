#### **Что такое context switch и почему при нём важно сохранять/восстанавливать состояние процессора? ⭐⭐**:

**Переключение контекста (context switch)** — это процедура остановки выполнения одного процесса и запуска другого процессора, выполняемая операционной системой в многопрограммных системах,. Несмотря на то, что в каждый момент времени процессор (ядро) выполняет только одну задачу, быстрая смена процессов создает иллюзию параллелизма, называемую псевдопараллелизмом,.

**Важность сохранения и восстановления состояния:**

1. **Непрерывность выполнения:** С точки зрения процесса прерывание должно быть незаметным; после возобновления он должен продолжить работу ровно с той инструкции и с теми же данными в регистрах, которые были на момент остановки,.
2. **Изоляция данных:** Каждый процесс обладает своим набором переменных и состоянием регистров. Без восстановления состояния данные одного процесса могли бы быть повреждены действиями другого.
3. **Абстракция «Виртуального CPU»:** ОС предоставляет каждому процессу модель его собственного процессора. Переключение контекста — это физическая реализация этой абстракции.

**Процесс переключения в псевдографике:**

```
  Процесс A          Ядро ОС (Планировщик)        Процесс B
      |                       |                       |
  [Выполнение]                |                       |
      |---(Прерывание/Таймер)-->|                       |
      |                       |                       |
      |                 (1) СОХРАНЕНИЕ                |
      |                 состояния A в                 |
      |               таблицу процессов               |
      |                       |                       |
      |                 (2) ЗАГРУЗКА                  |
      |                 состояния B из                |
      |               таблицы процессов               |
      |                       |                       |
      |                       |---(Возврат из прер.)->|
      |                       |                  [Выполнение]
```

При переключении ОС должна выполнить переход в режим ядра, сохранить регистры, обновить таблицы памяти (MMU) и, в некоторых случаях, сбросить кэши,.
#### **Какие регистры процессора важны для ОС (PC, SP, PSW) и как ОС использует/учитывает их? ⭐⭐**:

Для управления жизненным циклом процессов операционная система должна напрямую взаимодействовать с ключевыми регистрами процессора,.

1. **Program Counter (PC) / Счётчик команд:**
    - **Суть:** Содержит адрес следующей инструкции, которую должен извлечь и исполнить процессор.
    - **Использование ОС:** При приостановке процесса ОС сохраняет текущее значение PC в записи таблицы процессов (Process Control Block), чтобы при следующем запуске знать, с какого места продолжать выполнение,.
2. **Stack Pointer (SP) / Указатель стека:**
    - **Суть:** Указывает на вершину текущего стека в памяти, где хранятся локальные переменные, параметры функций и адреса возврата.
    - **Использование ОС:** Каждому процессу (и потоку) выделяется свой стек. При переключении задач ОС переключает SP на стек нового процесса, обеспечивая изоляцию контекстов вызовов.
3. **Program Status Word (PSW) / Слово состояния программы:**
    - **Суть:** Регистр, содержащий важные флаги состояния системы: коды условий (результаты сравнений), приоритет процессора и, самое главное, текущий режим работы (пользовательский или режим ядра).
    - **Использование ОС:** ОС считывает PSW для анализа исключений и записывает в него данные для переключения режима работы процессора. Поле режима в PSW определяет, разрешено ли программе выполнять привилегированные инструкции.
#### **Чем архитектура процессора отличается от микроархитектуры? Почему ОС в основном «видит» архитектуру? ⭐⭐**:

Разделение между этими понятиями позволяет разработчикам процессоров улучшать производительность, не нарушая работу существующего программного обеспечения.

- **Архитектура (Instruction Set Architecture, ISA):** Это спецификация того, что процессор может делать. Она включает набор инструкций (например, x86, ARM, RISC-V), видимые регистры (PC, PSW) и организацию памяти. Архитектура — это «контракт» между «железом» и программистом.
- **Микроархитектура:** Это конкретная реализация архитектуры внутри чипа. Сюда относятся конвейеры, кэши L1/L2, буферы предсказания переходов и блоки внеочередного выполнения,.

**Почему ОС видит архитектуру:** Для ОС критически важны те элементы, которыми она должна управлять напрямую: регистры для сохранения контекста и инструкции для ввода-вывода или защиты памяти. Микроархитектурные детали (например, размер строки кэша или глубина конвейера) обычно скрыты и работают автоматически на аппаратном уровне. Если бы ОС зависела от микроархитектуры, её пришлось бы переписывать под каждую новую модель процессора даже внутри одного семейства.
#### **Объясните, что такое конвейер (pipeline) и как он повышает производительность. Какие сложности он создаёт? ⭐⭐⭐**:

**Конвейер** — это метод аппаратной организации процессора, при котором выполнение инструкции разбивается на несколько стадий, и разные инструкции обрабатываются на разных стадиях одновременно,.

**Принцип работы (на примере 3-х стадий):**

1. **Fetch (Выборка):** Извлечение инструкции из памяти.
2. **Decode (Декодирование):** Определение типа команды и операндов.
3. **Execute (Исполнение):** Выполнение самой операции.

**Повышение производительности:** Если выполнение одной инструкции занимает 3 такта, то без конвейера 3 инструкции выполнятся за 9 тактов. С конвейером, когда первая инструкция переходит к стадии декодирования, вторая уже начинает выбираться из памяти. В идеале за один такт завершается выполнение одной инструкции.

**Иллюстрация конвейера:**

```
Такт:     1      2      3      4      5
Команда 1: [Выб]  [Дек]  [Исп]
Команда 2:        [Выб]  [Дек]  [Исп]
Команда 3:               [Выб]  [Дек]  [Исп]
```

**Сложности:**

- **Зависимости по управлению:** Если в конвейере оказывается условный переход, процессор может начать выбирать инструкции по неверному пути, что потребует «очистки» конвейера (flush) при ошибке предсказания.
- **Сложность для ОС:** При возникновении прерывания или ошибки страницы конвейер может находиться в «грязном» состоянии, когда часть инструкций уже частично исполнена. ОС должна корректно восстановить состояние до начала инструкции, вызвавшей сбой,.
#### **Что такое суперскалярный процессор и «внеочередное выполнение»? Почему это может быть важно для ОС? ⭐⭐⭐**:

**Суперскалярный процессор** — это более продвинутая версия конвейерного дизайна, имеющая несколько независимых исполнительных блоков (например, для целых чисел, для чисел с плавающей точкой и т.д.).

**Основные концепции:**

- **Параллельная выборка:** Процессор извлекает из памяти сразу несколько инструкций за один раз.
- **Внеочередное выполнение (Out-of-order execution):** Инструкции помещаются в буфер ожидания. Как только соответствующий исполнительный блок освобождается, он берет из буфера любую готовую инструкцию, даже если она идет в программе позже других.

**Важность для ОС:**

1. **Сложность обработки прерываний:** Когда происходит аппаратный сбой или прерывание, ОС трудно определить точное состояние системы, так как инструкции вокруг точки сбоя могли быть завершены в произвольном порядке.
2. **Синхронизация:** ОС должна учитывать, что порядок операций с памятью может отличаться от написанного в коде, что критично при разработке драйверов и примитивов синхронизации.
3. **Безопасность:** Сложность внеочередного выполнения стала источником современных уязвимостей (типа Spectre и Meltdown), что вынудило разработчиков ОС вводить дополнительные механизмы защиты (например, изоляцию таблиц страниц ядра).
#### **Сравните kernel mode и user mode: какие инструкции/возможности доступны в каждом режиме и почему? ⭐⭐**:

Для обеспечения стабильности системы большинство процессоров поддерживают как минимум два режима работы, переключаемых битом в регистре PSW,.

|Характеристика|Пользовательский режим (User Mode)|Режим ядра (Kernel Mode)|
|:--|:--|:--|
|**Доступ к аппаратуре**|Ограничен; только через запросы к ОС.|Полный и неограниченный доступ ко всему оборудованию,.|
|**Набор инструкций**|Только подмножество; запрещены команды управления системой,.|Доступен весь набор инструкций процессора,.|
|**Управление памятью**|Программа видит только своё адресное пространство.|Может изменять таблицы страниц и обращаться к любой области ОЗУ,.|
|**Риск ошибки**|Сбой затрагивает только само приложение.|Ошибка может привести к краху всей системы (BSoD/Panic),.|

**Почему это нужно:** Если бы пользовательская программа могла напрямую выполнять инструкции ввода-вывода или отключать прерывания, она могла бы захватить компьютер, стереть данные других пользователей или случайно вывести из строя оборудование,. Разделение режимов создает защитный барьер, гарантируя, что только доверенный код (ядро ОС) управляет критическими ресурсами.
#### **Что такое системный вызов (syscall) и чем он отличается от обычного вызова функции? Опишите общий механизм «trap в ядро». ⭐⭐⭐**:

**Системный вызов (syscall)** — это интерфейс между прикладной программой и операционной системой, позволяющий программе запрашивать сервисы, требующие привилегий режима ядра (например, чтение файла или создание процесса),.

**Отличия от вызова функции:**

1. **Смена режима:** Обычный вызов происходит внутри пользовательского режима. Системный вызов переключает процессор из User Mode в Kernel Mode.
2. **Точка входа:** При обычном вызове программа может прыгнуть по любому адресу. Системный вызов выполняется через специальную инструкцию-ловушку (trap), которая передает управление на строго фиксированный адрес в ядре,.
3. **Безопасность:** Ядро само проверяет параметры вызова перед исполнением, не доверяя пользовательскому процессу.

**Механизм «trap в ядро» (на примере `read`):**

1. **Подготовка:** Пользовательская программа кладет параметры (дескриптор, адрес буфера) в регистры процессора,.
2. **Trap:** Выполняется инструкция ловушки (например, `SYSCALL` или `INT`). Процессор сохраняет PC и PSW в стек и переключается в режим ядра,.
3. **Диспетчеризация:** Ядро считывает номер вызова из регистра, находит в таблице системных вызовов адрес нужного обработчика и запускает его,.
4. **Выполнение:** Код ОС в режиме ядра выполняет работу (например, дает команду контроллеру диска).
5. **Возврат:** Выполняется инструкция возврата из прерывания, которая восстанавливает PSW и PC, возвращая процессор в пользовательский режим и программу к следующей инструкции,.
#### **Какие бывают аппаратные traps (кроме syscall)? Как ОС может реагировать на исключительные ситуации? ⭐⭐**:

Помимо системных вызовов, процессор генерирует **ловушки (traps)** или исключения автоматически при возникновении определенных событий в ходе выполнения программы,.

**Виды аппаратных ловушек:**

1. **Ошибки арифметики:** Деление на ноль, переполнение или антипереполнение чисел с плавающей точкой,.
2. **Нарушения защиты:** Попытка выполнить привилегированную инструкцию в пользовательском режиме или обращение к запрещенному адресу памяти (Segmentation Fault),.
3. **Ошибка страницы (Page Fault):** Обращение к виртуальному адресу, данные которого в данный момент отсутствуют в оперативной памяти (выгружены на диск),.
4. **Отладочные ловушки:** Точки останова (breakpoints), используемые отладчиками для остановки программы.

**Реакция ОС:** Когда происходит ловушка, управление передается ядру, которое принимает решение:

- **Завершение программы:** Если произошла критическая ошибка (например, несанкционированный доступ к памяти), ОС убивает процесс с ошибкой,.
- **Игнорирование/Коррекция:** При арифметическом антипереполнении ОС может просто установить результат в 0 и позволить программе работать дальше.
- **Прозрачная обработка:** При Page Fault ОС приостанавливает процесс, подгружает страницу с диска и возобновляет выполнение так, что программа даже не замечает паузы,.
- **Сигнализация:** ОС может отправить процессу сигнал (например, `SIGFPE` при делении на ноль), позволяя программе самой обработать ошибку, если в ней прописан соответствующий обработчик.