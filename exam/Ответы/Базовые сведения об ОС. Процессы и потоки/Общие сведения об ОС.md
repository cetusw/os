#### **Дайте определение операционной системы и объясните, какие задачи она решает в современном компьютере. ⭐**:

**Операционная система (ОС)** — это слой программного обеспечения, который располагается между аппаратным обеспечением (hardware) и прикладными программами, предоставляя пользователям и разработчикам удобную модель компьютера и управляя всеми его ресурсами,. С технической точки зрения ОС — это программа, которая работает в **привилегированном режиме ядра** (kernel mode), имея неограниченный доступ ко всей аппаратуре системы,.

**Задачи, которые решает современная ОС:**

- **Создание абстракций (модель «расширенной машины»):** ОС скрывает от программиста невероятно сложные и неудобные интерфейсы оборудования (например, регистры контроллеров дисков), заменяя их простыми и понятными абстракциями, такими как **файлы**,,.
- **Управление ресурсами:** ОС выступает в роли менеджера, который упорядоченно распределяет процессоры, память, таймеры, диски, сетевые интерфейсы и устройства ввода-вывода между конкурирующими за них программами,.
- **Обеспечение защиты и безопасности:** ОС изолирует процессы друг от друга, чтобы ошибка в одной программе не могла привести к краху всей системы или повреждению данных другого пользователя,.
- **Предоставление пользовательского интерфейса:** Хотя оболочка (shell) или графический интерфейс (GUI) формально не являются частью ОС, система обеспечивает их работу, позволяя пользователю запускать приложения и управлять ими,.

**Уровневая модель системы:**

```
+---------------------------+
|   Прикладные программы    | (Пользовательский режим)
+---------------------------+
|    Оболочка / GUI         | (Пользовательский режим)
+---------------------------+
|   Операционная система    | (Режим ядра)
+---------------------------+
|    Микроархитектура       | (Аппаратура)
+---------------------------+
|    Физические устройства  | (Аппаратура)
+---------------------------+
```
#### **Почему прикладные программы обычно не работают напрямую с «железом»? Какие проблемы возникли бы без ОС? ⭐⭐**:

Прикладные программы не работают с оборудованием напрямую из-за **чрезмерной сложности аппаратных интерфейсов**,. Например, описание интерфейса работы с диском SATA занимает сотни страниц, и реализация этой логики в каждом приложении была бы крайне неэффективной и трудозатратной.

**Проблемы, которые возникли бы без использования ОС:**

- **Хаос в распределении ресурсов:** Если бы несколько программ попытались одновременно выводить данные на один принтер, результат превратился бы в «абсолютный беспорядок» из перемешанных строк,.
- **Отсутствие защиты памяти:** Без контроля со стороны ОС любая программа могла бы случайно или намеренно стереть код операционной системы или данные других программ, что приводило бы к постоянным сбоям,,.
- **Несовместимость:** Программистам пришлось бы писать уникальный код для каждой конкретной модели видеокарты, диска или клавиатуры, что сделало бы разработку софта практически невозможной,,.
- **Сложность разработки:** Вместо использования простой команды «записать в файл», разработчик был бы вынужден вручную управлять перемещением головок диска, ожиданием оборота шпинделя и проверкой секторов на наличие ошибок,.
#### **Объясните, как ОС управляет ресурсами при многопользовательской работе. Какие типы конфликтов она предотвращает? ⭐⭐**:

При многопользовательской работе ОС берет на себя роль **арбитра**, обеспечивая упорядоченное и защищенное использование ресурсов системы,. Она отслеживает, какой процесс использует конкретный ресурс, обрабатывает запросы на выделение новых ресурсов и ведет учет их потребления.

**Типы предотвращаемых конфликтов:**

- **Конфликты доступа к памяти:** С помощью аппаратных средств защиты (таких как регистры границ или таблицы страниц) ОС гарантирует, что один пользователь не сможет прочитать или изменить память, выделенную другому пользователю,,.
- **Конфликты ввода-вывода:** ОС предотвращает одновременный захват физического устройства (например, принтера) несколькими процессами, используя буферизацию данных (spooling),,.
- **Файловые конфликты:** ОС управляет правами доступа к файлам, определяя, кто может читать, записывать или удалять конкретные данные, предотвращая несанкционированный доступ,,.
- **Конфликты процессорного времени:** С помощью алгоритмов планирования ОС предотвращает монополизацию процессора одной «жадной» программой, принудительно переключая контекст.
#### **Что такое мультиплексирование во времени и в пространстве? Приведите по 2 примера каждого. ⭐⭐**:

Мультиплексирование — это метод, позволяющий нескольким программам или пользователям совместно использовать один физический ресурс.

**Мультиплексирование во времени (Time Multiplexing):** Ресурс предоставляется разным пользователям по очереди — один за другим,.

1. **Процессор (CPU):** ОС выделяет каждому процессу определенный квант времени для выполнения, после чего передает процессор следующей задаче,.
2. **Принтер:** Когда несколько документов отправлены на печать, они выстраиваются в очередь и распечатываются последовательно,.

**Мультиплексирование в пространстве (Space Multiplexing):** Ресурс делится на части, и каждый пользователь одновременно получает в распоряжение свою долю.

1. **Оперативная память (RAM):** ОС разделяет общий объем памяти на сегменты или страницы, позволяя нескольким программам находиться в памяти одновременно.
2. **Жесткий диск / SSD:** Пространство накопителя делится на блоки, в которых одновременно могут храниться файлы разных пользователей.
#### **В каких типах устройств ОС может быть не нужна? Приведите примеры и объясните почему. ⭐⭐**:

Операционная система может быть не нужна во **встраиваемых устройствах с фиксированным набором функций**, где программа работает напрямую с оборудованием,.

**Примеры:**

- **Микроволновые печи**,.
- **Простые стиральные машины**,.
- **Электронные термометры**.
- **Банковские смарт-карты**,.

**Почему ОС там не нужна:** В таких системах отсутствует необходимость в запуске сторонних приложений пользователем, а вся логика работы жестко прошита в ПЗУ (ROM),. Задачи этих устройств крайне специфичны и просты, поэтому требования к многозадачности, сложным файловым системам или защите между пользователями отсутствуют,. Использование полноценной ОС в подобных случаях привело бы лишь к неоправданному расходу памяти и вычислительной мощности.
#### **Чем RTOS отличается от «полноценной» ОС общего назначения? В каких областях RTOS критична? ⭐⭐**:

**RTOS (Real-Time Operating System)** — это специализированная система, в которой время выполнения операции является ключевым параметром корректности работы всей системы,.

**Основные отличия:**

- **Детерминизм:** В RTOS важна не средняя скорость выполнения задач (как в Windows или Linux), а гарантия того, что задача будет выполнена в строго заданный срок (deadline),.
- **Предсказуемость:** Алгоритмы планирования в RTOS спроектированы так, чтобы исключить непредсказуемые задержки,.
- **Архитектура:** Часто RTOS представляют собой компактные библиотеки, связанные с приложением, и могут не иметь сложной защиты памяти между компонентами для достижения максимальной скорости реакции.

**Критические области применения:**

- **Авиация и авионика:** Управление закрылками или двигателями самолета,.
- **Медицина:** Роботы-хирурги или аппараты жизнеобеспечения,.
- **Промышленная робототехника:** Сварочные роботы на автомобильных конвейерах,.
- **Военные системы:** Управление наведением ракет.

В «жестких» системах реального времени (Hard Real Time) опоздание выполнения операции даже на миллисекунду эквивалентно катастрофическому отказу системы,.
#### **Опишите базовую архитектуру ПК (CPU–память–I/O) и роль системной шины в этой модели. ⭐**:

Концептуально архитектура персонального компьютера строится вокруг трех основных компонентов, связанных коммуникационным каналом,:

1. **Центральный процессор (CPU):** Является «мозгом» системы; он извлекает инструкции из памяти, декодирует их и исполняет в бесконечном цикле,.
2. **Память (ОЗУ/RAM):** Хранит программы, которые выполняются в данный момент, и данные, необходимые для их работы,.
3. **Устройства ввода-вывода (I/O):** Включают в себя контроллеры и физические устройства (диски, мониторы, клавиатуры), обеспечивающие взаимодействие компьютера с внешним миром,.

**Системная шина** выполняет роль «главной дороги» или общей магистрали, соединяющей все компоненты,. По ней передаются три типа информации: **данные**, **адреса** (куда эти данные передать) и **управляющие сигналы** (что именно сделать — прочитать или записать). В современных системах архитектура усложнена: используется несколько специализированных шин (PCIe, USB, SATA), соединенных через специальные мосты (Platform Controller Hub), чтобы обеспечить разную скорость передачи для разных устройств,.
#### **Что означает, что ОС «создаёт абстракции»? Приведите пример перехода от «блоков диска» к «файлам». ⭐⭐**:

Создание абстракций — это процесс превращения сложного, неудобного и специфичного аппаратного интерфейса в упрощенную, чистую и единообразную программную модель,,. ОС скрывает «ужасные» детали реализации оборудования от программиста,.

**Пример перехода от блоков диска к файлам:**

- **На уровне «железа»:** Диск состоит из вращающихся магнитных пластин, разделенных на дорожки, секторы и цилиндры,. Чтобы прочитать данные, программисту пришлось бы командовать контроллеру переместить рычаг с головкой на нужный цилиндр, ждать, пока нужный сектор пролетит под головкой, и обрабатывать ошибки контроллера,,.
- **На уровне абстракции ОС:** ОС предоставляет концепцию **файла** — именованной последовательности байтов,. Программисту достаточно вызвать функцию `read("filename")`, не задумываясь о том, на какой физической дорожке диска или в какой ячейке флэш-памяти находятся данные,. ОС сама транслирует имя файла в адреса конкретных блоков на физическом носителе,.

#### **Что такое драйвер устройства и почему драйверы часто выполняются в режиме ядра? ⭐⭐**:

**Драйвер устройства** — это специализированный программный модуль, который содержит детальные знания о контроллере конкретного оборудования и обеспечивает интерфейс между этим оборудованием и операционной системой,. Производитель каждого устройства поставляет драйверы для различных ОС (например, для Windows или Linux).

**Причины выполнения в режиме ядра (Kernel Mode):**

- **Доступ к оборудованию:** Только в режиме ядра процессор может выполнять команды ввода-вывода и обращаться к регистрам контроллеров устройств,,.
- **Производительность:** Прямой доступ к аппаратным ресурсам из режима ядра исключает накладные расходы на постоянные переключения между режимами при каждой операции с устройством.
- **Безопасность и стабильность:** Если бы драйверы работали в пользовательском режиме, они не смогли бы управлять прерываниями и портами ввода-вывода без специальной поддержки. Однако обратной стороной является то, что ошибка в драйвере, работающем в режиме ядра, может привести к немедленному краху всей операционной системы,.
#### **Назовите и сравните три способа установки драйверов (пересборка ядра, загрузка при старте, hotplug). ⭐⭐**:

Существует три основных метода добавления драйверов в систему,:

|Способ|Суть метода|Сравнение|
|:--|:--|:--|
|**Пересборка ядра**|Драйвер статически линкуется с кодом ядра в единый исполняемый файл,.|Самый старый метод (характерен для ранних UNIX). Требует компиляции и обязательной перезагрузки,.|
|**Загрузка при старте**|ОС находит нужные драйверы в файловой системе (например, `.dll` или `.so`) и динамически загружает их в память во время загрузки системы,.|Позволяет не менять код ядра. Упрощает установку, но всё же требует перезагрузки для активации нового устройства,.|
|**Динамическая (Hotplug)**|ОС способна принимать, устанавливать и запускать драйверы прямо во время работы системы,.|Самый современный и гибкий метод. Необходим для USB и Thunderbolt устройств, которые подключаются «на лету»,.|
#### **Что такое прерывание (interrupt) и зачем оно нужно при вводе-выводе? Опишите путь от устройства до обработчика. ⭐⭐⭐**:

**Прерывание** — это аппаратный механизм, позволяющий внешнему устройству подать сигнал процессору о том, что произошло важное событие (например, завершилось чтение данных с диска или нажата клавиша),. Это избавляет процессор от необходимости тратить время на постоянный опрос устройства (polling),.

**Путь сигнала от устройства до обработчика:**

1. **Устройство** завершает операцию и подает сигнал на свой **контроллер**.
2. Контроллер устройства выставляет сигнал на шине для **контроллера прерываний**.
3. Если прерывания разрешены, контроллер прерываний активирует специальный вывод (pin) на чипе **CPU**.
4. **CPU** заканчивает текущую инструкцию, сохраняет программный счетчик (PC) и слово состояния (PSW) в стек, чтобы иметь возможность вернуться назад,.
5. CPU переходит в режим ядра и использует номер устройства как индекс в **таблице векторов прерываний**, чтобы найти адрес нужного **обработчика**,.
6. Запускается код **обработчика прерывания** (часть драйвера), который считывает данные из контроллера и переводит процесс в состояние готовности,.
#### **Сравните методы I/O: busy waiting, interrupts, DMA — плюсы/минусы и типичные сценарии использования. ⭐⭐⭐**:

|Метод|Описание|Плюсы|Минусы|Сценарий|
|:--|:--|:--|:--|:--|
|**Busy waiting (Опрос)**|Процессор в цикле проверяет бит готовности устройства,.|Простейшая реализация, не требует сложной логики прерываний.|Процессор полностью занят бесполезным ожиданием,.|Очень простые системы или сверхбыстрые устройства.|
|**Interrupts (Прерывания)**|Устройство само сообщает CPU о завершении работы,.|CPU свободен для других задач во время работы устройства,.|Для передачи каждого байта данных требуется вмешательство CPU (прерывание),.|Медленные и средние устройства (клавиатура, модем).|
|**DMA (Прямой доступ)**|Отдельный чип управляет передачей данных между памятью и устройством,.|Максимальная разгрузка CPU; данные передаются блоками без участия процессора,.|Требуется дополнительное оборудование (контроллер DMA),.|Быстрые устройства с большими объемами данных (диски, сеть),.|

#### **Опишите процесс загрузки компьютера: что делает BIOS/UEFI, как выбирается загрузчик и что происходит при запуска ядра ОС. ⭐⭐⭐**:

Загрузка компьютера (booting) — это многоэтапный процесс инициализации оборудования и запуска программного обеспечения,:

1. **Старт и BIOS/UEFI:** Сразу после включения CPU начинает выполнять код прошивки из флэш-памяти по фиксированному адресу (reset vector),. Прошивка проводит самотестирование (POST), инициализирует RAM, шины (PCIe) и обнаруживает подключенные устройства,.
2. **Выбор устройства:** BIOS/UEFI обращается к списку приоритетов загрузки в памяти CMOS, пытаясь найти загрузочное устройство (диск, USB).
3. **Запуск первичного загрузчика:**
    - **В BIOS:** Считывается первый сектор диска (**MBR**), код которого ищет активный раздел и запускает оттуда вторичный загрузчик,.
    - **В UEFI:** Прошивка находит на диске специальный раздел **ESP** (FAT32), считывает оттуда файл загрузчика в формате **PE** и запускает его,.
4. **Загрузка ядра:** Загрузчик считывает образ ядра ОС с диска в оперативную память и передает ему управление,.    
5. **Инициализация ОС:** Ядро инициализирует свои внутренние таблицы (процессов, памяти), загружает необходимые драйверы устройств, запускает системные службы (демоны) и, наконец, запускает программу входа в систему или графическую оболочку,.
#### **Сравните BIOS и UEFI (MBR vs GPT/ESP, ограничения, возможности). Почему UEFI считают «маленькой ОС»? ⭐⭐⭐**:

**BIOS (Basic Input/Output System)** представляет собой традиционный стандарт прошивки, долгое время бывший основным интерфейсом между оборудованием и программным обеспечением при запуске ПК,. 
**UEFI (Unified Extensible Firmware Interface)** — это современный наследник BIOS, устраняющий его архитектурные ограничения и предлагающий расширенные возможности управления системой,.

##### Сравнение BIOS и UEFI

|Характеристика|BIOS (традиционный)|UEFI (современный)|
|:--|:--|:--|
|**Схема разделов диска**|Использует **MBR (Master Boot Record)**,.|Использует **GPT (GUID Partition Table)**,.|
|**Ограничение объема диска**|Не более **2 ТБ**,.|До **8 ZiB** (8 секстиллионов байт),.|
|**Место хранения загрузчика**|Первый сектор диска (512 байт кода),.|Специальный раздел **ESP (EFI System Partition)** в формате FAT32,.|
|**Скорость загрузки**|Медленная, архитектурно зависимая,.|**Быстрая загрузка**, независимость от архитектуры процессора,.|
|**Надежность данных**|Низкая (одна копия MBR в начале диска).|**Высокая** (GPT дублируется в начале и в конце диска),.|
|**Интерфейс и управление**|Текстовый, управление только клавиатурой.|Графический, поддержка мыши, сети и нескольких ОС,.|
##### Почему UEFI называют «маленькой ОС»

В отличие от BIOS, возможности которого крайне ограничены, **UEFI обладает функциональностью, типичной для полноценных операционных систем**,.

**Ключевые признаки «маленькой ОС» в UEFI:**

- **Собственная командная оболочка (Shell):** UEFI предоставляет интерфейс со стандартным набором команд для диагностики и настройки системы без загрузки основной ОС.
- **Поддержка файловых систем:** Прошивка UEFI самостоятельно умеет читать данные с дисков, поддерживая как минимум форматы **FAT-12, FAT-16 и FAT-32**.
- **Исполнение сложных программ:** UEFI способна запускать приложения и драйверы в стандартном исполняемом формате **PE (Portable Executable)**,.
- **Менеджер загрузки:** Встроенный **Boot Manager** позволяет пользователю выбирать нужную ОС из меню и настраивать приоритеты загрузки прямо в интерфейсе прошивки,.
- **Сетевой стек и графика:** Современные реализации UEFI поддерживают работу с сетевыми интерфейсами и вывод качественной графики с поддержкой манипуляторов (мыши),.
- **Безопасность:** Наличие таких механизмов, как **Secure Boot**, позволяет UEFI контролировать подлинность загружаемого программного кода, защищая систему от вредоносного ПО на этапе старта.