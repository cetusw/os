#### **Что делает TSL (test-and-set) и почему эта операция считается атомарной? ⭐⭐**:

Инструкция **TSL (Test and Set Lock)** выполняет два действия за один такт: она **считывает значение** переменной-замка (lock) в регистр и одновременно **устанавливает её значение в 1**.

Эта операция считается **атомарной**, так как на аппаратном уровне она гарантирует неделимость цикла «чтение-модификация-запись». В момент выполнения TSL процессор активирует механизм **«bus lock»**, блокируя доступ к шине памяти для всех остальных ядер до завершения инструкции, что предотвращает любое вмешательство извне.

---

#### **Сравните TSL и XCHG как примитивы: в чём концептуальная одинаковость и какие есть архитектурные нюансы. ⭐⭐**:

Концептуально **TSL и XCHG идентичны**: обе инструкции обеспечивают аппаратную поддержку взаимного исключения через атомарный доступ к памяти.

- **TSL R, LOCK**: Читает старое значение и принудительно записывает «1».
- **XCHG R, LOCK**: Атомарно **обменивает** содержимое регистра (в который программа заранее записала «1») с содержимым ячейки памяти.

Архитектурный нюанс заключается в том, что в некоторых системах XCHG может быть более универсальной инструкцией, тогда как TSL была специфическим примитивом для синхронизации в ранних архитектурах. Оба метода используют блокировку шины или протоколы когерентности кэша для обеспечения глобальной атомарности.

---

#### **Почему спинлоки эффективны только для «очень коротких» критических секций? Опишите критерии «короткости». ⭐⭐**:

Спинлоки основаны на **активном ожидании (busy waiting)**, при котором поток непрерывно занимает CPU, проверяя условие в цикле.

**Критерии «короткости»:**

1. **Время ожидания меньше времени переключения контекста:** Если поток заблокируется «по-настоящему» (уйдет в сон), система потратит значительное время на сохранение регистров и вызов планировщика. Спинлок выгоден, если ресурс освободится быстрее, чем произойдет этот переход.
2. **Операции в ядре:** Типичный пример — обновление списка готовых процессов или обработка прерывания, занимающая считанные инструкции.

---

#### **Что такое starvation в контексте спинлоков и почему отсутствие fairness — нормальная цена за простоту? ⭐⭐**:

**Starvation (голодание)** — это ситуация, когда один или несколько потоков не могут войти в критическую секцию в течение неопределенного времени, потому что другие потоки постоянно «выигрывают» гонку за замок в момент его освобождения.

Отсутствие **fairness (справедливости/очереди)** — это компромисс. Реализация строгой очереди требует дополнительных структур данных и усложнения логики, что увеличивает накладные расходы. Для примитивного спинлока важнее **минимальная задержка** при захвате, чем гарантия порядка.

---

#### **Какие техники применяют, чтобы уменьшить вред спина под конкуренцией (pause/yield/backoff)? Почему это помогает? ⭐⭐⭐**:

Для снижения нагрузки на CPU и энергопотребления применяют:

- **Pause**: Специальная инструкция (в x86), которая говорит процессору, что идет спин-цикл, оптимизируя работу конвейера.
- **Yield()**: Поток добровольно отдает свой квант времени другим задачам, если не смог захватить замок с первой попытки.
- **Backoff**: Процесс делает небольшую паузу (задержку) перед следующей попыткой захвата.

Эти техники помогают, так как **разгружают системную шину** и позволяют другим потокам (включая владельца замка) быстрее получить CPU и завершить работу.

---

#### **Объясните, как atomic_flag::test_and_set реализует идею TSL. Что возвращает и почему это удобно для лока? ⭐⭐**:

Метод `std::atomic_flag::test_and_set` атомарно устанавливает флаг в состояние «true» и возвращает его **предыдущее значение**.

Это удобно для реализации блокировки: если метод вернул `false`, значит, замок **был свободен**, и мы его успешно захватили. Если вернул `true`, замок **уже был занят** кем-то другим, и мы должны продолжать цикл ожидания (spin).

---

#### **Почему в примере используются memory_order_acquire на lock и memory_order_release на unlock? Что будет, если поставить relaxed? ⭐⭐⭐**:

Эти барьеры памяти гарантируют корректный порядок операций в многоядерных системах.

- **memory_order_acquire (на lock)**: Гарантирует, что никакие инструкции чтения/записи в критической секции не будут выполнены процессором **раньше**, чем замок будет фактически захвачен.
- **memory_order_release (на unlock)**: Гарантирует, что все изменения данных, сделанные внутри секции, станут видны другим ядрам **до** того, как замок будет официально освобожден.

Если использовать **relaxed**, процессор или компилятор могут переупорядочить инструкции так, что данные будут обрабатываться **вне** защищенного периода, что приведет к гонке данных и непредсказуемым ошибкам.

---

#### **Какие практические проблемы у такого спинлока: рекурсивность, fairness, влияние на энергопотребление, масштабирование на много ядер? ⭐⭐**:

1. **Не рекурсивный**: Повторный вызов `lock()` из того же потока приведет к **вечному дедлоку**, так как поток будет ждать самого себя.
2. **Отсутствие fairness**: Риск «голодания» потоков.
3. **Энергопотребление**: Постоянная работа ядра в цикле на 100% мощности тратит заряд батареи и греет процессор.
4. **Плохое масштабирование**: При большом количестве ядер (SMP) постоянные попытки записи в одну ячейку памяти вызывают «конфликты кэш-линий» и сильно замедляют всю систему.

---

#### **Почему внутри std::atomic_flag реализация может быть сложнее, чем кажется? Как это влияет на производительность? ⭐⭐⭐**:

Хотя логически это один бит, внутри `std::atomic_flag` может содержать **выравнивание (alignment)** и **дополнительные отступы (padding)**.

Это делается для защиты от **false sharing** — ситуации, когда разные атомарные переменные попадают в одну кэш-линию процессора. Если два ядра будут постоянно обновлять разные флаги в одной линии, они будут инвалидировать кэш друг друга, что катастрофически снизит производительность всей многоядерной системы.

---

#### **Как бы вы добавили в TSLLock try_lock() и «вежливое ожидание»? Какие компромиссы появятся? ⭐⭐**:

- **try_lock()**: Это был бы вызов `test_and_set` без цикла `while`. Метод просто возвращает результат попытки: `true` — успех, `false` — замок занят.
- **«Вежливое ожидание»**: Добавление в цикл спина вызова `std::this_thread::yield()` или паузы через `backoff`.

**Компромиссы:** «Вежливость» (yield/backoff) снижает нагрузку на CPU, но **увеличивает латентность** (время отклика) — поток может пропустить момент освобождения замка и запуститься только через системный квант времени.