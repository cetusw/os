#### **Зачем ОС связывает процесс с UID/GID, и как это влияет на доступ к файлам и процессам других пользователей? ⭐⭐**:

Операционная система связывает каждый процесс с **идентификатором пользователя (UID)** и **идентификатором группы (GID)** для реализации механизмов защиты и разграничения доступа к ресурсам,. Каждому человеку, имеющему право пользоваться системой, администратор назначает уникальный UID, а процессы, запускаемые этим пользователем, автоматически наследуют его идентификатор,.

**Влияние на доступ:**

- **Доступ к файлам:** При попытке открыть файл ОС проверяет UID и GID процесса на соответствие правам доступа (rwx), установленным для этого файла,. Если UID процесса не совпадает с UID владельца файла и процесс не входит в соответствующую группу, доступ будет запрещен.
- **Доступ к процессам:** Идентификаторы позволяют изолировать процессы разных пользователей. Например, обычный пользователь не может отправить сигнал (команда `kill`) процессу, принадлежащему другому пользователю или системе.

**Схема связки в ядре:**

```
[ Пользователь ] --- (логин/пароль) ---> [ Сессия ]
                                            |
                                    [ Процесс (PID) ]
                                    |  - UID: 1000  |
                                    |  - GID: 1000  |
                                            |
      Проверка прав:  [ Процесс ] <---( Сравнение )---> [ Файл на диске ]
                                                         - Owner UID: 1000
                                                         - Rights: rwx------
```

---

#### **Чем отличается «пользователь» от «группы» в практическом управлении доступом? Приведите пример политики доступа. ⭐⭐**:

**Пользователь** — это конкретная учетная запись (субъект), ассоциированная с уникальным UID,. **Группа** — это логическое объединение пользователей, имеющее свой GID, которое позволяет назначать права доступа сразу множеству людей,.

**Практическое различие:**

- Права для пользователя (owner) являются наиболее приоритетными и специфичными.
- Группы позволяют гибко управлять доступом к общим проектам, не настраивая права для каждого человека отдельно.

**Пример политики доступа:** Представим файл `project_plan.txt`, над которым работает отдел маркетинга.

- **Владелец (User: manager):** имеет права `rw-` (чтение и запись), так как он автор документа.
- **Группа (Group: marketing):** имеет права `r--` (только чтение), чтобы все сотрудники отдела могли ознакомиться с планом.
- **Остальные (Others):** имеют права `---` (нет доступа), чтобы сотрудники других отделов не видели документ. В символьном виде это выглядит как `rw-r-----`.

---

#### **Почему root (администратор) — одновременно полезная и опасная концепция? Какие риски она создаёт? ⭐⭐**:

**Root** (или суперпользователь) — это учетная запись с UID 0, которая обладает абсолютными полномочиями в системе,.

**Польза:**

- Root необходим для выполнения критических задач: установки драйверов, изменения таблиц страниц памяти, управления правами других пользователей и настройки оборудования,.
- Он может обойти любые правила защиты для восстановления системы после сбоев,.

**Риски и опасность:**

- **Отсутствие защиты от ошибок:** Если программа запущена от имени root и в ней есть баг, она может случайно стереть всю файловую систему или повредить ядро, так как проверки прав для root не действуют,.
- **Цель для атак:** Злоумышленники стремятся получить права root, так как это дает им полный контроль над данными всех пользователей и возможность скрыть следы своего присутствия.
- **Риск нарушения изоляции:** Любая ошибка в коде, работающем в режиме ядра (где часто действует логика root), может привести к краху всей ОС,.

---

#### **Какую информацию можно извлечь из `/etc/passwd`, и почему наличие записи там ещё не означает возможность интерактивного входа? ⭐⭐⭐**:

Файл `/etc/passwd` содержит список всех учетных записей системы в текстовом формате. Каждая строка файла разбита на поля, разделенные двоеточием.

**Извлекаемая информация (по полям):**

1. **Имя пользователя:** логин.
2. **Пароль:** обычно там стоит `x` (реальный хэш хранится в `/etc/shadow`).
3. **UID:** цифровой идентификатор пользователя.
4. **GID:** идентификатор основной группы.
5. **Комментарий:** обычно полное имя или описание.
6. **Домашний каталог:** путь к личной папке пользователя.
7. **Командная оболочка:** программа, запускаемая при входе (например, `/bin/bash`).

**Почему запись не гарантирует вход:** В поле «командная оболочка» может быть указана специальная программа, запрещающая интерактивный вход, например `/usr/sbin/nologin` или `/bin/false`. Такие учетные записи (например, `daemon` или `bin`) нужны только для запуска системных фоновых процессов (демонов) и не предназначены для живого общения с пользователем через терминал,.

---

#### **Опишите типичную модель «минимально необходимых прав» и как она реализуется на практике в UNIX через пользователей/группы/права. ⭐⭐⭐**:

Модель **«минимально необходимых прав»** (или **POLA** — Principle of Least Authority) гласит, что каждый компонент системы (или пользователь) должен иметь доступ только к тем ресурсам, которые жизненно необходимы для выполнения его текущей задачи, и не более того.

**Практическая реализация в UNIX:**

1. **Разделение привилегий:** Вместо запуска всего под root, создаются системные пользователи для конкретных служб (например, пользователь `www-data` для веб-сервера).
2. **Битовая маска прав (rwx):** Файлам назначаются строгие права. Если демону нужно только читать конфиг, ему дают `r--`, но не `rw-`.
3. **Иерархия групп:** Пользователей добавляют только в те группы, доступ к ресурсам которых им действительно нужен.
4. **Временное повышение прав:** Вместо постоянной работы с правами администратора, используются механизмы вроде `sudo` для выполнения одной конкретной команды с повышенными привилегиями.

---

#### **В чём принципиальная разница между `su` и `sudo` с точки зрения модели безопасности? ⭐⭐**:

|Характеристика|`su` (substitute user)|`sudo` (superuser do)|
|:--|:--|:--|
|**Суть**|Полное переключение в контекст другого пользователя.|Выполнение конкретной команды с правами другого пользователя.|
|**Пароль**|Требует пароль **целевого** пользователя (например, root).|Требует пароль **текущего** пользователя.|
|**Сессия**|Создает новую полноценную сессию оболочки.|Права повышаются временно только для одной операции.|
|**Аудит**|Трудно отследить, кто именно зашел под root, если пароль знают многие.|Каждое действие фиксируется в логах с указанием реального имени пользователя.|

---

#### **Почему `su` считается менее безопасным подходом в командах/организациях, и как это связано с паролями и аудитом? ⭐⭐**:

При использовании `su` возникает несколько критических проблем безопасности:

1. **Разглашение пароля:** Чтобы дать сотруднику права администратора через `su`, вы обязаны сообщить ему пароль учетной записи root. Это нарушает базовое правило: пароль должен знать только один человек.
2. **Отсутствие персональной ответственности:** Если три системных администратора знают пароль root и используют `su`, то в случае критического сбоя или саботажа логи системы покажут, что действия совершил «root», и будет невозможно установить, кто именно это был.
3. **Сложность отзыва прав:** Чтобы лишить одного человека прав администратора, придется менять пароль root и сообщать его всем остальным, что крайне неудобно.

`sudo` решает эти проблемы, позволяя пользователю использовать собственный пароль, который система проверяет по списку разрешений (sudoers), сохраняя при этом детальный журнал действий каждого сотрудника,.

---

#### **Что именно меняется при `su`: какие части «сессии» (окружение, текущий каталог, права) могут вести себя иначе? ⭐⭐⭐**:

Команда `su` инициирует глубокую смену контекста выполнения.

**Изменения в сессии:**

- **Права:** Процесс получает новые UID и GID. Теперь системные вызовы `open` или `write` будут проверяться относительно новой личности.
- **Переменные окружения (Environment):** Если используется `su -` (с дефисом), то загружается полное окружение целевого пользователя: пути поиска программ (`PATH`), настройки терминала, локаль,. Если просто `su`, часть переменных (например, `PATH`) может остаться от старого пользователя, что иногда ведет к конфликтам.
- **Текущий рабочий каталог:** При `su -` каталог меняется на домашний каталог целевого пользователя (например, в `/root`),.
- **Командная оболочка:** Запускается та оболочка, которая прописана для этого пользователя в `/etc/passwd`.

---

#### **Зачем `sudo` обычно просит пароль текущего пользователя, а не root? Как это помогает контролю и расследованиям? ⭐⭐**:

Запрос пароля текущего пользователя в `sudo` преследует две цели:

1. **Подтверждение личности (Аутентификация):** Система проверяет, что за компьютером сидит именно тот человек, которому разрешено использовать `sudo`, а не кто-то, кто подошел к открытому терминалу.
2. **Сохранение тайны пароля root:** Пароль администратора остается неизвестным обычному пользователю, что предотвращает несанкционированный вход в систему в обход механизмов контроля,.

**Для контроля и расследований:** Поскольку пользователь вводит _свой_ пароль, система точно знает, кто инициировал запрос. В системном журнале (аудите) записывается: «Пользователь _vivid_ выполнил команду _ps aux_ с правами root». Это позволяет в любой момент провести ретроспективный анализ действий и понять, какие изменения в систему вносил конкретный человек.

---

#### **Опишите сценарий, когда `sudo` может быть опасен при неверной настройке (например, чрезмерные права), и как это предотвратить. ⭐⭐⭐**:

**Опасный сценарий:** Администратор разрешил пользователю запускать через `sudo` текстовый редактор `vim` без пароля (для правки одного конфига). Однако `vim` имеет встроенную функцию запуска командной оболочки (`:!sh`). Пользователь запускает редактор через `sudo vim`, затем вызывает из него оболочку и получает **неограниченный доступ к командной строке root**, фактически обходя все ограничения `sudoers`.

**Как это предотвратить:**

1. **Принцип минимизации:** Не давать доступ к программам, которые позволяют выполнять произвольный код или переходить в оболочку.
2. **Ограничение аргументов:** В настройках `sudo` указывать не просто программу, а конкретный файл, который разрешено открывать (например, `sudo /usr/bin/vim /etc/nginx/nginx.conf`).
3. **Использование специализированных утилит:** Вместо редакторов использовать команды с ограниченным функционалом (например, `sudoedit` вместо `sudo vim`).
4. **Регулярный аудит:** Проверять файл настроек `sudoers` на наличие слишком широких разрешений (например, использования групповых масок `ALL=(ALL:ALL) ALL`).