#### **Дайте определения «механизм» и «политика» применительно к планированию. Почему их разделение считается фундаментальным принципом ОС? ⭐⭐**

- **Механизм** — это техническая реализация того, **как** выполняется планирование (например, процедуры переключения контекста, структуры очередей).
- **Политика** — это набор правил, определяющих, **что именно** считать приоритетным и как распределять ресурсы между задачами. Разделение этих понятий считается фундаментальным принципом, так как оно обеспечивает **гибкость и универсальность**: ядро может предоставлять эффективные инструменты (механизмы), в то время как конкретные приложения или пользователи задают свои правила игры (политику), адаптируя систему под свои нужды.

#### **На примере СУБД объясните, почему приложение может «лучше знать», как планировать свои дочерние задачи/потоки, чем ядро ОС. ⭐⭐**

Один процесс (например, СУБД) может иметь множество дочерних потоков с разными функциями. **Приложение обладает семантическим знанием** о важности своих задач: оно понимает, какой поток обрабатывает критический запрос клиента, а какой выполняет фоновую очистку логов. Планировщик ОС этой информации не имеет и может ошибочно выделить ресурсы менее важному потоку, что приведет к неоптимальной работе.

#### **Приведите примеры параметров/интерфейсов ОС, через которые пользовательский процесс может влиять на политику, не реализуя механизм (приоритеты, квоты и т. п.). ⭐⭐**

Пользовательские процессы могут влиять на политику через:

- **Числовые приоритеты**, назначаемые потокам, которые ядро учитывает при выборе следующей задачи для запуска.
- **Атрибуты планирования** в API (например, `pthread_attr_t` в POSIX), позволяющие задать политику внутри конкретного класса задач.
- **Квоты** и лимиты на использование процессорного времени, которые ограничивают «аппетиты» процесса в пользу других участников системы.

#### **Какие опасности возникают, если приложениям дать слишком много контроля над политикой? Как ОС может это ограничивать? ⭐⭐⭐**

- **Опасности:** «Жадные» приложения могут бесконтрольно повышать свой приоритет, вызывая **голодание (starvation)** других программ или даже парализуя работу всей ОС.
- **Ограничения:** ОС применяет механизмы защиты, требующие **специальных привилегий** (прав администратора) для повышения приоритетов выше определенного уровня. Также используются алгоритмы вроде **динамической деградации**, которые автоматически снижают приоритет процесса, если он слишком долго занимает CPU.

#### **Опишите ситуацию, где отсутствие разделения policy/mechanism приводит к заметной потере производительности или нарушению требований по времени. ⭐⭐⭐**

Если ядро ОС жестко фиксирует приоритеты без возможности влияния извне, может возникнуть ситуация, когда высокоприоритетный (с точки зрения ОС) вычислительный процесс блокирует критически важную, но редкую задачу интерактивного приложения. Это приведет к **зависанию интерфейса** или нарушению **дедлайнов** в системах реального времени, так как ядро не «понимает», что кратковременный отклик на действие пользователя в данный момент важнее долгих вычислений.

#### **Почему наличие двух уровней параллелизма (процессы и потоки) усложняет планирование по сравнению с «только процессами»? ⭐⭐**

Параллелизм на уровне процессов дополняется параллелизмом внутри них. Это усложняет задачу, так как системе приходится принимать **двухуровневое решение**: сначала выбрать процесс, которому будет выделен квант времени, а затем решить, какой именно поток внутри этого процесса должен выполняться. Поведение системы начинает зависеть от того, поддерживаются ли потоки ядром или только пользовательской библиотекой.

#### **Объясните, как происходит планирование при user-level threads: кто и что планирует, и почему отсутствует принудительное вытеснение потоков таймером? ⭐⭐**

- **Кто планирует:** Планировщик ядра видит только процесс целиком, а управлением потоками занимается **библиотека рантайма** внутри адресного пространства процесса.
- **Отсутствие вытеснения:** Поскольку ядро «не знает» о существовании этих потоков, оно не может посылать им прерывания таймера. Потоки работают **кооперативно**: один поток должен добровольно вызвать функцию `yield`, чтобы передать управление другому.

#### **В чём главный практический недостаток user-level threads при блокирующих операциях ввода-вывода? Как он проявляется для пользователя? ⭐⭐**

Если один пользовательский поток выполняет блокирующий системный вызов (например, чтение с диска), ядро **блокирует весь процесс целиком**, так как оно не видит других потоков, готовых к работе. Для пользователя это проявляется как **полное замирание приложения**, даже если в нем есть другие независимые задачи (например, анимация интерфейса), которые могли бы продолжаться.

#### **Объясните, как планирование отличается для kernel-level threads и почему становится возможна «перемежающаяся» последовательность потоков разных процессов. ⭐⭐**

Ядро планирует каждый поток **индивидуально**, имея полную таблицу всех потоков системы. Это позволяет планировщику гибко переключаться между ними: например, выполнить поток 1 процесса А, затем поток 2 процесса Б, затем поток 2 процесса А. При пользовательских потоках такое невозможно — ядро отдает квант одному процессу, и тот сам распределяет его между своими потоками до конца интервала.

#### **Почему переключение между kernel-level threads обычно дороже, чем между user-level threads? Какие компоненты ОС делают его дорогим? ⭐⭐⭐**

Переключение потоков ядра дороже, так как требует полноценного **системного вызова** и перехода процессора в **режим ядра (trap)**. Это влечет за собой сохранение регистров в таблице потоков ядра и возможные накладные расходы на работу планировщика ОС. Переключение в user space происходит на порядки (в 10–100 раз) быстрее, так как выполняется простыми библиотечными процедурами без вовлечения ядра.

#### **Почему ядру выгоднее (при прочих равных) продолжать выполнять поток в том же процессе, а не переключаться на поток другого процесса? Свяжите ответ с памятью и кэшами. ⭐⭐⭐**

Потоки одного процесса используют общее **адресное пространство**. При переключении на поток другого процесса ядру необходимо сменить таблицы страниц в MMU, что приводит к **сбросу TLB (кэша трансляции адресов)** и неэффективному использованию **L1/L2 кэшей**, которые оказываются «холодными» для новой задачи. Продолжение работы внутри одного процесса экономит сотни тактов, необходимых на повторную загрузку данных в быструю память.

#### **В чём идея гибридного подхода (сочетание user-level и kernel-level) и какие проблемы каждого уровня он пытается компенсировать? ⭐⭐⭐**

Идея заключается в мультиплексировании множества пользовательских потоков на пул из нескольких потоков ядра (модель M:N).

- Это компенсирует **медлительность** потоков ядра, позволяя быстро переключаться между легкими задачами в user space.
- Это решает проблему **блокировок** пользовательских потоков: если один поток заблокируется на I/O, ядро просто переключит CPU на другой доступный поток того же процесса.

#### **Сформулируйте общий вывод лекции для случая real-time + threads: какие свойства планировщика становятся ключевыми и почему? ⭐⭐⭐**

В случае сочетания многопоточности и реального времени ключевыми становятся **предсказуемость (predictability)** и строгое соблюдение **дедлайнов**. Планировщик обязан минимизировать **накладные расходы** на переключение контекста и гарантировать, что высокоприоритетные потоки не будут блокированы из-за инверсии приоритетов. Разделение политики и механизма здесь критично: приложение должно иметь возможность жестко задавать дедлайны своим потокам, опираясь на надежные механизмы исполнения, предоставляемые ядром.