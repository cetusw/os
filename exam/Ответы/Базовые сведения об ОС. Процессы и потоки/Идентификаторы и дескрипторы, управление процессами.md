#### **Что такое PID и какие свойства у него есть (уникальность, переиспользование, область видимости)? ⭐**:

**PID (Process Identifier)** — это уникальный числовой идентификатор, который операционная система присваивает каждому процессу в момент его создания,.

**Основные свойства PID:**

- **Уникальность:** В рамках одной операционной системы в любой момент времени не может существовать двух разных процессов с одинаковым PID.
- **Переиспользование:** После завершения процесса его идентификатор может быть спустя некоторое время использован повторно для нового процесса. Это требует от программистов осторожности, так как посылка сигнала по старому PID может случайно затронуть «нового владельца» этого номера.
- **Область видимости:** PID является глобальным идентификатором в системе. Он виден в системных утилитах, таких как диспетчер задач или `ps`, и используется системными вызовами для базового управления,.

---

#### **В чём отличие PID от HANDLE: почему PID — это «паспорт», а HANDLE — «ключ»? ⭐⭐**:

В ОС Windows существует четкое разделение между этими понятиями,.

- **PID («Паспорт»):** Это глобальный номер, который просто называет процесс. Зная PID, вы знаете, «кто» это, но это не дает вам автоматического права управлять им.
- **HANDLE («Ключ»):** Это дескриптор объекта ядра, возвращаемый API (например, `CreateProcess`). Это своего рода токен доступа, который подтверждает ваше право выполнять конкретные действия над процессом (ожидать завершения, менять приоритет и т.д.),.

**Сравнение в псевдографике:**

```
[ Система ]
    |
    +--> [ Процесс ] PID: 4520 (Паспорт - идентификация)
    |       ^
    |       |
[ Программа-владелец ]
    |       |
    +--> [ HANDLE ] (Ключ - дает право доступа к объекту процесса)
```

---

#### **Какие операции обычно можно выполнить, имея только PID, и какие требуют более «сильной ссылки» на объект? ⭐⭐**:

Имея только **PID**, в большинстве систем можно выполнить базовые административные действия, если у пользователя достаточно прав,:

- Отправка сигнала (например, `kill` в Linux).
- Получение общей информации о процессе (владелец, использование CPU).
- Ожидание завершения (в UNIX через `waitpid`).

Более «сильная ссылка» (например, **HANDLE** в Windows) требуется для глубокого управления процессом,:

- Изменение приоритета выполнения.
- Синхронизация (ожидание события в ядре).
- Дублирование ресурсов или манипуляция потоками внутри этого процесса.

---

#### **Почему в Windows объект ядра может продолжать существовать после завершения процесса, и что определяет момент его уничтожения? ⭐⭐⭐**:

В Windows процессы представлены как объекты ядра. Жизненный цикл самого кода программы и объекта в ядре не совпадает.

После того как процесс завершил выполнение (стадия Terminated), его объект в ядре продолжает существовать до тех пор, пока на него открыт хотя бы один **HANDLE**. Это необходимо, чтобы родительский процесс (или другие процессы, имеющие дескриптор) мог гарантированно прочитать код выхода процесса через функцию `GetExitCodeProcess`. Объект окончательно уничтожается только тогда, когда счетчик ссылок на него становится равным нулю, то есть все дескрипторы закрыты через `CloseHandle`,.

---

#### **Объясните, как в Linux соотносятся PID, TID и TGID, и почему главный поток имеет PID = TID. ⭐⭐**:

В Linux потоки реализованы как «легкие процессы», и ядро управляет ими через единую структуру `task_struct`,.

- **TID (Thread ID):** Уникальный идентификатор каждой нити (потока) в системе.
- **PID (в контексте потоков):** Для ядра это то же самое, что TID.
- **TGID (Thread Group ID):** Идентификатор группы потоков, который для пользователя выглядит как «настоящий» PID всего процесса.

У главного потока (лидера группы) **PID равен TID**, так как он первым создает эту группу. Все последующие потоки, созданные в этом процессе, получат уникальные TID, но их TGID будет равен PID главного потока, что позволяет ОС группировать их для управления сигналами и памятью.

---

#### **Как формируется дерево процессов в UNIX, и почему процесс PID 1 играет особую роль? ⭐⭐**:

В UNIX новые процессы создаются путем копирования существующих (`fork`), что естественным образом порождает иерархию «родитель–потомок»,.

Все дерево процессов восходит к самому первому процессу — **init** (или `systemd`), который всегда имеет **PID 1**,. **Его особая роль:**

1. **Корень иерархии:** Он запускает все основные системные службы и оболочки пользователей.
2. **«Усыновление» сирот:** Если родительский процесс завершается раньше дочерних, эти «процессы-сироты» принудительно переподчиняются процессу PID 1, который берет на себя обязанность корректно завершить их и забрать их код возврата.

---

#### **Что такое процесс-группа и зачем она нужна в терминальной работе (например, Ctrl-C)? ⭐⭐**:

**Процесс-группа** — это объединение нескольких связанных процессов для удобства управления ими как единым целым.

При работе в терминале это критично для обработки сигналов. Когда вы нажимаете **Ctrl-C**, драйвер терминала посылает сигнал прерывания (`SIGINT`) не одному процессу, а всей **текущей группе процессов**. Например, в конвейере `ls | grep | sort` все три программы входят в одну группу, и нажатие Ctrl-C мгновенно остановит всю цепочку обработки, а не только одну её часть.

---

#### **Почему говорят, что Windows «не хранит дерево процессов так же жёстко», как UNIX, и какие практические последствия у этого есть? ⭐⭐**:

В отличие от UNIX, где связь родитель-ребенок фиксирована и определяет логику «усыновления», в Windows процессы после создания считаются равными,.

**Практические последствия:**

- Родитель получает HANDLE ребенка только в момент создания.
- Если родитель закроет этот HANDLE или передаст его другому процессу, прямая иерархическая связь для ОС перестает существовать,.
- В Windows нет автоматического «усыновления» процессом PID 1, так как концепция иерархии носит скорее информационный, а не структурный характер.

---

#### **Что такое «потеря иерархии» при передаче HANDLE другому процессу в Windows, и почему это меняет модель управления? ⭐⭐⭐**:

В Windows управление процессом завязано на обладание **HANDLE** (ключом), а не на родственную связь,. Родитель может передать свой дескриптор дочернего процесса любой другой программе. В этот момент «право на управление» уходит от создателя к новому владельцу. Это меняет модель управления с жесткой «семейной» (как в UNIX) на объектно-ориентированную и гибкую: процессом может управлять тот, кто в данный момент владеет его «ключом», независимо от того, кто его породил,.

---

#### **Опишите модель состояний процесса: Running / Ready / Blocked. Что означает каждое состояние на практике? ⭐**:

Процесс в мультипрограммной системе может находиться в одном из трех ключевых состояний,:

1. **Running (Выполняется):** Процесс фактически использует процессор в данный такт времени.
2. **Ready (Готов):** Процесс готов к работе, у него есть все ресурсы, но процессор занят другой задачей. Он ждет своей очереди.
3. **Blocked (Заблокирован):** Процесс не может продолжать работу, так как ждет внешнего события (завершения ввода-вывода, прихода данных из сети или сигнала).

---

#### **Разберите переходы между состояниями: какие из них вызваны внешними событиями, а какие — решениями планировщика? ⭐⭐**:

- **Running → Blocked:** Вызвано самим процессом (запрос ввода-вывода).
- **Blocked → Ready:** Вызвано **внешним событием** (данные с диска прочитаны, прерывание от устройства произошло).
- **Running → Ready:** Вызвано решением **планировщика** (истек квант времени, выделенный процессу).
- **Ready → Running:** Вызвано решением **планировщика** (выбор наиболее приоритетной задачи из очереди готовых).

**Схема переходов:**

```
 (1) Блокировка на I/O
 Running ---------------------> Blocked
    ^                             |
    | (4) Выбор планировщиком     | (2) Событие произошло
    |                             v
  Ready <-------------------------+
    |                             ^
    +-----------------------------+
       (3) Таймер (вытеснение)
```

---

#### **Почему процесс может быть Ready, но не Running, и какие факторы влияют на то, когда он получит CPU? ⭐⭐**:

Процесс находится в состоянии **Ready**, когда система перегружена или использует мультипрограммирование для повышения загрузки CPU,.

**Факторы влияния:**

- **Квант времени:** Планировщик снимает процесс с CPU по истечении таймера (обычно десятки мс), переводя его в Ready,.
- **Приоритет:** Более важные процессы (например, UI или системные службы) могут вытеснять менее важные задачи.
- **Алгоритм планирования:** Например, в Round Robin процессы получают CPU строго по очереди.

---

#### **На примере pipeline cat | grep объясните, почему один процесс может быть Blocked, а другой — Running/Ready, и как это связано с I/O. ⭐⭐**:

В цепочке `cat | grep`:

- `cat` читает файл и выдает поток данных.
- `grep` ждет эти данные на вход.

Если файл большой или диск медленный, `grep` будет находиться в состоянии **Blocked**, так как ему нечего обрабатывать. Как только `cat` записывает данные в канал (pipe), ОС «будит» `grep`, переводя его в **Ready**. Если в этот момент CPU свободен, `grep` переходит в **Running** и обрабатывает данные. Это позволяет системе эффективно перекрывать медленный ввод-вывод полезными вычислениями других процессов.

---

#### **Чем отличается блокировка на I/O от «просто ожидания кванта времени» с точки зрения эффективности системы? ⭐⭐⭐**:

- **Ожидание кванта (Ready):** Это чистая конкуренция за CPU. Процесс готов считать, но ему мешают другие. Это снижает индивидуальную скорость процесса, но не эффективность CPU.
- **Блокировка на I/O (Blocked):** Это ожидание физически медленного устройства (диска, сети). С точки зрения системы это «золотое время»: вместо того чтобы CPU простаивал, ожидая диск (который в миллионы раз медленнее памяти), планировщик переключает его на другой процесс из очереди **Ready**,. Модель мультипрограммирования гласит: чем больше процессов в памяти, тем выше вероятность, что хоть один из них не будет заблокирован на I/O и займет процессор.

---

#### **Что такое PCB (Process Control Block) и какие данные в нём критичны для переключения контекста? ⭐⭐**:

**PCB (в Linux — `task_struct`)** — это структура данных в ядре, хранящая всё состояние процесса,.

**Критичные данные для переключения контекста:**

- **Регистры процессора:** Состояние всех вычислительных блоков на момент прерывания.
- **Program Counter (PC):** Адрес инструкции, на которой процесс был остановлен.
- **Stack Pointer (SP):** Указатель на текущую вершину стека процесса.
- **Состояние памяти:** Ссылки на таблицы страниц (адресное пространство),.

---

#### **Почему таблица процессов — это не просто список, а центральная структура для планировщика, сигналов, памяти и файлов? ⭐⭐⭐**:

Таблица процессов (массив PCB) связывает воедино все подсистемы ОС:

- **Планировщик:** Использует записи таблицы для выбора процесса с флагом `Ready`.
- **Сигналы:** В PCB хранятся маски заблокированных и ожидающих сигналов.
- **Память:** Каждая запись указывает на дескриптор памяти (`mm_struct`), определяющий границы адресного пространства процесса.
- **Файлы:** В PCB хранится таблица открытых дескрипторов (файлов, сокетов),. Без этой централизации ОС не смогла бы изолировать ресурсы и переключаться между задачами без потери данных.

---

#### **Опишите, что происходит при переключении контекста: какие части состояния сохраняются и где именно. ⭐⭐⭐**:

**Переключение контекста (Context Switch)** — это дорогая операция смены активного процесса.

1. **Сохранение:** Текущие значения регистров, PC и SP сохраняются в записи таблицы процессов (PCB) текущего процесса.
2. **Смена режима:** Происходит переход в режим ядра.
3. **Загрузка:** Состояние нового процесса (его регистры и PC) извлекается из его записи в таблице процессов.
4. **Смена памяти:** MMU перенастраивается на новые таблицы страниц (на x86 — загрузка нового адреса в регистр `CR3`),.
5. **Возврат:** CPU начинает выполнять код нового процесса с восстановленного адреса.

---

#### **Почему процесс может быть прерван тысячи раз, но «не замечать этого»? Какие условия должны соблюдаться для этой иллюзии? ⭐⭐**:

Процесс не замечает прерываний, так как ОС обеспечивает **прозрачность восстановления состояния**. **Условия иллюзии:**

1. **Полное сохранение контекста:** При возвращении все регистры и флаги должны быть идентичны моменту прерывания.
2. **Изоляция времени:** Процесс не должен полагаться на циклы задержки («idle loops»), так как реальное время между инструкциями непредсказуемо из-за переключений,.
3. **Атомарность инструкций:** ОС должна гарантировать, что процесс возобновляется ровно с той инструкции, которая была прервана (решается аппаратно через сохранение PC).

---

#### **Как связаны понятия прерывание, обработчик, вектор прерываний и последующее решение планировщика? ⭐⭐⭐**:

Связь реализуется по следующей цепочке,:

1. **Прерывание:** Аппаратный сигнал (например, от таймера или диска) приостанавливает CPU.
2. **Вектор прерываний:** Аппаратура использует номер прерывания как индекс в специальной таблице (векторе), чтобы найти адрес нужной функции.
3. **Обработчик:** Запускается низкоуровневый код ОС, который сохраняет текущий контекст и выполняет работу (например, считывает данные из контроллера).
4. **Планировщик:** По завершении обработчика управление не обязательно возвращается к прерванному процессу. ОС может вызвать планировщик, чтобы выбрать более приоритетную задачу из очереди готовых.

---

#### **Что такое task_struct в Linux и почему его считают «сердцем» модели процессов? ⭐⭐⭐**:

**`task_struct`** — это структура данных в ядре Linux, представляющая дескриптор процесса или потока. Она является «сердцем», потому что содержит абсолютно всю информацию о сущности исполнения:

- **Идентификаторы:** PID, TGID (для группировки потоков), PPID.
- **Состояние:** Текущий статус (Running, Interruptible и др.).
- **Ресурсы:** Указатели на таблицы памяти (`mm_struct`) и файлы (`files_struct`).
- **Связи:** Ссылки на родительские и дочерние процессы, а также на очереди планировщика. Любой системный вызов (например, `getpid` или `fork`) опирается именно на данные внутри `task_struct` текущего процесса.