#### **Зачем ядру нужно различать spin_lock, spin_lock_irq и spin_lock_irqsave? Опишите типичный сценарий для каждого. ⭐⭐⭐**:

Ядро использует разные виды спинлоков в зависимости от того, в каком контексте защищаются данные.

- **`spin_lock`**: Отключает только вытеснение ядра на текущем процессоре. Типичный сценарий — работа с данными, которые **гарантированно не используются** в обработчиках прерываний.
- **`spin_lock_irq`**: Отключает вытеснение и локальные прерывания на текущем CPU. Применяется, когда данные используются и в обычном контексте ядра, и в прерываниях, чтобы обработчик не мог вытеснить текущий поток и попытаться захватить тот же замок.
- **`spin_lock_irqsave`**: Самый универсальный и надежный вариант. Он **сохраняет текущее состояние прерываний**, отключает их и захватывает замок. Используется, когда критическая секция может быть вызвана из кода, где прерывания уже могут быть отключены.

---

#### **Почему «спать» внутри спинлока нельзя? Приведите пример deadlock-сценария. ⭐⭐**:

Сон внутри спинлока запрещен, так как поток, удерживающий блокировку, не освободит её, пока не проснется. В многопроцессорных системах (SMP) другие потоки, пытающиеся захватить этот же замок, будут находиться в состоянии **активного ожидания (busy waiting)**, бесконечно потребляя ресурсы CPU. **Пример дедлока:** Поток А захватил спинлок и «уснул» (например, ожидая I/O). Поток Б на другом ядре пытается захватить этот же спинлок и вечно крутится в цикле, ожидая освобождения, которое не произойдет, пока Поток А не получит CPU для продолжения работы, но Поток Б может занимать это самое ядро.

---

#### **В чём опасность, если обработчик прерывания попытается захватить тот же спинлок на том же CPU? Как это предотвращают? ⭐⭐⭐**:

Возникает ситуация **неизбежного дедлока**. Если обычный процесс захватил спинлок, и в этот момент на том же ядре возникло прерывание, обработчик которого хочет тот же замок, он начнет вечно ждать его освобождения. Однако прерванный процесс не сможет возобновить работу и освободить замок, пока обработчик не закончит выполнение. Это предотвращают использованием `spin_lock_irq` или `spin_lock_irqsave`, которые **отключают локальные прерывания** на время удержания замка.

---

#### **Почему spin_lock_irq может быть быстрее irqsave, но потенциально опаснее? ⭐⭐**:

`spin_lock_irq` работает быстрее, так как не тратит такты на сохранение состояния регистра флагов (состояния прерываний). Опасность заключается в том, что при выходе (`spin_unlock_irq`) она **всегда принудительно включает прерывания**, даже если до входа в критическую секцию они были выключены по другой причине. Это может нарушить логику вложенных функций ядра.

---

#### **Что происходит с латентностью прерываний, если слишком часто/долго держать spin_lock_irqsave? Чем это грозит системе? ⭐⭐⭐**:

Длительное удержание таких замков напрямую **увеличивает латентность (задержку)** обработки внешних событий. Пока прерывания отключены, система «слепа» к сигналам от оборудования (сетевые пакеты, тики таймера). Это грозит потерей отзывчивости, пропусками данных от устройств и общей нестабильностью ОС.

---

#### **В чём фундаментальная проблема примитивов sleep()/wakeup() как абстракции, если нет «памяти о сигнале»? ⭐⭐**:

Фундаментальный недостаток — риск **потери сигнала пробуждения**. Если `wakeup()` отправляется процессу, который еще не успел выполнить `sleep()`, этот сигнал просто исчезает, и процесс, уснув позже, может никогда не проснуться.

---

#### **Разберите сценарий «потерянного wakeup» в producer-consumer из слайдов: какие именно шаги приводят к вечному сну? ⭐⭐⭐**:

1. Буфер пуст, потребитель проверяет `count == 0`.
2. В этот момент происходит переключение контекста на производителя.
3. Производитель кладет товар, делает `count = 1` и посылает `wakeup(consumer)`.
4. Поскольку потребитель логически еще не спит, сигнал **теряется**.
5. Потребитель возобновляется и выполняет команду `sleep()`, засыпая навсегда, так как производитель больше не будет его будить (он думает, что потребитель уже активен).

---

#### **Почему «wakeup waiting bit» решает проблему только для двух процессов и начинает ломаться при увеличении числа участников? ⭐⭐⭐**:

Этот бит работает как примитивный запоминатель одного пропущенного сигнала. Когда процессов больше двух, одного бита недостаточно, чтобы учесть ситуации, когда сразу несколько `wakeup` были отправлены разным участникам или когда сигналы приходят от нескольких источников одновременно — информация о количестве и адресатах сигналов теряется.

---

#### **Как связаны sleep/wakeup, очереди ожидания и «ожидание по адресу» (sleep(address)/wakeup(address))? Почему привязка к адресу полезна? ⭐⭐**:

В современных ОС `sleep` и `wakeup` оперируют не просто процессами, а **очередями ожидания**, связанными с конкретным адресом ресурса в памяти. Привязка к адресу полезна тем, что `wakeup(address)` будит **только те процессы**, которые ждут события именно на этом ресурсе, предотвращая лишние пробуждения (проблема «stray wakeups»).

---

#### **Чем отличаются «sleep как задержка по времени» (nanosleep) и «sleep как IPC/синхронизация»? Почему путаница опасна? ⭐⭐**:

- **`nanosleep` / `Sleep(ms)`**: Просто приостанавливает поток на фиксированное время.
- **`wait_event` / `WaitForSingleObject`**: Блокирует поток до наступления **логического события** от другого процесса. Путаница опасна, так как использование задержек по времени для ожидания данных (вместо механизмов синхронизации) делает систему крайне неэффективной и непредсказуемой.

---

#### **Семафор как «счётчик сохранённых wakeup’ов»: объясните модель и почему она предотвращает потерю сигналов. ⭐⭐**:

Семафор хранит целое число, которое инкрементируется при каждом сигнале (`up`) и декрементируется при потреблении ресурса (`down`). Если сигнал `up` приходит раньше, чем `down`, значение семафора просто увеличивается, становясь **«сохраненным пробуждением»**, которое следующий процесс использует без блокировки.

---

#### **Почему операции down/up в семафоре должны быть атомарными? Что именно должно быть «неделимо» и какая гонка иначе появится? ⭐⭐⭐**:

Проверка значения семафора и его изменение должны быть **неделимыми (атомарными)**. Если два процесса одновременно проверят семафор со значением 1, оба увидят, что он больше нуля, и оба успешно выполнят `down`, уменьшив его до -1. В результате в критическую секцию попадут двое, что нарушает принцип взаимного исключения.

---

#### **В задаче producer-consumer объясните роль трёх семафоров mutex/empty/full как двух разных применений: mutual exclusion vs ordering. ⭐⭐**:

- **`mutex`**: Используется для **взаимного исключения (mutual exclusion)**, гарантируя, что только один поток одновременно манипулирует памятью буфера.
- **`empty` и `full`**: Используются для **синхронизации (ordering)**, контролируя порядок событий: нельзя класть в полный буфер и нельзя брать из пустого.

---

#### **Сравните std::counting_semaphore и std::condition_variable как инструменты синхронизации: где проще семафор, а где — condvar? ⭐⭐⭐**:

- **Семафор проще**, когда нужно просто **считать доступные ресурсы** или ограничить их количество, так как он сам хранит состояние накопленных сигналов.
- **Condition variable** эффективнее для ожидания **сложных логических условий** (например, «флаг равен true И список не пуст»), но она требует мьютекса и **не хранит сигналы** (если `notify` вызван, когда никто не ждет, он теряется).

---

#### **Как бы вы спроектировали ограничитель ресурсов (например, «не больше K одновременных запросов») в C++20: какие примитивы выберете и какие corner cases учтёте? ⭐⭐⭐**:

Идеальным выбором будет **`std::counting_semaphore<K>`**, инициализированный значением `K`.

1. Каждый поток при входе вызывает `acquire()`.
2. При выходе поток вызывает `release()`.
3. **Corner cases**: Необходимо использовать RAII-обертки для гарантированного вызова `release()` в случае возникновения исключений, чтобы не допустить «утечки» разрешений. Также стоит учитывать возможность «голодания» потоков при очень высокой нагрузке.