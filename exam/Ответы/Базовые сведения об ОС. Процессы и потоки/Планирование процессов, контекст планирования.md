#### **Необходимость планирования и состояния процессов ⭐**:

В многопрограммных системах одновременно может существовать множество процессов, претендующих на использование центрального процессора (CPU). Поскольку количество ядер процессора обычно меньше количества активных задач, возникает необходимость в **планировщике**, который решает, какой процесс получит доступ к CPU и на какое время.

Для эффективного управления выделяют три основных состояния процесса:

1. **Running (Выполнение):** Процесс занимает CPU и исполняет инструкции в данный момент.
2. **Ready (Готовность):** Процесс готов к работе, но временно остановлен, чтобы дать возможность поработать другому процессу.
3. **Blocked (Блокировка):** Процесс ожидает внешнего события (например, завершения ввода-вывода или сигнала), без которого он не может продолжать выполнение.

---

#### **Планировщик и алгоритм планирования ⭐**:

**Планировщик (scheduler)** — это компонент операционной системы (механизм), который выполняет физическое переключение между задачами. **Алгоритм планирования** — это набор правил и логика (политика), на основе которых планировщик делает свой выбор.

**Примеры решений планировщика:**

- Выбор процесса из очереди готовых для запуска на свободном ядре.
- Принудительное прерывание текущего процесса по истечении его кванта времени (вытеснение).
- Динамическое изменение приоритета процесса в зависимости от его поведения (например, повышение приоритета для I/O-зависимых задач).

---

#### **Планирование процессов и потоков ⭐⭐**:

Принципы планирования применимы к обоим типам объектов, так как потоки являются «процессами внутри процесса» и делят его ресурсы. В современных ОС именно **поток является единицей планирования**, в то время как процесс рассматривается как единица владения ресурсами.

**Что меняется при планировании потоков:**

- **Контекст:** Переключение между потоками одного процесса происходит быстрее, так как не требуется смена адресного пространства (таблиц страниц MMU).
- **Уровни:** Существует разделение на потоки уровня пользователя (управляются библиотекой) и уровня ядра. При использовании потоков уровня ядра планировщик может распределять потоки одного процесса по разным физическим ядрам CPU для реального параллелизма.

---

#### **Роль планирования в разных типах систем ⭐⭐**:

Важность и цели планирования зависят от среды эксплуатации:

- **Пакетные системы (Batch):** Главная цель — максимальная пропускная способность (**throughput**) и минимизация времени оборота задач. Здесь допустимы длинные кванты времени для снижения накладных расходов на переключения.
- **Персональные компьютеры (PC):** Акцент делается на **отзывчивость** пользовательского интерфейса. Планировщик должен гарантировать, что активное приложение не «замирает».
- **Серверы:** Важен баланс между обслуживанием множества конкурирующих клиентов, справедливостью распределения ресурсов и эффективным использованием CPU.

---

#### **Критические сценарии на быстрых ПК ⭐⭐**:

Даже на мощном оборудовании планирование критично для задач с высокими требованиями к непрерывности выполнения:

- **Рендеринг видео и игры:** Требуют стабильных вычислительных всплесков (**CPU burst**). Любые задержки в планировании приводят к «фризам» или jitter-эффекту.
- **Аудио- и видеопотоки:** Относятся к системам мягкого реального времени; планировщик должен обеспечивать предсказуемость, чтобы избежать провалов в воспроизведении.

---

#### **Энергопотребление в IoT и смартфонах ⭐⭐**:

В мобильных и встроенных устройствах алгоритмы планирования напрямую влияют на **заряд батареи**. **Компромиссы:**

- Агрессивное засыпание CPU для экономии энергии может увеличить задержку (latency) при пробуждении для обработки события.
- Планировщик может намеренно снижать частоту процессора или объединять задачи (batching) для минимизации периодов активности, что может негативно сказаться на пиковой производительности.

---

#### **Переключение контекста (Context Switch) ⭐⭐**:

Переключение контекста — это процесс замены одного исполняемого процесса другим, выполняемый в режиме ядра. **Что происходит на уровне CPU и ОС:**

1. **Сохранение:** Текущее состояние (счетчик команд PC, указатель стека SP, общие регистры) сохраняется в таблице процессов (PCB).
2. **Смена режима:** Переход из пользовательского режима в режим ядра.
3. **Загрузка:** Планировщик выбирает новый процесс и загружает его регистры из PCB.
4. **MMU:** Происходит переключение таблиц страниц, что делает видимым адресное пространство нового процесса.

Это считается **«дорогой» операцией**, так как во время переключения CPU не выполняет никакой полезной работы пользователя.

---

#### **Накладные расходы и архитектура памяти ⭐⭐**:

Компоненты стоимости переключения зависят от аппаратных особенностей:

- **MMU и таблицы страниц:** Необходимость обновления указателя на корень таблиц в регистре (например, CR3 в x86).
- **TLB (Кэш трансляции):** При смене процесса TLB часто должен быть очищен (flush), что приводит к медленному доступу к памяти на начальном этапе работы нового процесса из-за промахов в TLB.
- **Кэши (L1/L2):** Новый процесс сталкивается с «холодным кэшем», так как данные предыдущего процесса вытеснили его собственные данные из быстрой памяти.

---

#### **Частые переключения и производительность ⭐⭐**:

Если квант времени (time slice) слишком мал, доля времени, затрачиваемая на накладные расходы переключения, становится чрезмерной по отношению к полезному времени вычислений. В результате, даже если CPU загружен на 100%, реальная **полезная производительность системы падает**, так как процессор занят преимущественно обслуживанием самой ОС (сохранением и восстановлением состояний).

---

#### **Выбор длины кванта (Time Slice) ⭐⭐**:

Выбор кванта времени — это баланс между эффективностью и отзывчивостью:

- **Короткий квант:** Обеспечивает отличную интерактивность (много процессов кажутся работающими одновременно), но увеличивает процент времени, теряемого на переключения контекста.
- **Длинный квант:** Повышает эффективность использования CPU (меньше переключений), но ухудшает время отклика — пользователь может заметить задержки в реакции приложений.

На качественном уровне: квант должен быть значительно больше времени одного переключения контекста, чтобы накладные расходы не превышали нескольких процентов от общего времени.

---

#### **Метрики и симптомы избыточного переключения ⭐⭐⭐**:

Указать на проблемы с накладными расходами могут следующие признаки:

- **Метрики:** Высокое значение «System Time» (время в режиме ядра) по сравнению с «User Time» при общей высокой загрузке CPU.
- **Низкий Throughput:** Снижение количества завершенных задач в единицу времени при увеличении числа активных процессов.
- **Симптомы:** «Заикание» звука, пропуски кадров в видео или нестабильное время отклика (jitter) интерфейса, когда система тратит больше времени на переупорядочивание задач, чем на их выполнение.