#### **Перечислите основные ситуации, когда в системе создаются процессы (boot, пользователь, родитель, batch) и объясните их отличия. ⭐**:

В современных операционных системах можно выделить четыре основные ситуации, приводящие к созданию нового процесса:

1. **Инициализация системы (Boot):** При загрузке ОС создается множество процессов. Часть из них — **foreground-процессы**, взаимодействующие с пользователем, другие — **background-процессы (демоны в UNIX, службы в Windows)**. Они выполняют системные задачи: проверку почты, работу веб-сервера или антивируса.
2. **Запрос от работающего процесса:** Работающая программа может выполнить системный вызов для создания одного или нескольких вспомогательных процессов (например, для одновременного получения данных из сети и их обработки). Здесь возникает иерархия «родитель–ребенок».
3. **Запрос пользователя:** Пользователь инициирует создание процесса, запуская программу через командную строку или двойным кликом по иконке. В UNIX-системах с графической оболочкой новый процесс может «захватить» окно, в котором он был запущен.
4. **Инициирование пакетного задания (Batch):** Применяется в основном на мейнфреймах. Пользователь передает системе список заданий (batch job), и когда ОС располагает ресурсами, она создает новый процесс для выполнения следующего задания из очереди.

**Схема создания:**

```
[ Старт ОС ] ----> [ Первый процесс (init/systemd) ]
                          |
             +------------+-----------+
             |                        |
      [ Системные демоны ]     [ Пользовательский Shell ]
                                      |
                               [ Команда пользователя ]
                                      |
                               [ Новый процесс ]
```

---

#### **Почему в UNIX исторически сложилась двухшаговая модель fork() → exec(), и какие преимущества она даёт? ⭐⭐**:

В UNIX создание процесса разделено на два этапа:

1. **fork():** создает точную копию родительского процесса.
2. **exec() (и его варианты):** заменяет программный образ (код и данные) текущего процесса новым кодом из исполняемого файла.

**Преимущества такой модели:** Основное преимущество — наличие «окна» между созданием копии и запуском новой программы. В этом промежутке дочерний процесс, оставаясь копией родителя, может изменять свои атрибуты (например, файловые дескрипторы), не влияя на родителя. Это позволяет легко реализовывать **перенаправление ввода-вывода (redirection)** и использование **каналов (pipes)** силами самой оболочки (shell), а не прикладной программы.

---

#### **Что именно копирует fork() и что не копируется? ⭐⭐**:

Системный вызов `fork()` создает практически идентичный дубликат процесса.

**Копируются:**

- Образ памяти (код, данные, стек).
- Значения регистров процессора (включая PC и SP).
- Переменные окружения.
- Открытые файловые дескрипторы (указатели на таблицу открытых файлов в ядре).

**НЕ копируется:**

- **PID (Process ID):** у ребенка он уникальный.
- **PPID (Parent PID):** у ребенка это PID того, кто вызвал fork.
- **Возвращаемое значение fork:** родителю возвращается PID ребенка, ребенку — 0.
- **Потоки:** в копии процесса остается только тот поток, который вызвал `fork()` (в Linux).

---

#### **Что такое copy-on-write и почему он делает fork эффективным в реальных ОС? ⭐⭐⭐**:

**Copy-on-write (COW, копирование при записи)** — это оптимизация управления памятью. При вызове `fork()` ОС не копирует сразу всю физическую память родителя, так как это дорогая и часто бесполезная операция (особенно если следом идет `exec`).

**Механизм работы:**

1. Родитель и ребенок начинают использовать **общие физические страницы памяти**.
2. Эти страницы помечаются в MMU как «только для чтения».
3. Как только один из процессов пытается **записать** данные в страницу, возникает аппаратное исключение.
4. Ядро ОС перехватывает его, создает реальную физическую копию только этой страницы, обновляет таблицы страниц и разрешает запись.

**Эффективность:** COW позволяет создавать процессы мгновенно, затрачивая память только на те фрагменты данных, которые реально различаются у родителя и ребенка.

---

#### **В чём смысл «окна» между fork() и exec() для shell-подобных программ? Приведите примеры действий, которые выполняются именно там. ⭐⭐**:

«Окно» — это период, когда дочерний процесс уже существует как отдельная сущность, но еще не начал выполнять новую программу.

**Примеры действий в этом «окне»:**

- **Перенаправление потоков:** замена стандартного вывода (stdout) на файл с помощью вызова `dup2`.
- **Настройка каналов (pipes):** закрытие ненужных концов канала перед запуском фильтров.
- **Смена окружения:** установка специфических переменных среды (`envp`), которые нужны только новой программе.
- **Смена приоритета или лимитов:** ограничение ресурсов для дочернего процесса.

---

#### **Что делает execve()/execvp() на уровне процесса, и почему говорят «заменяет образ процесса»? ⭐⭐**:

Системный вызов группы `exec` уничтожает текущее содержимое адресного пространства процесса.

**Происходящие изменения:**

1. Старый код (Text), глобальные переменные (Data) и стек (Stack) процесса удаляются из памяти.
2. В это же адресное пространство загружается новый исполняемый файл с диска.
3. Счетчик команд (PC) сбрасывается на точку входа (entry point) новой программы.
4. **Важно:** PID процесса при этом **не меняется**. С точки зрения ОС это тот же процесс, но выполняющий теперь совершенно иную работу.

---

#### **Почему в Windows используют CreateProcess вместо fork/exec, и какие возможности он даёт сразу при запуске? ⭐⭐**:

Windows была спроектирована с объектно-ориентированным подходом к ядру, где процессы — это отдельные объекты. В отличие от UNIX, Windows предпочитает создавать процесс «с нуля» за один вызов.

**Возможности CreateProcess:** Вызов имеет 10 параметров, позволяющих сразу при создании задать:

- Атрибуты безопасности (Security Attributes) для процесса и потоков.
- Флаги наследования дескрипторов (Handles).
- Приоритет выполнения.
- Конфигурацию окна (если это GUI-приложение).
- Командную строку и переменные окружения. Это избавляет от необходимости копирования адресного пространства родителя.

---

#### **Какие типичные ошибки делают при работе с CreateProcess (например, командная строка, наследование дескрипторов, ожидание завершения)? ⭐⭐⭐**:

1. **Модификация командной строки:** `CreateProcess` может изменять переданный буфер строки, поэтому передача строкового литерала напрямую часто ведет к ошибке доступа (Access Violation).
2. **Утечка Handles:** Если забыть вызвать `CloseHandle` для `pi.hProcess` и `pi.hThread` после создания, объекты ядра не будут уничтожены даже после завершения процесса.
3. **Неверное наследование:** Ошибка в установке флага `bInheritHandles` может привести к тому, что дочерний процесс получит доступ к файлам родителя, к которым не должен иметь доступа.
4. **Отсутствие ожидания:** Программисты часто забывают вызвать `WaitForSingleObject`, из-за чего родитель продолжает работу, не зная, успешно ли выполнился ребенок.

---

#### **Объясните, зачем родителю ждать дочерний процесс (waitpid / WaitForSingleObject), и что может случиться, если этого не делать. ⭐⭐**:

Ожидание необходимо для синхронизации и получения результата работы.

**Последствия отсутствия ожидания:**

- **UNIX:** Процесс превращается в **зомби (zombie)**. Он завершен, ресурсы памяти освобождены, но запись в таблице процессов (с кодом возврата) остается. Если родитель никогда не вызовет `wait()`, таблица процессов может переполниться.
- **Windows:** Хотя понятия «зомби» нет, объект процесса в ядре остается активным, пока открыт его HANDLE.
- **Логика:** Родитель не узнает код возврата (успех/ошибка) и может начать использовать данные, которые ребенок еще не успел записать.

---

#### **Какие бывают причины завершения процесса и чем отличается «ошибка программы» от «принудительного убийства»? ⭐**:

1. **Нормальный выход (voluntary):** Программа завершила работу и вызвала `exit()` или `ExitProcess`.
2. **Ошибочный выход (voluntary):** Программа обнаружила ошибку (например, отсутствие файла) и сама решила завершиться с ненулевым кодом.
3. **Фатальная ошибка (involuntary):** Ошибка выполнения, вызвавшая исключение процессора (деление на ноль, обращение к чужой памяти).
4. **Убийство другим процессом (involuntary):** Вызов `kill` (UNIX) или `TerminateProcess` (Windows).

**Отличие:** «Ошибка программы» инициируется аппаратурой или ядром из-за некорректного кода, а «убийство» — это внешнее управленческое действие со стороны пользователя или другого процесса.

---

#### **Чем отличается exit-код процесса от завершения сигналом, и почему ОС должна уметь различать эти сценарии? ⭐⭐**:

- **Exit-код:** Целое число (0–255), которое программа осознанно передает ОС как отчет о своей работе.
- **Завершение сигналом:** Процесс был прерван извне (или ядром). У него нет возможности вернуть код, так как он не дошел до инструкции `exit`.

**Зачем различать:** Это критично для автоматизированных систем (скриптов, CI/CD). Одно дело, если программа вернула 1 (логическая ошибка), и совсем другое — если она упала с `SIGSEGV` (ошибка памяти в коде). Второе требует исправления кода программы, а первое — проверки входных данных.

---

#### **Как родитель в UNIX может определить: ребёнок завершился нормально или был убит сигналом? ⭐⭐**:

Для этого используются специальные макросы, применяемые к статусу, полученному из `waitpid()`:

- `WIFEXITED(status)`: возвращает true, если процесс завершился сам (вызов `exit`). Тогда код возврата берется через `WEXITSTATUS(status)`.
- `WIFSIGNALED(status)`: возвращает true, если процесс был убит сигналом. Номер сигнала тогда берется через `WTERMSIG(status)`.

---

#### **Что означает «завершение родителя ≠ завершение детей» и какие последствия это имеет для архитектуры сервисов? ⭐⭐**:

В большинстве ОС дочерние процессы живут независимо от родителя. Если родитель завершается раньше детей:

- В UNIX дети становятся **сиротами (orphans)** и «усыновляются» процессом `init` (PID 1).
- Это позволяет создавать **демонов**: процесс-родитель запускается, делает `fork` и тут же завершается, а ребенок продолжает работать в фоне.

**Последствия для архитектуры:** Разработчики должны явно предусматривать механизмы остановки всей группы процессов (например, через отправку сигналов всей группе процессов в UNIX), иначе в системе останутся «брошенные» фоновые задачи, потребляющие ресурсы.

---

#### **Почему в многопользовательской системе нельзя разрешать «кому угодно» завершать чужие процессы? Какие механизмы авторизации обычно применяются? ⭐⭐⭐**:

Разрешение бесконтрольного завершения процессов привело бы к тому, что один пользователь мог бы остановить работу всей системы или сорвать вычисления конкурента (Denial of Service).

**Механизмы авторизации:**

- **UID (User ID):** ОС проверяет, совпадает ли UID того, кто посылает сигнал, с UID владельца процесса.
- **Групповые права:** В некоторых случаях права могут расширяться на группу.
- **Привилегии (root/Administrator):** Только суперпользователь имеет право убивать любые процессы в системе для поддержания ее стабильности.

---

#### **Почему fork в C++ может «ломать» привычный жизненный цикл объектов, и какие классы проблем это порождает? ⭐⭐**:

Проблема в том, что `fork()` копирует адресное пространство «как есть» (бинарно), не зная о логике C++.

1. **Двойные деструкторы:** Объект, созданный до `fork`, существует в двух экземплярах. При завершении процессов деструктор вызовется дважды. Если в деструкторе закрывается файл или удаляется временный файл, второй процесс получит ошибку или удалит нужные данные.
2. **Отсутствие конструкторов:** В дочернем процессе объекты уже «живут», но их конструкторы там не вызывались.
3. **Состояние мьютексов:** Если поток в родителе держал мьютекс во время `fork`, в ребенке этот мьютекс навсегда останется заблокированным (так как поток-владелец в ребенка не скопировался).

---

#### **Объясните разницу между exit() и _exit() в дочернем процессе после fork, и почему неправильный выбор может приводить к багам. ⭐⭐⭐**:

- **exit():** Стандартная функция C. Вызывает функции, зарегистрированные через `atexit`, и, самое главное, **сбрасывает буферы ввода-вывода (flush)** стандартных библиотек.
- **_exit() (или _Exit()):** Системный вызов ядра. Завершает процесс немедленно, не трогая буферы и не вызывая обработчики.

**Почему это важно:** Если дочерний процесс после `fork` не делает `exec` и выходит через `exit()`, он может повторно сбросить буферы (например, `printf`), которые уже были в родителе. В итоге в логах или консоли строки напечатаются **дважды**. Для выхода из ребенка, который не запустил новую программу, следует использовать `_exit`.

---

#### **Приведите примеры ресурсов (файлы, сокеты, lock-файлы, логи), которые после fork могут привести к ошибкам, и предложите стратегии безопасного дизайна. ⭐⭐⭐**:

1. **Лог-файлы:** Два процесса пишут в один дескриптор. Сообщения могут перемешиваться или перезаписывать друг друга.
2. **Сокеты:** Оба процесса могут пытаться читать из одного сокета. Кто получит данные — непредсказуемо.
3. **Lock-файлы:** Деструктор ребенка может удалить lock-файл, хотя родитель еще работает с ресурсом.

**Стратегии безопасного дизайна:**

- **Сразу после fork делать exec:** Это самый надежный способ очистить состояние.
- **Флаг FD_CLOEXEC:** Устанавливать на файловые дескрипторы, чтобы они автоматически закрывались при вызове `exec`.
- **Использование pthread_atfork:** Регистрация функций, которые подготовят ресурсы (например, разблокируют мьютексы) непосредственно перед и после клонирования.
- **Явное закрытие:** В дочернем процессе сразу после `fork` нужно пройтись по списку ресурсов и закрыть те, которые ему не принадлежат.