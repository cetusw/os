#### **Почему в ОС вообще нужны абстракции (процессы/адресные пространства/файлы), и какие проблемы «железа» они скрывают от программиста? ⭐⭐**:

Абстракции необходимы для превращения «ужасного» и хаотичного интерфейса аппаратного обеспечения в «прекрасную» и удобную модель для программиста. Современное «железо» крайне сложно: например, интерфейс работы с диском SATA описывается сотнями страниц документации. Если бы каждый программист должен был учитывать физическое перемещение головок диска или номера секторов, разработка ПО стала бы почти невозможной.

ОС скрывает следующие проблемы:

- **Сложность ввода-вывода**: Вместо управления регистрами контроллера диска программист видит **файлы**.
- **Ограниченность и фрагментация ресурсов**: Вместо управления физическими планками ОЗУ используется **адресное пространство**.
- **Управление временем**: Вместо ручного деления времени процессора используется абстракция **процесса**, создающая иллюзию владения виртуальным CPU.

```
+-----------------------+
|  Прикладная программа | <--- Видит «красивый» интерфейс (файлы, процессы)
+-----------------------+
| Операционная система  | <--- Превращает «ужасное» в «красивое»
+-----------------------+
|      Hardware         | <--- «Ужасный» интерфейс (регистры, прерывания)
+-----------------------+
```

---

#### **Чем «программа» отличается от «процесса», и какие атрибуты превращают код на диске в выполняющийся процесс? ⭐**:

Различие между ними фундаментально и часто объясняется через кулинарную аналогию: **программа** — это статический рецепт (код на диске), а **процесс** — это сама деятельность по приготовлению блюда (выполнение программы).

Атрибуты, превращающие пассивный код в активный процесс:

1. **Счетчик команд (PC)**: указывает на текущую выполняемую инструкцию.
2. **Регистры процессора**: хранят промежуточные данные вычислений.
3. **Адресное пространство**: область памяти, содержащая код, переменные (Data) и стек (Stack).
4. **Ресурсы**: список открытых файлов, назначенные таймеры и сигналы.

---

#### **Как адресное пространство помогает одновременно в удобстве программирования и в безопасности? ⭐⭐**:

Абстракция адресного пространства отделяет логические адреса программы от физических адресов памяти.

- **Удобство**: Программисту предоставляется иллюзия линейной памяти, начинающейся с адреса 0. Ему не нужно знать, в какую именно физическую ячейку ОЗУ будет загружен код. Адрес 28 в одном процессе логически не связан с адресом 28 в другом.
- **Безопасность**: ОС изолирует процессы друг от друга. Используя аппаратные средства (например, MMU), система гарантирует, что один процесс не сможет прочитать или изменить память другого. Если программа попытается выйти за границы своего адресного пространства, произойдет аппаратное исключение (segmentation fault), и ОС завершит нарушителя.

---

#### **Приведите пример: какая одна и та же операция может выглядеть «как работа с файлом», но на самом деле быть работой с устройством или IPC? Объясните идею унификации. ⭐⭐**:

Идея унификации заключается в использовании единого интерфейса системных вызовов (`read`, `write`, `open`, `close`) для доступа к разнородным объектам. Это делает ввод-вывод независимым от типа устройства.

**Пример:** Команда `write(fd, buffer, nbytes)` может:

1. Записывать данные в **обычный файл** на SSD.
2. Отправлять текст на **принтер** (через специальный файл устройства `/dev/lp`).
3. Передавать данные другому процессу через **канал (pipe)**.

Программе не нужно знать специфику оборудования; для неё всё выглядит как именованная последовательность байтов.

---

#### **Какие последствия для дизайна ОС возникают из того, что процесс и файл — ключевые универсальные абстракции почти во всех ОС? ⭐⭐⭐**:

Использование процесса как универсального «контейнера выполнения» и файла как «контейнера данных» приводит к следующим следствиям в дизайне:

- **Единообразие интерфейсов**: Почти всё в системе (включая устройства и сетевые сокеты) можно представить как файлы. Это упрощает API.
- **Иерархическая структура**: Процессы образуют дерево (родитель-потомок), а файлы — древовидную файловую систему. Это облегчает управление правами и ресурсами.
- **Механизмы защиты**: Безопасность строится вокруг владения процессом (UID/GID) и доступа к файлам (rwx-биты).
- **Взаимозаменяемость**: Модель «программы-фильтры», соединенные каналами (pipes), позволяет строить сложные системы из простых инструментов.

---

#### **Что именно хранит ОС о процессе в «таблице процессов», и зачем там нужны значения регистров и позиции в файлах? ⭐⭐**:

Таблица процессов — это массив структур (Process Control Block), где хранится вся информация, необходимая для возобновления работы приостановленного процесса.

- **Регистры (PC, SP, PSW и др.)**: Когда ОС переключает контекст, она сохраняет значения регистров текущего процесса в таблицу. Без этого при возвращении к процессу он бы «потерял мысль» и не смог продолжить вычисления.
- **Позиции в файлах (File descriptors)**: Если процесс читал большой файл и был приостановлен, ОС должна помнить, на каком байте он остановился, чтобы следующий вызов `read` вернул правильные данные.

---

#### **Какие ресурсы (кроме памяти) обычно «прикреплены» к процессу, и что должно случиться с ними при завершении процесса? ⭐⭐**:

Помимо памяти (адресного пространства), к процессу привязаны:

1. **Файловые дескрипторы** (открытые файлы, сокеты, каналы).
2. **Таймеры и сигналы** (ожидающие уведомления).
3. **Дочерние процессы** (связи в иерархии).
4. **Блокировки (locks)** на файлы или ресурсы.

При завершении процесса ОС обязана выполнить **очистку**: закрыть все дескрипторы, освободить память, аннулировать таймеры. Это необходимо для предотвращения утечек ресурсов, которые могли бы парализовать систему.

---

#### **Опишите, что должно произойти при приостановке и последующем возобновлении процесса, чтобы программа «ничего не заметила». ⭐⭐**:

Этот процесс называется **переключением контекста (context switch)**.

1. **При приостановке**:
    - Процессор переходит в режим ядра.
    - Текущие значения всех регистров (включая PC и SP) сохраняются в записи таблицы процессов данного процесса.
    - Состояние процесса меняется с «выполняется» на «готов» или «спит».
2. **При возобновлении**:
    - ОС выбирает процесс из очереди готовых.
    - Из таблицы процессов восстанавливаются значения регистров.
    - Процессор переключается обратно в пользовательский режим.
    - Выполнение начинается ровно с той инструкции, на которой процесс был прерван.

---

#### **Как вы объясните различие между состоянием «спит», «выполняется», «остановлен», «зомби» с точки зрения ОС и родителя процесса? ⭐⭐**:

| Состояние          | Описание для ОС                                                               | Вид для родителя                                             |
| :----------------- | :---------------------------------------------------------------------------- | :----------------------------------------------------------- |
| **Выполняется**    | Процесс использует CPU в данный момент.                                       | Активный процесс.                                            |
| **Спит (Blocked)** | Ждет внешнего события (ввода с диска, сигнала). Не претендует на CPU.         | Активный, но временно «зависший».                            |
| **Остановлен**     | Приостановлен пользователем (например, Ctrl+Z). Ждет сигнала для продолжения. | Не выполняет работу.                                         |
| **Зомби**          | Завершился, освободил память, но запись в таблице процессов осталась.         | Ждет, пока родитель прочитает код его выхода (вызов `wait`). |

---

#### **Почему процессы часто называют «контейнерами выполнения», и в каком смысле это похоже/не похоже на контейнеры уровня Docker? ⭐⭐⭐**:

Процесс — это «контейнер», потому что он объединяет все необходимое для работы программы: память, права доступа и ресурсы.

- **Сходство с Docker**: Оба механизма обеспечивают изоляцию. Процесс изолирован по памяти и дескрипторам.
- **Различие**: Обычный процесс в одной ОС делит с другими процессами общую файловую систему и дерево устройств. Контейнер Docker использует механизмы ОС (namespaces, cgroups) для более глубокой изоляции: у него «свой» корень файловой системы, «свои» пользователи и сетевой стек, хотя он по-прежнему работает на ядре хоста.

---

#### **Какие выводы о системе можно сделать по списку процессов `ps aux`: что искать в USER/PID/STAT/COMMAND? ⭐**:

- **USER**: Кто владеет процессом (например, `root` указывает на системные службы).
- **PID**: Уникальный идентификатор (PID 1 — обычно `init` или `systemd`, корень дерева).
- **STAT**: Текущее состояние. `R` — работает, `S` — спит, `Z` — зомби. Дополнительные символы (например, `<`) могут указывать на приоритет.
- **COMMAND**: Строка запуска. Помогает понять назначение процесса (например, `nginx` — веб-сервер).

---

#### **Чем отличаются VSZ/VIRT и RSS/RES, и почему «много VIRT» не всегда означает «проблема с памятью»? ⭐⭐**:

- **VIRT (VSZ)**: Общий объем **виртуальной памяти**, которую процесс «застолбил». Сюда входят все подключенные библиотеки, отображенные файлы и неиспользуемые области.
- **RES (RSS)**: **Реальный объем** физической памяти (ОЗУ), который процесс занимает прямо сейчас.

**Почему «много VIRT» — не всегда плохо?** Процесс может отобразить в память файл размером 10 ГБ (mmap), и его VIRT вырастет до 10 ГБ, но реально в ОЗУ (RES) будут загружены только те 4 КБ, которые читаются в данный момент.

---

#### **Как интерпретировать %CPU в `top` на многоядерной машине: когда 100% — это «всё» и когда — «одно ядро»? ⭐⭐**:

В большинстве UNIX-систем (Linux) значение `%CPU` в `top` рассчитывается **на одно ядро**.

- Если у вас 4 ядра, то общая мощность системы составляет **400%**.
- Если процесс показывает **100%**, это означает, что он полностью загрузил **одно ядро**.
- Если процесс показывает **0.1%**, он почти не использует процессор.

---

#### **Что означает load average, и почему он может быть высоким даже при низком %CPU? ⭐⭐⭐**:

**Load average** — это среднее количество процессов, которые находятся в состоянии выполнения (Runnable) или ожидают ввода-вывода (Uninterruptible sleep).

**Почему он высокий при низком %CPU?** Это происходит, когда процессы «застряли» в ожидании диска или сети. CPU при этом простаивает (низкий `%CPU`), но очередь заданий растет, так как процессы не могут продолжить работу, пока медленное устройство не отдаст данные.

---

#### **Как бы вы нашли «подозрительный» процесс, который редко использует CPU, но постоянно держит диск занятым? Какие поля/инструменты помогут? ⭐⭐⭐**:

Использования только `top` может быть недостаточно, так как он сфокусирован на CPU.

1. **Инструменты**: `htop` (позволяет видеть колонки ввода-вывода) или специализированный `iotop`.
2. **Признаки**: В `top` искать процессы в состоянии `D` (Uninterruptible sleep) — это часто означает ожидание диска. Также стоит смотреть на колонку `wa` (%Cpu(s): ... wa) — время ожидания ввода-вывода.
3. **Поля**: В `htop` можно добавить колонки `RD_BYTE` и `WR_BYTE`, чтобы увидеть реальную скорость чтения/записи процесса.

---

#### **Почему в UNIX-подобных системах естественно возникает дерево процессов? Что даёт модель «родитель–ребёнок»? ⭐⭐**:

В UNIX новые процессы создаются только путем клонирования существующих (вызов `fork`). Поскольку у каждого клона (ребенка) есть четкий создатель (родитель), автоматически выстраивается иерархия.

**Преимущества модели:**

- **Управление**: Родитель может ждать завершения ребенка и получать его статус.
- **Наследование**: Ребенок получает копию открытых файлов родителя.
- **Группировка**: Сигналы (например, Ctrl+C) можно посылать всей группе процессов-потомков сразу.
- **Инициализация**: Все процессы в итоге восходят к PID 1 (`init`), который запускает все службы системы.

---

#### **Сравните: IPC через каналы (pipes), через файлы и через сокеты — в чём различие по модели использования и по стоимости? ⭐⭐⭐**:

|Механизм|Модель использования|Стоимость/Особенности|
|:--|:--|:--|
|**Файлы**|Асинхронная, данные сохраняются.|**Дорого**: медленная работа с диском.|
|**Каналы (Pipes)**|Потоковая, строго между родственниками.|**Дешево**: данные передаются через буфер в ядре без диска.|
|**Сокеты**|Двусторонняя, сетевая или локальная.|**Средне**: универсально, поддерживает связь между разными ПК.|

---

#### **Что такое сигнал: чем он принципиально отличается от «сообщения» IPC, и почему его сравнивают с прерываниями? ⭐⭐**:

**Сигнал** — это программный аналог аппаратного прерывания. Это уведомление процесса о событии, которое заставляет его временно прервать текущую работу и запустить обработчик.

**Отличия от сообщения IPC:**

1. **Асинхронность**: Сигнал может прийти в любой момент, его нельзя «прочитать» из очереди по желанию.
2. **Отсутствие данных**: Сигнал — это просто номер (например, SIGTERM). Он не несет в себе сложной структуры данных (сообщения).
3. **Прерывание потока**: Сигнал заставляет CPU «прыгнуть» на адрес обработчика, сохраняя текущий контекст на стеке.

---

#### **Придумайте сценарий, где сигнал — хороший механизм (например, таймер/ошибка), и сценарий, где сигнал — плохой выбор и лучше IPC. ⭐⭐⭐**:

- **Хороший сценарий**: **Таймер (SIGALRM)**. Процесс запрашивает уведомление через 5 секунд, продолжает работу, и ОС «стучит ему в дверь» сигналом, когда время вышло. Или **SIGFPE** при делении на ноль — немедленное прерывание ошибочного кода.
- **Плохой сценарий**: **Передача базы данных** из 1000 записей. Сигналы не могут нести данные. Здесь лучше использовать **каналы (pipes)** или **общую память**, так как они позволяют передавать большие объемы структурированной информации.

---

#### **Что может пойти не так, если процесс «не готов» принимать сигнал (нет обработчика) — почему это иногда полезно, а иногда опасно? ⭐⭐**:

Если для сигнала не определен пользовательский обработчик, выполняется **действие по умолчанию**.

- **Полезно**: Для фатальных ошибок (SIGSEGV) или принудительного завершения (SIGKILL). Это гарантирует, что зависший или сломанный процесс можно убить.
- **Опасно**: Для сигналов вроде SIGTERM. Если процесс (например, база данных) не готов (нет обработчика), он будет немедленно убит системой, не успев сохранить данные на диск или закрыть транзакции, что приведет к порче файлов.