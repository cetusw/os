#### **Сравните ключевые цели планирования для batch, interactive и real-time систем. Почему одна и та же метрика не подходит всем? ⭐⭐**:

Для разных типов операционных систем приоритетными являются разные показатели эффективности планирования.

- **Пакетные системы (Batch):** Основными целями здесь являются максимизация пропускной способности (**throughput**) — количества задач, выполненных за час, и минимизация времени оборота (**turnaround time**) — времени между запуском и завершением задачи. Также важно поддерживать высокую загрузку процессора (**CPU utilization**).
- **Интерактивные системы (Interactive):** Здесь на первый план выходит время отклика (**response time**) на действия пользователя и **пропорциональность** — выполнение задач в соответствии с ожиданиями (например, открытие папки должно быть быстрее загрузки видео).
- **Системы реального времени (Real-time):** Ключевой целью является строгое соблюдение временных ограничений (**meeting deadlines**) и предсказуемость (**predictability**) — стабильность выполнения задач во времени.

Одна и та же метрика не подходит всем, так как условия эксплуатации систем радикально различаются. Например, в пакетной системе допустимы задержки в несколько минут ради общей эффективности, тогда как в интерактивной системе это сделает работу пользователя невозможной, а в системе реального времени может привести к катастрофе.

---

#### **Что такое fairness в планировании? Как «справедливость» может конфликтовать с производительностью или политикой приоритетов? ⭐⭐⭐**:

**Fairness (Справедливость)** в планировании означает предоставление каждому процессу или пользователю равной доли ресурсов процессора или шанса на выполнение.

**Конфликты:**

- **С производительностью:** Строгая справедливость требует частого переключения контекста, что создает высокие накладные расходы на сохранение регистров, сброс кэшей и таблиц MMU, снижая общую полезную мощность системы.
- **С политикой приоритетов:** Политика приоритетов намеренно нарушает справедливость, отдавая предпочтение критически важным задачам перед второстепенными. Если планировщик будет «слишком справедлив» к фоновому процессу, высокоприоритетная задача (например, управление двигателем или интерфейс пользователя) может не выполниться вовремя.

---

#### **Объясните разницу между throughput и turnaround time. Почему максимизация throughput может ухудшать turnaround? ⭐⭐**:

- **Throughput (Пропускная способность):** Это количество задач, которые система успевает полностью завершить за единицу времени (например, за час).
- **Turnaround time (Время оборота):** Это полный интервал времени от момента отправки задания в систему до момента получения готового результата.

**Максимизация throughput** часто достигается за счет выполнения множества коротких задач или объединения похожих задач для минимизации переключений контекста. В этом сценарии одна большая и сложная задача может постоянно откладываться в очереди, что приведет к катастрофическому росту её индивидуального **turnaround time**.

---

#### **Почему CPU utilization — спорная метрика качества планирования в batch-системах? Когда она всё же полезна? ⭐⭐**:

**CPU utilization** (загрузка процессора) считается спорной метрикой, потому что она показывает лишь то, что процессор не простаивает, но не гарантирует, что выполняется полезная работа пользователя. Процессор может быть загружен на 100% из-за неэффективных алгоритмов или частых переключений контекста планировщиком (system time), при этом количество завершенных задач может быть низким.

Она **полезна** в случаях, когда оборудование крайне дорогостоящее (например, мейнфреймы), и необходимо гарантировать, что ресурс, за который заплачены миллионы долларов, не тратится впустую во время ожидания ввода-вывода.

---

#### **Что такое response time в интерактивных системах и почему «пропорциональность ожиданиям пользователя» важна как отдельная цель? ⭐⭐**:

**Response time (Время отклика)** — это время от момента нажатия клавиши или клика мышью до появления первой реакции системы на экране.

**Пропорциональность** важна, так как у пользователей есть психологические ожидания сложности задач. Пользователь готов ждать загрузки тяжелой игры несколько минут, но если простое нажатие кнопки в меню будет обрабатываться более секунды, это вызовет раздражение и ощущение «зависания» системы. Планировщик должен учитывать этот контекст, чтобы поддерживать удовлетворенность пользователя.

---

#### **Почему в real-time системах «правильный ответ слишком поздно» может быть эквивалентен ошибке? Приведите примеры. ⭐⭐**:

В системах реального времени время является критическим параметром корректности. Если результат вычислений получен после наступления дедлайна, он становится бесполезным или опасным.

**Примеры:**

- **Робототехника:** Если сварочный робот на конвейере получит команду на сварку на 100 мс позже, чем нужно, он прожжет деталь в пустом месте, и машина будет испорчена.
- **Авиация:** Если система управления автопилотом рассчитает траекторию выхода из пике с опозданием, самолет может столкнуться с землей до того, как команда будет исполнена.

---

#### **Чем отличается predictability от просто «высокой скорости» в real-time/мультимедиа? Почему jitter критичен? ⭐⭐⭐**:

**Скорость** — это среднее время выполнения задачи, тогда как **предсказуемость (predictability)** — это гарантия того, что задача будет выполнена точно в заданный интервал времени.

**Jitter (Джиттер)** — это вариация времени отклика или задержки выполнения. Он критичен для мультимедиа, так как даже при очень высокой средней скорости обработки кадров, неравномерность (один кадр обработан за 1 мс, а следующий за 100 мс) приведет к заметным рывкам в видео или провалам в звуке. Для человеческого уха и глаза важен именно ритм (отсутствие джиттера), а не пиковая скорость.

---

#### **Опишите алгоритм FCFS и объясните, почему его называют «справедливым», но при этом он может давать плохую среднюю производительность. ⭐⭐**:

**FCFS (First-Come, First-Served)** — это простейший невытесняющий алгоритм, при котором процессы выполняются строго в порядке их поступления в очередь.

Он считается **«справедливым»** по аналогии с очередью в магазине: кто первый пришел, того первого и обслужили. Однако его **средняя производительность низка**, так как короткие задачи могут часами ждать в очереди за одной очень длинной задачей, что резко увеличивает среднее время ожидания и оборота для всех процессов в системе.

---

#### **Что такое «эффект конвоя» в FCFS? Опишите сценарий с CPU-bound и множеством I/O-bound процессов и последствия для времени завершения. ⭐⭐⭐**:

**Эффект конвоя** — это ситуация в алгоритме FCFS, когда один медленный процесс задерживает за собой множество быстрых.

**Сценарий:**

1. Один **CPU-bound** процесс (длительные вычисления) занимает процессор.
2. Множество **I/O-bound** процессов быстро завершают свои короткие операции ввода-вывода и встают в очередь за CPU-bound процессором.
3. Они ждут долгое время, пока вычислительный процесс не завершит свой квант или не заблокируется сам.
4. Когда I/O-bound процессы наконец получают CPU, они мгновенно выполняют свои короткие расчеты и снова уходят на I/O, оставляя процессор простаивать, пока медленный CPU-bound процесс опять не встанет в очередь.

**Последствие:** Ресурсы (CPU и устройства ввода-вывода) используются крайне неэффективно, а время завершения всех задач значительно увеличивается.

---

#### **Объясните идею SJF (Shortest Job First) и почему он минимизирует среднее turnaround time при известной длительности задач. ⭐⭐**:

Идея **SJF** заключается в том, чтобы выбирать из очереди готовых задач ту, которая имеет **наименьшее время выполнения**.

Это минимизирует среднее время оборота, так как быстрое завершение коротких задач позволяет им немедленно покинуть очередь, не заставляя ждать других. Математически доказано, что если вы сначала выполните задачи длительностью 4, 4, 4, а затем 8, среднее время оборота составит 11 мс, в то время как при порядке 8, 4, 4, 4 оно составило бы 14 мс.

---

#### **В каких условиях SJF является оптимальным, а в каких — нет? Приведите контрпример с разными временами прихода задач. ⭐⭐⭐**:

SJF является оптимальным только в условиях, когда **все задачи доступны одновременно** в начале работы планировщика.

**Контрпример:**

- Задача A (длительность 8) приходит в момент $T=0$.
- Задача B (длительность 4) приходит в момент $T=2$.
- Невытесняющий SJF начнет выполнять задачу A в момент 0. Даже когда в момент 2 придет более короткая задача B, планировщик не сможет прервать A. В итоге B будет ждать до $T=8$.
- Среднее время оборота будет хуже, чем если бы мы имели возможность вытеснения.

---

#### **Чем SRTN (Shortest Remaining Time Next) отличается от SJF и почему вытеснение помогает «коротким» задачам? ⭐⭐**:

**SRTN** — это **вытесняющая (preemptive)** версия SJF. При поступлении новой задачи планировщик сравнивает её время выполнения с **оставшимся** временем текущей задачи.

**Вытеснение помогает**, так как оно позволяет новой короткой задаче получить процессор немедленно, не дожидаясь окончания долгой задачи, которая случайно запустилась на секунду раньше. Это существенно снижает время отклика и ожидания для коротких процессов.

---

#### **Какие практические проблемы возникают при попытке применить SJF/SRTN в реальных ОС (оценка времени, ошибки прогнозов, starvation)? ⭐⭐⭐**:

1. **Оценка времени:** В реальной жизни ОС не знает заранее, сколько времени проработает произвольная программа.
2. **Ошибки прогнозов:** Системе приходится использовать эвристики (например, экспоненциальное сглаживание на основе прошлых запусков), и если прогноз неверен, это может привести к лишним переключениям контекста.
3. **Starvation (Голодание):** Длинные задачи могут вообще никогда не запуститься, если в систему постоянно поступает поток новых коротких задач, которые планировщик всегда будет ставить в начало очереди.