#### **Какую проблему выбора «spinlock vs блокировка через ядро» решает futex? ⭐⭐**:

Эта дилемма заключается в том, что **spinlock (активное ожидание)** эффективен только при очень коротком времени ожидания, но бесполезно тратит ресурсы CPU при длительных задержках. С другой стороны, **блокировка через ядро** эффективна при высокой конкуренции, но системные вызовы стоят «дорого» даже в тех случаях, когда ресурс свободен. **Futex** решает эту проблему, предлагая гибридный механизм: он работает полностью в пользовательском пространстве, пока нет конфликтов, и вовлекает ядро только при реальной конкуренции за ресурс.

---

#### **Объясните, что означает «в отсутствии конкуренции ядро не вовлекается вообще». За счёт чего это достигается? ⭐⭐⭐**:

Это означает, что захват и освобождение блокировки происходят без выполнения дорогостоящих **системных вызовов** и переключения контекста в режим ядра. Это достигается за счёт того, что потоки делят между собой **общую переменную** (целое число в разделяемой памяти). Поток пытается захватить ресурс с помощью быстрой **атомарной инструкции** (например, декремент и проверка): если результат показывает, что ресурс был свободен, поток просто продолжает работу в user space.

---

#### **Опишите жизненный цикл захвата futex: атомарная попытка → системный вызов → очередь ожидания → пробуждение. ⭐⭐⭐**:

Жизненный цикл захвата блокировки выглядит следующим образом:

1. **Атомарная попытка:** Поток выполняет атомарную операцию над переменной futex в пользовательском пространстве.
2. **Системный вызов:** Если проверка показывает, что ресурс уже занят другим потоком, текущий поток выполняет системный вызов, передавая управление ядру.
3. **Очередь ожидания:** Ядро ОС приостанавливает поток и помещает его в специальную **очередь ожидания (wait queue)**.
4. **Пробуждение:** Когда владелец освобождает ресурс, он выполняет атомарную операцию в user space и, если обнаруживает наличие ожидающих, делает системный вызов, чтобы ядро разбудило один или несколько потоков из очереди.

---

#### **Почему futex редко используется напрямую прикладным программистом, но часто встречается «под капотом»? ⭐⭐**:

Futex является очень низкоуровневым и сложным в правильной реализации механизмом. Ошибки в работе с ним могут привести к трудноуловимым дедлокам или состояниям гонки. Поэтому он служит **фундаментальным строительным блоком**, на котором профессиональные разработчики системных библиотек строят более удобные и безопасные абстракции, такие как `pthread_mutex`, `std::mutex` и условные переменные.

---

#### **Какие ошибки могут возникнуть при неправильном использовании futex (например, потерянные пробуждения, ABA-сценарии, неверные ожидания)? ⭐⭐⭐**:

Основной риск при использовании примитивов типа sleep/wakeup (на которых основан futex) — это **потеря сигнала пробуждения**. Если сигнал `wakeup` отправлен до того, как поток фактически уснул, сигнал исчезает, и поток может остаться в состоянии ожидания навсегда. Также возможны проблемы с логикой ожидания, если состояние переменной изменилось в промежутке между проверкой условия в user space и фактической блокировкой в ядре.

---

#### **Какие гарантии даёт pthread_mutex_lock и что он НЕ гарантирует (например, порядок пробуждений/справедливость)? ⭐⭐**:

`pthread_mutex_lock` гарантирует **взаимное исключение**: только один поток может находиться в критической секции одновременно, защищая данные от гонок. Однако стандартные мьютексы обычно **не гарантируют строгий порядок** пробуждения потоков (справедливость/fairness). Поток, который дольше всех ждал блокировку, не обязательно получит её первым после освобождения; это зависит от планировщика ОС и реализации библиотеки.

---

#### **Почему условные переменные всегда используются вместе с мьютексом? ⭐⭐**:

Это необходимо для предотвращения **состояний гонки**. Мьютекс защищает общее состояние данных (например, флаг или размер очереди), которое проверяется перед тем, как поток решит уснуть на условной переменной. Без мьютекса другой поток мог бы изменить условие и отправить сигнал `notify` именно в тот момент, когда первый поток уже проверил условие, но ещё не успел войти в режим ожидания, что привело бы к потере сигнала.

---

#### **Что означает фраза «условные переменные не накапливают сигналы» и чем это отличается от семафоров? ⭐⭐⭐**:

Это означает, что условная переменная **не имеет «памяти»** о прошедших событиях: если вы вызываете `notify`, а в этот момент никто не вызвал `wait`, сигнал просто **теряется**. **Семафоры**, напротив, хранят историю сигналов в виде счётчика: если вызвать `up()` (signal) раньше, чем `down()` (wait), семафор запомнит это увеличение, и следующий поток пройдёт через него без блокировки.

---

#### **Объясните, почему pthread_cond_wait(&cond, &mutex) атомарно «отпускает мьютекс и засыпает». Почему это важно? ⭐⭐⭐**:

Атомарность этой операции критична для надежности. Поток должен **одновременно** освободить мьютекс, чтобы другие могли изменить данные, и встать в очередь ожидания сигнала. Если бы эти действия были раздельными, возникло бы «окно» времени, в котором поток уже отпустил мьютекс, но ещё не начал ждать. Если в это окно пришёл сигнал `notify`, поток его пропустит и уснёт навсегда.

---

#### **В producer/consumer примере почему проверка условия должна быть в while, а не if? Назовите минимум две причины. ⭐⭐**:

Использование `while` обязательно по следующим причинам:

1. **Ложные пробуждения (spurious wakeups):** Потоки могут просыпаться без явного сигнала от системы.
2. **Конкуренция:** К моменту, когда поток проснулся и снова захватил мьютекс, другой «быстрый» поток-потребитель уже мог забрать элемент из очереди, сделав условие снова ложным.

---

#### **Чем отличаются std::lock_guard и std::unique_lock? Почему wait() требует именно unique_lock? ⭐⭐**:

- `std::lock_guard` — это максимально легкая RAII-обёртка, которая захватывает мьютекс в конструкторе и отпускает в деструкторе без возможности ручного управления.
- `std::unique_lock` более гибкий: он позволяет явно вызывать `unlock()` и `lock()` в процессе жизни объекта. Функция `wait()` требует именно **`unique_lock`**, потому что внутри себя она должна иметь возможность **временно разблокировать** мьютекс на время сна и заблокировать его обратно после пробуждения.

---

#### **Что такое spurious wakeup и почему он возможен даже при корректной логике notify? ⭐⭐⭐**:

**Spurious wakeup (ложное пробуждение)** — это ситуация, когда поток выходит из состояния `wait()`, хотя никакого сигнала `notify` не посылалось. Это архитектурная особенность многопоточных систем, связанная с тем, как ОС и процессоры обрабатывают прерывания и сигналы на низком уровне. Поскольку гарантировать отсутствие таких пробуждений слишком «дорого» для производительности системы, программистам предписано всегда проверять условие в цикле.

---

#### **В чём разница между cv.wait(lock) и cv.wait(lock, predicate) с точки зрения безопасности и читаемости? ⭐⭐**:

- `cv.wait(lock)` требует от программиста вручную написать цикл `while` вокруг вызова для защиты от ложных пробуждений.
- `cv.wait(lock, predicate)` принимает лямбда-выражение (предикат) и **автоматически** выполняет проверку в цикле. Это делает код более **читаемым** (условие ожидания описано прямо в вызове) и **безопасным**, так как исключает риск забыть цикл `while`.

---

#### **Какую типичную ошибку делают при использовании notify_one()/notify_all() (например, уведомление без изменения состояния)? ⭐⭐**:

Типичная ошибка — вызывать уведомление **без фактического изменения** данных, которые проверяет ожидающий поток. Если вызвать `notify`, но не изменить переменную-флаг, проснувшийся поток снова увидит ложное условие в своем цикле `while` и немедленно вернётся в режим сна. Это приводит к лишним переключениям контекста и снижению производительности.

---

#### **Опишите корректный дизайн очереди producer-consumer на C++: где хранится условие, где мьютекс, где уведомление, что защищаем. ⭐⭐⭐**:

Корректный дизайн включает:

1. **Общие данные:** Сама структура данных (например, `std::deque` или буфер), в которой хранятся элементы.
2. **Мьютекс (`std::mutex`):** Защищает доступ к этой структуре данных и к переменным состояния.
3. **Условная переменная (`std::condition_variable`):** Используется для уведомления о том, что очередь перестала быть пустой (для потребителей) или перестала быть полной (для производителей).
4. **Логика:** Поток захватывает мьютекс через `unique_lock`, вызывает `wait` с предикатом (проверка размера очереди), выполняет операцию (push/pop), а затем вызывает `notify_one()` или `notify_all()` **после** изменения состояния.