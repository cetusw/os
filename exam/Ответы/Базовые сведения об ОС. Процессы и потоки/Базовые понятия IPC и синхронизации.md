#### **Чем принципиально отличаются синхронизация и коммуникация между процессами/потоками? Приведите примеры. ⭐⭐**:

Несмотря на тесную связь, эти понятия решают разные задачи межпроцессного взаимодействия (IPC):

1. **Коммуникация (Передача информации):** Это сам процесс обмена данными между субъектами исполнения. Один процесс должен передать информацию другому (например, видеоплеер передаёт декодированные кадры отрисовщику).
2. **Синхронизация (Координация):** Это управление временем и порядком выполнения операций для обеспечения корректности. Она нужна, чтобы процессы не мешали друг другу при доступе к общим ресурсам или соблюдали строгую последовательность шагов.

**Примеры:**

- **Только коммуникация:** Запись логов в файл несколькими независимыми процессами (если порядок не критичен, они просто «говорят» диску, что записать).
- **Только синхронизация:** Использование **барьера**. Потоки просто ждут друг друга на определённом этапе, не обмениваясь никакими новыми данными, кроме самого факта прибытия.
- **Обе вместе:** Задача **производителя-потребителя**. Производитель передаёт данные (коммуникация), но они должны синхронизироваться, чтобы потребитель не читал из пустого буфера, а производитель не писал в полный.

---

#### **Почему общая память «упрощает обмен данными», но одновременно «усложняет синхронизацию»? Разберите на примере инварианта. ⭐⭐**:

Общая память позволяет потокам обмениваться данными мгновенно, просто читая и записывая одни и те же переменные без копирования в ядро или другие буферы. Однако это лишает систему естественной изоляции.

**Пример инварианта (банковский перевод):** Инвариант: Сумма денег на двух счетах должна быть постоянной ($A + B = Const$).

1. Поток 1 начинает перевод 100$ от $A$ к $B$. Он считывает баланс $A$.
2. В этот момент планировщик переключает контекст на Поток 2, который хочет проверить общий баланс ($A + B$).
3. Поскольку Поток 1 ещё не успел обновить счета, Поток 2 видит корректную сумму.
4. Но если Поток 1 успел вычесть 100$ из $A$, но ещё не прибавил их к $B$, то Поток 2 увидит «пропажу» 100$. Инвариант временно нарушен. Без **взаимного исключения** (синхронизации) другой поток может прочитать или даже изменить эти «неконсистентные» данные.

---

#### **Дайте определения: race condition, data race, atomicity violation. Чем они отличаются? ⭐⭐⭐**:

- **Race condition (Состояние гонки):** Логическая ошибка, при которой результат работы системы зависит от непредсказуемого порядка выполнения инструкций процессами. _Симптом:_ программа иногда работает правильно, а иногда — нет (например, один файл в спулере печати перезаписывает другой).
- **Data race (Гонка данных):** Специфический случай на низком уровне, когда два потока одновременно обращаются к одной ячейке памяти, и при этом хотя бы один из них выполняет запись, и нет никакой синхронизации.
- **Atomicity violation (Нарушение атомарности):** Ситуация, когда блок кода, который должен был выполниться как единая неделимая операция («всё или ничего»), прерывается другим потоком, что приводит к некорректному состоянию данных.

**Отличие:** Data race — это ошибка работы с памятью; Race condition — это ошибка логики/порядка событий; Atomicity violation — это ошибка целостности сложной операции.

---

#### **Что такое критическая секция? Какие свойства кода делают участок «критическим»? ⭐**:

**Критическая секция** — это участок программы, в котором выполняется доступ к разделяемым (общим) ресурсам. Свойства, делающие участок критическим:

1. **Доступ к общей памяти** (чтение/запись глобальных переменных, кучи).
2. **Работа с разделяемыми файлами** или внешними устройствами.
3. Выполнение действий, которые могут привести к **состояниям гонки**, если их прервать. _Ключевой принцип:_ в критической секции одновременно может находиться не более одного процесса.

---

#### **Какие 4 условия корректного решения задачи критической секции вы считаете ключевыми? ⭐⭐**:

Для реализации **взаимного исключения** (mutual exclusion) должны соблюдаться следующие условия:

1. **Никакие два процесса не могут находиться внутри своих критических секций одновременно.** (Обеспечивает безопасность данных).
2. **Нельзя делать предположений о скоростях или количестве процессоров.** (Обеспечивает переносимость и независимость от железа).
3. **Процесс, находящийся вне критической секции, не должен блокировать другие процессы.** (Предотвращает ложные блокировки).
4. **Ни один процесс не должен ждать входа в критическую секцию вечно.** (Предотвращает голодание/starvation).

---

#### **Почему пример с counter++/counter-- может дать случайный результат? Опишите интерливинги. ⭐⭐**:

На языке C++ код выглядит симметрично, но на уровне процессора (x86-64) операции `++counter` и `--counter` не являются атомарными. Каждая состоит из трёх шагов:

1. Чтение значения из памяти в регистр.
2. Инкремент/декремент значения в регистре.
3. Запись значения из регистра обратно в память.

**Межпоточный интерливинг (пример):** Пусть `counter = 0`.

- **T1 (Thread 1):** Считывает `0` в свой регистр `RAX1`.
- **T2 (Thread 2):** Считывает `0` в свой регистр `RAX2`.
- **T1:** Увеличивает `RAX1` до `1`.
- **T2:** Уменьшает `RAX2` до `-1`.
- **T1:** Записывает `1` в память. (`counter = 1`)
- **T2:** Записывает `-1` в память, **затирая** результат работы T1. (`counter = -1`). В итоге вместо ожидаемого `0` мы получаем случайное число, зависящее от того, какой поток «успел» записать данные последним.

---

#### **Объясните, как исправить проблему в коде выше. ⭐⭐**:

Проблему можно исправить, используя **атомарные операции**. В C++ для этого следует заменить тип переменной `int` на `std::atomic<int>`. Это гарантирует, что операции инкремента и декремента будут выполняться как **неделимые инструкции** на уровне процессора (используя префикс `lock` в x86). Никакой другой поток не сможет «вклиниться» между чтением и записью значения.

---

#### **Что означает префикс lock в x86-инструкциях? Как это связано с когерентностью кэша? ⭐⭐⭐**:

Префикс `lock` перед инструкцией (например, `lock add`) заставляет процессор выполнить операцию атомарно.

1. **Атомарность:** Гарантирует цикл «чтение-модификация-запись» как одну операцию.
2. **Связь с кэшем:** В современных процессорах `lock` активирует протоколы когерентности кэша. Он либо блокирует системную шину (в старых CPU), либо (в современных) монопольно захватывает кэш-линию, содержащую переменную. Это гарантирует, что ни одно другое ядро процессора не сможет прочитать или изменить эту память, пока инструкция не завершится.

---

#### **Почему volatile не является механизмом синхронизации в C++? ⭐⭐⭐**:

В C++ ключевое слово `volatile` имеет очень узкое значение: оно запрещает компилятору оптимизировать обращения к переменной (например, кешировать её в регистре или удалять «ненужные» с точки зрения компилятора записи). **Оно не спасает от гонки, потому что:**

- Не обеспечивает **атомарности**: `volatile int x; ++x;` всё ещё превращается в три неатомарные инструкции (чтение, изменение, запись).
- Не создает **барьеров памяти**: процессор всё ещё может переупорядочивать инструкции (out-of-order execution), что сломает логику синхронизации в многопоточной среде.

---

#### **Объясните смысл acquire/release на примере. Что такое happens-before? ⭐⭐⭐**:

Это модель памяти, используемая для эффективной синхронизации без тяжелых блокировок (мьютексов).

**Пример «данные + флаг готовности»:**

1. **Писатель:** Сначала записывает «тяжелые» данные в обычную память, а затем устанавливает флаг `ready` с семантикой **release**. `store(ready, 1, memory_order_release)`.
2. **Читатель:** В цикле проверяет флаг с семантикой **acquire**. `load(ready, memory_order_acquire)`.

**Смысл:**

- **Release** гарантирует, что все записи в память, сделанные _до_ него (наши данные), будут завершены и видны другим.
- **Acquire** гарантирует, что все последующие чтения из памяти (чтение данных) увидят значения, актуальные на момент release.

**Happens-before (произошло до):** Это логическое отношение порядка. Если событие А _happens-before_ Б, то все изменения памяти, сделанные в А, гарантированно видны в Б. Связка release-acquire создает это отношение между потоками.