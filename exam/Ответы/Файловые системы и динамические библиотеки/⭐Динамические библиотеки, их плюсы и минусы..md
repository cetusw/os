#### **Объясните, что означает фраза: “программа содержит не сами функции из библиотеки, а только ссылки на них”. ⭐⭐**

Это означает, что при сборке программы (линковке) машинный код библиотечных функций не копируется в результирующий `.exe` или `elf` файл. Вместо кода там создается **запись в таблице импорта**. Эта запись содержит имя библиотеки (например, `kernel32.dll` или `libc.so`) и имя нужной функции (например, `printf`). Реальный код остается во внешнем файле на диске и будет найден операционной системой только в момент запуска или работы программы.

#### **Почему подключение динамической библиотеки переносит часть работы линковщика на время выполнения программы? ⭐⭐**

При статической линковке все адреса функций известны заранее. При динамической — адрес функции в памяти становится известен только тогда, когда библиотека загружена в адресное пространство процесса.
**Загрузчик ОС (runtime linker)** должен:
1. Найти файл библиотеки на диске.
2. Загрузить его в память.
3. Пройти по таблице импорта программы и «прошить» (разрешить) ссылки, заменив имена функций на их реальные физические адреса в памяти.

#### **Чем отличаются форматы .dll и .so не только по расширению, но и по типичным механизмам загрузки/поиска? ⭐⭐**

*   **.dll (Windows):** Часто использует механизм «импортных библиотек» (`.lib` файлов при сборке). Поиск идет в текущей папке, системных папках (System32) и путях в переменной `PATH`.
*   **.so (Unix/Linux):** Основан на формате ELF. Требует наличия кода, независимого от позиции (**PIC — Position Independent Code**). Для поиска используются переменная `LD_LIBRARY_PATH`, кэш `ldconfig` и пути, зашитые в сам бинарник (`RPATH/RUNPATH`).

#### **Как динамическая линковка влияет на распространение приложения (deployment) и требования к окружению? ⭐⭐**

*   **Deployment:** Исполняемый файл весит меньше, но приложение становится «хрупким». Вместе с ним нужно поставлять набор зависимых библиотек (дистрибутив усложняется).
*   **Окружение:** Возникает зависимость от версий библиотек в целевой ОС. Если в системе пользователя установлена более старая или несовместимая версия системной библиотеки, программа не запустится (ошибка «missing dependencies»).

#### **В каких случаях динамическая библиотека может быть подключена не при запуске, а позже? ⭐⭐**

Это называется **явной загрузкой (explicit linking)**. Программа запускается без библиотеки, а в процессе работы вызывает специальные системные функции (`LoadLibrary` в Windows или `dlopen` в Linux).
**Сценарии:**
1.  **Плагины:** Программа не знает заранее, какие расширения установит пользователь.
2.  **Экономия ресурсов:** Загрузка тяжелой библиотеки (например, для печати) только тогда, когда пользователь нажал кнопку «Печать».
3.  **Опциональная поддержка:** Программа может работать и без библиотеки, предоставляя лишь базовый функционал.

#### **Что такое “символ” в бинарном смысле и почему он важнее, чем исходный код функции? ⭐⭐**

**Символ** — это текстовое имя (строка), которое связано с определенным адресом или смещением внутри бинарного файла. Линковщику и загрузчику не нужен исходный код (C++/Rust); им нужны только таблицы символов, чтобы понять: «Функция с именем `calculate` находится по смещению 0x1234». Символ — это «крючок», за который цепляется линковщик при связывании разных файлов.

#### **Чем отличаются символы функций и символы данных с точки зрения загрузчика? ⭐⭐**

*   **Символы функций:** Указывают на исполняемый код в секции `.text`. Загрузчик просто находит адрес начала инструкций.
*   **Символы данных:** Указывают на глобальные или статические переменные в секциях `.data` или `.bss`. Это сложнее, так как загрузчик должен обеспечить, чтобы все части программы видели одну и ту же область памяти для этой переменной, а в случае записи — корректно обрабатывать права доступа.

#### **Что такое таблица импорта и какие данные она должна содержать, чтобы связывание стало возможным? ⭐⭐**

Это структура внутри исполняемого файла, описывающая его внешние зависимости.
**Состав:**
1.  Имена требуемых библиотек.
2.  Список имен функций (символов), которые нужно найти в этих библиотеках.
3.  Пустые «слоты» (адреса), куда загрузчик запишет реальные указатели после загрузки библиотек.

#### **Что такое таблица экспорта и почему она является “витриной” библиотеки? ⭐**

Это список всех функций и переменных, которые библиотека разрешает использовать внешним программам. Функции, не указанные в таблице экспорта, считаются внутренними («приватными») и недоступны для вызова извне. Это интерфейс библиотеки.

#### **Как загрузчик связывает импорт и экспорт: какие шаги он выполняет при старте процесса? ⭐⭐⭐**

1.  **Загрузка EXE:** ОС отображает файл программы в память.
2.  **Анализ зависимостей:** Читается таблица импорта, составляется список нужных библиотек.
3.  **Загрузка DLL/SO:** Библиотеки отображаются в память (если они еще не загружены другими процессами).
4.  **Разрешение символов:** Для каждого элемента в таблице импорта загрузчик ищет совпадение в таблице экспорта соответствующей библиотеки.
5.  **Binding (Связывание):** Найденный адрес функции записывается в таблицу импорта EXE-файла. Теперь вызов функции через таблицу импорта перейдет на реальный код библиотеки.

#### **Почему динамический загрузчик должен уметь разрешать зависимости библиотек друг от друга? ⭐⭐**

Потому что библиотека А сама может зависеть от библиотеки Б (транзитивные зависимости). Если загрузчик загрузит только А, программа упадет при первой же попытке А вызвать функцию из Б. Загрузчик должен построить граф зависимостей и загрузить все необходимые файлы.

#### **Что произойдёт, если импортируемый символ отсутствует в таблице экспорта найденной DLL/so? ⭐⭐**

Произойдет ошибка связывания.
*   Если это происходит при старте: ОС выдаст критическую ошибку («Точка входа в процедуру не найдена») и процесс будет завершен.
*   Если при явной загрузке (`dlsym`): функция вернет `NULL`, и программист должен сам обработать эту ситуацию.

#### **Почему динамические библиотеки позволяют экономить память, и при каких условиях эта экономия максимальна? ⭐⭐**

**Экономия:** Код библиотеки (секция `.text`) загружается в физическую RAM только **один раз**. Все процессы, использующие эту библиотеку, просто отображают эти же физические страницы в свои виртуальные адресные пространства.
**Максимальная экономия:** Когда в системе запущено много разных процессов, использующих одни и те же стандартные библиотеки (например, `libc` в Linux или `ntdll.dll` в Windows).

#### **Объясните, как несколько процессов могут использовать один и тот же код библиотеки одновременно, оставаясь изолированными. ⭐⭐⭐**

Это магия виртуальной памяти и пейджинга:
1.  **Код (Read-Only):** Страницы с кодом библиотеки помечаются как доступные только для чтения. Все процессы читают одни и те же физические кадры памяти.
2.  **Данные (Read-Write):** У каждого процесса должна быть своя копия переменных библиотеки. Используется механизм **Copy-on-Write (COW)**. Страницы данных общие до тех пор, пока процесс не попытается в них что-то записать. В момент записи ОС создает для этого процесса персональную физическую копию этой страницы.
3.  **Изоляция:** Виртуальные адреса у процессов могут быть разными, но они указывают на один физический код.

#### **Почему обновление DLL/so может “починить” программу без пересборки — и почему это же может её сломать? ⭐⭐**

*   **Починит:** Если в библиотеке была ошибка в алгоритме, исправление кода внутри функции автоматически применится ко всем программам при следующем запуске.
*   **Сломает:** Если обновление изменило **ABI** (например, порядок аргументов в функции, размер возвращаемой структуры или вообще удалило функцию). Программа будет ожидать старое поведение, а получит новое, что приведет к краху.

#### **В чём заключается “сложность настройки окружения” для динамически связанного приложения? ⭐⭐**

Нужно гарантировать, что:
1. Все нужные `.dll/.so` присутствуют на машине.
2. Они находятся в путях поиска.
3. Версии этих библиотек соответствуют тем, на которых тестировалась программа.

#### **Приведите пример ситуации, когда динамическая линковка создаёт проблему, которую статическая линковка устранила бы полностью. ⭐⭐**

**Ситуация:** Вы написали программу, использующую редкую библиотеку версии 1.2. На сервере пользователя установлена версия 2.0 той же библиотеки, которая несовместима с 1.2 (ABI изменился). Программа не запустится.
**Решение статикой:** Если бы вы вшили код версии 1.2 прямо в свою программу, она работала бы везде, независимо от того, что установлено в системе.

#### **Почему системные вызовы часто “упакованы” в библиотеки, а не вызываются приложением напрямую? ⭐⭐**

1.  **Стабильность API:** Номера прерываний ядра могут меняться от версии к версии. Библиотека (например, `glibc`) скрывает эти изменения, предоставляя стабильную функцию `open()`.
2.  **Переносимость:** Библиотека может реализовать одну и ту же функцию разными способами в зависимости от версии ядра или архитектуры процессора.
3.  **Безопасность:** Библиотека может выполнять базовые проверки аргументов перед тем, как переходить в дорогостоящий режим ядра.

#### **Как динамические библиотеки помогают модульности ОС и обновляемости компонентов? ⭐⭐**

ОС состоит из сотен модулей. Благодаря динамическим библиотекам можно обновить, например, стек протоколов TCP/IP или драйвер видеокарты, просто заменив один файл, без необходимости пересобирать и переустанавливать всё ядро или всю систему.

#### **Что такое runtime-библиотека языка и почему без неё приложение может не запуститься? ⭐⭐**

Это библиотека (например, `msvcrt.dll` для C++ или `libstdc++.so`), которая содержит «черновую» работу: запуск `main()`, выделение памяти (`malloc/new`), обработку исключений, работу с вводом-выводом. Без неё скомпилированный код просто не будет знать, как взаимодействовать с операционной системой.

#### **Почему плагины и расширения приложений почти всегда реализуются через динамическую загрузку? ⭐⭐**

Потому что это позволяет расширять возможности основной программы (браузера, фоторедактора) без доступа к её исходному коду и без её перекомпиляции. Основная программа просто ищет файлы в папке `plugins/` и загружает их по мере необходимости.

#### **Как динамические библиотеки связаны с драйверами устройств (даже если драйвер — это не всегда DLL/so)? ⭐⭐⭐**

Драйверы — это, по сути, динамические библиотеки для **ядра**. Они загружаются в память ядра по требованию (например, при подключении флешки), имеют свои таблицы экспорта (функции, которые вызывает ядро) и импорта (функции ядра, которые нужны драйверу). Они обеспечивают ту же модульность, что и DLL для пользовательских программ, позволяя ядру оставаться компактным.
