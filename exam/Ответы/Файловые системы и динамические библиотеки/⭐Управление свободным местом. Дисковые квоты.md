#### **Как работает связный список свободных блоков и почему он прост, но плохо масштабируется? ⭐⭐⭐**

**Принцип работы:** 
В этой схеме все свободные блоки диска объединяются в связный список. Сам свободный блок используется для хранения адресов других свободных блоков. 
*   В простейшем варианте первый свободный блок хранит адрес второго, второй — третьего и так далее.
*   В более эффективном варианте (как описывает Таненбаум) один свободный блок выделяется под «блок указателей». Он забивается номерами других свободных блоков «до отказа». Последний указатель в таком блоке ведет на следующий аналогичный блок с указателями.

**Почему прост:** 
Он не требует выделения отдельного непрерывного пространства на диске заранее. Сами пустые блоки «хранят себя сами».

**Почему плохо масштабируется:** 
1.  **Высокие затраты на I/O:** Чтобы найти, например, 100 свободных блоков для записи большого файла, ОС может потребоваться прочитать несколько блоков с указателями с диска. Это медленно.
2.  **Фрагментация:** Список не дает информации о том, лежат ли свободные блоки рядом. В итоге новый файл будет «размазан» по всему диску, что катастрофично для производительности HDD.

---

#### **Почему free-list может занимать много места на больших дисках? ⭐⭐**

Если диск почти пуст, список свободных блоков становится огромным. 
*   Пусть диск имеет объем 1 ТБ, а размер блока — 1 КБ. Всего на диске $10^9$ блоков.
*   Каждый номер блока (указатель) занимает 32 бита (4 байта).
*   Если диск пуст, нам нужно хранить $10^9$ указателей по 4 байта каждый = **4 ГБ** дискового пространства только для того, чтобы знать, что диск пуст.
*   Хотя это место берется из самих свободных блоков, это увеличивает объем служебных данных, которые нужно прочитать/просканировать при управлении местом.

---

#### **Как bitmap кодирует свободное пространство и почему он считается очень компактным? ⭐⭐**

**Принцип кодирования:**
Используется битовая карта (вектор), где каждому блоку диска соответствует ровно 1 бит.
*   `1` — блок свободен.
*   `0` — блок занят.

**Компактность:**
Битовая карта требует в 32 раза (при 32-битных адресах) меньше места, чем список указателей. 
*   Для того же диска 1 ТБ с блоками 1 КБ битовая карта займет всего около **120 МБ** ($10^9$ бит). Это легко помещается в оперативную память современных систем целиком или крупными частями.

---

#### **Почему bitmap удобнее для поиска последовательностей свободных блоков? ⭐⭐⭐**

Современные файловые системы стараются записывать файлы в **непрерывные** последовательности блоков (экстенты), чтобы минимизировать перемещение головок диска.
*   В **связном списке** блоки перемешаны. Чтобы найти 10 идущих подряд блоков, нужно просмотреть почти весь список.
*   В **битовой карте** поиск идущих подряд блоков сводится к поиску последовательности единиц в оперативной памяти. Это делается очень быстро с помощью специальных инструкций процессора (например, сканирование битов).

---

#### **Какие преимущества даёт хранение bitmap «по одной странице в памяти»? ⭐⭐⭐**

Если диск очень большой (десятки ТБ), битовая карта может не влезть в RAM целиком. ОС разбивает её на страницы (блоки).
1.  **Локальность обращения:** Большинство аллокаций происходит в одной области диска. ОС держит в памяти только ту «страницу» битовой карты, которая описывает текущую область работы.
2.  **Экономия RAM:** Не нужно тратить сотни мегабайт памяти на описание всей поверхности диска, если мы работаем только с его началом.
3.  **Уменьшение I/O:** Запись изменений битовой карты на диск происходит порциями (страницами), только когда данные в этой области реально изменились.

---

#### **Зачем оптимизируют free-list через «pointer block наполовину заполненный» и как это уменьшает I/O? ⭐⭐⭐**

Эта оптимизация решает проблему **«дискового дребезга» (thrashing)**.
Представьте, что блок указателей в памяти полон. 
1.  Если мы освобождаем еще один блок на диске, блок указателей переполняется, и ОС вынуждена **записать** его на диск.
2.  Если сразу после этого мы создаем файл и нам нужен блок, ОС должна **прочитать** этот блок обратно с диска.
Если программа постоянно создает и удаляет временные файлы, ОС будет бесконечно гонять этот блок туда-сюда.

**Решение:**
Поддерживать блок указателей в памяти заполненным примерно наполовину. Тогда у системы есть «запас» как для массового освобождения блоков, так и для массового выделения без необходимости немедленного обращения к диску.

---

#### **Зачем квоты нужны в многопользовательских системах и какие угрозы они предотвращают? ⭐⭐**

**Цель:** Ограничение дискового пространства для каждого пользователя.
**Предотвращаемые угрозы:**
1.  **Монополизация ресурсов:** Один пользователь может (случайно или намеренно) забить весь диск логами или загрузками, из-за чего система не сможет записывать критические данные, а другие пользователи не смогут работать.
2.  **DoS-атаки:** Злонамеренное заполнение диска для остановки работы сервера.
3.  **Бесконтрольный рост:** Помогает администратору планировать закупки оборудования, понимая лимиты потребления.

---

#### **Чем ограничение «количество файлов» отличается от ограничения «количество блоков»? ⭐⭐**

1.  **Количество блоков (Space limit):** Ограничивает физический объем данных (МБ/ГБ). Защищает от гигантских файлов.
2.  **Количество файлов (Inode limit):** Ограничивает количество записей в таблице индексов (inodes). 
    *   *Зачем это нужно:* В UNIX-системах количество inode фиксируется при форматировании. Пользователь может создать миллион пустых файлов размером 0 байт. Место (блоки) не кончится, но закончатся inode, и никто больше не сможет создать ни одного файла в системе.

---

#### **В чём смысл soft limit и hard limit, и почему soft limit можно превышать временно? ⭐⭐**

*   **Hard limit (Жесткий лимит):** Абсолютный порог. Как только он достигнут, любой системный вызов `write()` вернет ошибку.
*   **Soft limit (Мягкий лимит):** Порог предупреждения. Пользователь может его превысить.
*   **Зачем превышать временно:** Для удобства работы. Например, при компиляции программы или создании архива объем данных может временно вырасти, а потом уменьшиться. Система дает пользователю «льготный период» (grace period, обычно 7 дней), чтобы тот почистил диск. Если по истечении срока лимит всё еще превышен, мягкий лимит превращается в жесткий.

---

#### **Как связаны open files table и запись квоты при увеличении размера файла? ⭐⭐⭐**

Чтобы проверка квот не тормозила систему при каждой записи байта:
1.  Когда процесс открывает файл, ОС находит запись о квотах владельца этого файла в системной таблице квот на диске.
2.  Эта запись загружается в память и **связывается с указателем на открытый файл** в системной таблице (Open File Table) или в структуре `v-node/i-node` в RAM.
3.  При каждой операции `write()`, которая увеличивает размер файла, ОС просто проверяет счетчик в уже загруженной структуре квоты. Это происходит в оперативной памяти без обращения к дисковой таблице квот.

---

#### **Почему система предупреждает при входе в систему о превышении soft limit, а не обязательно сразу запрещает запись? ⭐⭐⭐**

Это вопрос **User Experience** и стабильности:
1.  **Предотвращение внезапной остановки:** Если сразу запретить запись, пользователь может потерять результаты работы (программа не сможет сохранить файл).
2.  **Дать время на реакцию:** Предупреждение при логине сообщает: «У тебя есть 3 дня, чтобы удалить мусор, иначе запись заблокируется». Это позволяет пользователю комфортно провести очистку.
3.  **Автоматизация:** Многие системные процессы требуют записи. Мягкий лимит позволяет им завершиться успешно, не «ломая» систему немедленно.