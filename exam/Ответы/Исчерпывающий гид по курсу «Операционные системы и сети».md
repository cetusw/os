Приветствую, коллеги. Перед вами руководство, призванное систематизировать ваши знания перед экзаменационным испытанием. Мы рассмотрим архитектуру ОС не просто как набор утилит, а как результат долгой эволюции инженерной мысли. Помните старый закон: «онтогенез повторяет филогенез». История развития вычислительной техники — от мейнфреймов до встраиваемых систем — отражается в каждом системном вызове. Наша цель — понять логику работы ядра, чтобы на экзамене вы могли обосновать любое архитектурное решение.

--------------------------------------------------------------------------------

## 1. Фундаментальные концепции и управление процессами

Процесс — это центральная абстракция ОС, превращающая статическую программу в динамическую сущность. В то время как программа — это пассивный файл на диске, процесс — это «программа в действии», обладающая собственным жизненным циклом. ОС использует эту абстракцию для обеспечения изоляции: каждый процесс функционирует в своем «коконе» (адресном пространстве), что критически важно для стабильности. Ошибка в одном процессе не должна приводить к краху всей системы.

Процесс определяется его **адресным пространством** и набором **ресурсов** (счетчик команд, регистры, открытые файлы, таймеры). Для мониторинга процессов в UNIX-системах мы используем `ps aux`. Для экзамена важно понимать значение каждого столбца, особенно в контексте потребления ресурсов:

|   |   |   |
|---|---|---|
|Столбец|Значение|Описание|
|**USER**|Пользователь|UID, от имени которого запущен процесс (права доступа).|
|**PID**|ID процесса|Уникальный идентификатор процесса.|
|**%CPU**|Нагрузка CPU|Доля времени процессора, выделенная процессу.|
|**%MEM**|Нагрузка ОЗУ|Доля физической памяти, используемая процессом.|
|**VSZ**|Virtual Size|Полный объем виртуальной памяти процесса (в КБ).|
|**RSS**|Resident Set|Объем физической памяти, занятый процессом (в КБ).|
|**STAT**|Состояние|Статус процесса (R — выполняется, S — прерываемый сон, D — непрерываемый сон).|
|**TIME+**|CPU Time|Суммарное время работы процессора.|
|**COMMAND**|Команда|Строка запуска процесса.|

Процессы организованы в иерархию. В UNIX-подобных системах прародителем всех процессов является `init` (PID 1). Иерархию можно визуализировать через `ps aux --forest`:

```text
/sbin/init (PID 1)
 └─ /init (PID 2)
     └─ /init (PID 428)
         └─ -bash (PID 430)
             └─ ps aux --forest (PID 5125)
```

**Модель пользователей и безопасность:** Безопасность строится на идентификаторе пользователя (UID). Суперпользователь (**root**, UID=0) обладает неограниченными полномочиями и может обходить любые механизмы защиты.

- `su` (substitute user): требует пароль целевого аккаунта, полностью меняет сессию. Исторически это был основной способ администрирования.
- `sudo` (superuser do): современный стандарт. Требует пароль _текущего_ пользователя (если он в группе sudo) и повышает права только для одной команды, что позволяет детально логировать действия.

Для эффективного выполнения процессов системе необходимо грамотно распределять память, к чему мы и переходим.

--------------------------------------------------------------------------------

## 2. Управление памятью и виртуализация

Память — дефицитный ресурс, требующий как программной, так и аппаратной защиты. В ранних системах в ОЗУ находился один процесс, но мультипрограммирование потребовало изоляции. Современные процессоры используют аппаратные средства защиты, чтобы пресекать попытки процесса обратиться к чужому адресному пространству.

**Виртуальная память** — это триумф абстракции. Она позволяет программам использовать адресное пространство, значительно превышающее объем физической оперативной памяти (RAM). Это достигается за счет динамической подгрузки фрагментов из RAM в **Swap** (область на диске). Для программиста это упрощает разработку: больше не нужно вручную управлять загрузкой сегментов кода.

Студент должен уметь интерпретировать данные инструментов мониторинга:

- `free -h`: дает общую картину. Важно понимать разницу между **free** (абсолютно пустая память) и **available** (память, которую можно выделить без ухода в Swap, включая кэши).
- `vmstat`: показывает статистику по процессам, памяти, **si/so** (swap-in/swap-out — высокая активность здесь говорит о нехватке RAM).

Взаимодействие программы с памятью и ресурсами жестко регламентировано интерфейсом системных вызовов.

--------------------------------------------------------------------------------

## 3. Системные вызовы: Интерфейс между приложением и ядром

Системный вызов — это единственный безопасный способ перехода из пользовательского режима (Ring 3) в привилегированный режим ядра (Ring 0) для выполнения операций с оборудованием.

**Механизм выполнения (на примере x86-64):**

1. Пользовательская программа вызывает **библиотечную процедуру** (например, `read` из libc).
2. Параметры готовятся в регистрах (**RDI** для дескриптора, **RSI** для буфера, **RDX** для размера).
3. Библиотека помещает номер системного вызова в регистр **RAX**.
4. Выполняется инструкция `trap` (или `syscall`), переключающая CPU в режим ядра.
5. Ядро через таблицу диспетчеризации находит обработчик, выполняет работу и возвращает результат в регистр RAX, переключаясь обратно в Ring 3.

**Адресное пространство процесса** при этом делится на три ключевых сегмента:

- **Text (Code):** инструкции программы (только для чтения).
- **Data:** глобальные переменные (растет «вверх» к стеку).
- **Stack:** локальные переменные и кадры функций (растет «вниз» к данным).

**Сравнение POSIX и Win32 API:**

| Категория    | Вызов POSIX | Описание           | Аналог Win32 API      |
| ------------ | ----------- | ------------------ | --------------------- |
| **Процессы** | `fork()`    | Копия процесса     | `CreateProcess`       |
| **Процессы** | `waitpid()` | Ожидание дочернего | `WaitForSingleObject` |
| **Файлы**    | `open()`    | Открытие файла     | `CreateFile`          |
| **Файлы**    | `lseek()`   | Сдвиг позиции      | `SetFilePointer`      |
| **Файлы**    | `stat()`    | Метаданные файла   | `GetFileAttributesEx` |

**Логика Shell:** Командный интерпретатор работает по циклу: `fork()` создает дочерний процесс, в котором `execve()` заменяет образ памяти новой программой. Родитель при этом вызывает `waitpid()`. Однако параллельное выполнение порождает проблему конкуренции.

--------------------------------------------------------------------------------

## 4. Взаимное исключение и синхронизация

Когда два потока одновременно модифицируют данные, возникает **состояние гонки** (race condition). Классический пример — инкремент счетчика: `read-modify-write`. Если прерывание случится между чтением и записью, данные будут потеряны. Решение — **атомарные операции**, использующие аппаратный префикс `lock` для блокировки шины памяти.

**4 условия корректного решения критической секции:**

1. **Взаимное исключение:** Только один процесс внутри секции.
2. **Независимость от скорости:** Решение не зависит от частоты CPU и их количества.
3. **Нет блокировок извне:** Процесс вне секции не должен мешать другим входить в неё.
4. **Справедливость:** Отсутствие бесконечного ожидания (голодания).

**Эволюция методов:**

- **CLI/STI:** Отключение прерываний (флаг IF в RFLAGS). Доступно только в **Ring 0**, действует только на **локальное ядро** CPU. Опасно: пользовательский процесс может «завесить» систему.
- **Переменная-блокировка:** Неатомарна. Пока один процесс проверяет флаг, другой может его успеть установить.
- **Строгое чередование (Strict Alternation):** Нарушает условие №3, заставляя быстрый процесс ждать медленный.
- **Алгоритм Петерсона:** Элегантное программное решение. **Внимание:** на современных процессорах из-за внеочередного выполнения команд (out-of-order execution) он требует использования **барьеров памяти (fences)**, иначе проверка флагов может произойти в неверном порядке.

Аппаратные инструкции **TSL** (Test and Set Lock) и **XCHG** реализуют **активное ожидание** (busy waiting). Это эффективно для спинлоков в ядре, но для длительных пауз лучше использовать примитивы, отправляющие процесс «спать».

--------------------------------------------------------------------------------

## 5. Семафоры, Мьютексы и Мониторы

Чтобы не тратить циклы CPU впустую, применяются механизмы блокировки.

**Семафоры (Дейкстра):** Целочисленная переменная (счетчик пробуждений).

- `down (P)`: если > 0, уменьшает на 1. Если 0 — процесс засыпает.
- `up (V)`: увеличивает на 1, будит одного из спящих. В задаче **«Производитель-Потребитель»** используются три семафора: `mutex` (бинарный, для защиты буфера), `empty` (счетчик свободных мест) и `full` (счетчик занятых).

**Мьютексы и Futex:** Мьютекс — это упрощенный семафор (0 или 1). **Futex** (Fast User Space Mutex) в Linux — это гибрид: если конкуренции нет, захват идет мгновенно в пользовательском пространстве. Если ресурс занят, выполняется системный вызов для постановки в очередь ожидания в ядре.

**Мониторы:** Высокоуровневая концепция (Java/Pascal). Компилятор берет на себя управление блокировкой. Ключевое слово `synchronized` в Java создает монитор, гарантируя, что в один момент времени в объекте активен только один поток.

--------------------------------------------------------------------------------

## 6. Продвинутые механизмы: Обмен сообщениями и Барьеры

В распределенных системах, где нет общей памяти, используется обмен сообщениями через `send/receive`. Ключевые вопросы здесь: подтверждения (**ACK**), уникальные номера (**seqno**) для борьбы с дубликатами и адресация (на процесс или в «почтовый ящик»).

**Барьеры:** Синхронизируют группу потоков. Никто не начнет фазу n+1, пока все не закончат фазу n.

```text
Поток 1: --(работа)--[Arrive].............[Phase Sync]--->
Поток 2: --(работа)----------[Arrive].....[Phase Sync]--->
Поток 3: --(работа)----------------[Arrive][Phase Sync]--->
```

**Инверсия приоритетов (урок Mars Pathfinder):** Ситуация, когда поток с низким приоритетом (L) держит ресурс, необходимый высокому (H), а средний поток (M) вытесняет L, не давая ему освободить ресурс. Решается через **Priority Inheritance** (L временно получает приоритет H) или **Priority Ceiling** (мьютекс имеет фиксированный высокий приоритет).

**RCU (Read-Copy-Update):** Самая быстрая альтернатива локам для структур «много читателей — мало писателей».

1. **Копирование:** Писатель делает копию данных.
2. **Публикация:** Атомарно меняет указатель на новую версию.
3. **Grace Period:** Ожидание, пока все читатели покинут критические секции. Важный нюанс: читатели в RCU **не могут спать или блокироваться**, что позволяет ядру определить конец периода по переключению контекста.

--------------------------------------------------------------------------------

## 7. Файловые системы: Архитектура и Реализация

Файл — это абстракция, скрывающая детали физических блоков. **Структура файла (теория):**

- **Последовательность байтов:** (UNIX/Windows) Максимальная гибкость.
- **Последовательность записей:** (Мейнфреймы) Фиксированная длина.
- **Дерево:** (БД) Быстрый поиск по ключу.

**Типы файлов:** Обычные, Каталоги, Специальные символьные (терминалы), Специальные блочные (диски). **Атрибуты:** Права доступа задаются тремя группами битов: **Owner, Group, Others** (например, `rwxr-xr-x`).

**Реализация на диске:**

1. **Непрерывное размещение:** Высокая скорость, но фрагментация и сложность роста файла.
2. **FAT (Linked List):** Таблица в памяти хранит цепочки блоков. Плохо масштабируется на большие диски (таблица становится огромной).
3. **I-nodes:** Индексные узлы. В памяти хранится i-node только открытого файла. Самая масштабируемая структура.

**Ссылки:**

- **Hard links:** Разные имена ведут к одному i-node. Файл живет, пока счетчик ссылок > 0. **Запрещены для каталогов**, чтобы избежать бесконечных циклов в дереве.
- **Soft links:** Файл-путь к оригиналу.

**Загрузка:** Старый **MBR** (сектор 0) ограничен 2 ТБ. Современный **UEFI + GPT** поддерживает диски до 8 ZiB. Для надежности **GPT дублируется** — хранится в начале и в конце диска.

--------------------------------------------------------------------------------

## 8. Итоговый контрольный список для студента

Перед входом в аудиторию проверьте себя на этих «тонких» вопросах:

1. **В чем разница между VSZ и RSS?** VSZ — вся выделенная вирт. память, RSS — только то, что реально в RAM.
2. **Почему нельзя делать hard link на директорию?** Чтобы не создать циклы, которые сломают алгоритмы обхода ФС.
3. **Как работает Copy-on-Write при** `**fork()**`**?** Память не копируется физически, пока один из процессов не попытается её изменить.
4. **В чем разница между spin_lock и mutex?** Spin_lock — активное ожидание (CPU занят), mutex — поток засыпает (CPU свободен).
5. **Почему Peterson’s algorithm может не работать на x86-64?** Из-за переупорядочивания инструкций процессором (нужны memory barriers).
6. **Что такое Grace Period в RCU?** Интервал времени, за который каждый поток гарантированно прошел точку переключения контекста.
7. **Зачем нужен раздел ESP?** EFI System Partition содержит загрузчики и драйверы в формате FAT32.
8. **Чем** `**sudo**` **безопаснее** `**su**`**?** Sudo использует пароль текущего пользователя и позволяет ограничивать список доступных команд.
9. **Как ядро понимает, какой системный вызов выполнить?** По номеру, записанному в регистр RAX перед инструкцией `syscall`.
10. **Что такое инверсия приоритетов?** Когда высокоприоритетный поток ждет низкоприоритетный, который вытеснен среднеприоритетным.
11. **Почему CLI/STI не подходят для синхронизации в user space?** Это привилегированные инструкции (Ring 0), и они не работают на многопроцессорных системах.
12. **В чем разница между абсолютным и относительным путем?** Абсолютный — от корня (`/`), относительный — от текущего рабочего каталога процесса.
13. **Куда растут сегменты Data и Stack?** Data (куча) обычно растет вверх, Stack — вниз навстречу друг другу.
14. **Какую структуру файлов использует UNIX?** Неструктурированную последовательность байтов.
15. **Где хранится резервная копия GPT?** В самых последних блоках физического диска.

Удачи, коллеги. Помните: экзаменатор ценит системность и понимание физики процесса, а не только знание ключей командной строки.