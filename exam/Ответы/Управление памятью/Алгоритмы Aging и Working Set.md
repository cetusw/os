#### **Опишите механизм Aging: сдвиг счётчика, добавление R в старший бит, сброс R. ⭐⭐**

Алгоритм **Aging (старение)** имитирует LRU программным способом. Каждый тик системного таймера ОС выполняет следующие действия:

1. Счётчики всех страниц в памяти **сдвигаются вправо на 1 бит** (значение делится на 2).
2. Бит обращения **R (Referenced)** добавляется в качестве самого **старшего (крайнего левого)** бита счётчика.
3. Бит **R сбрасывается** в 0. Это приводит к тому, что при возникновении ошибки страницы выбирается страница с **наименьшим значением счётчика**.

#### **Почему Aging лучше NFU имитирует LRU и как именно он «забывает» старые обращения? ⭐⭐**

В отличие от NFU (Not Frequently Used), который просто накапливает обращения и «ничего не забывает», Aging при каждом сдвиге уменьшает значимость прошлых событий. Благодаря вставке бита R в **старший бит**, недавнее обращение сразу дает странице «большой вес», а старые обращения постепенно вымываются из счётчика вправо, пока не исчезнут вовсе.

#### **От чего зависит точность Aging (размер счётчика, период тика) и какие компромиссы при выборе параметров? ⭐⭐⭐**

Точность зависит от:

- **Размера счётчика:** определяет глубину истории (например, 8-битный счётчик хранит данные за 8 тиков).
- **Периода тика таймера:** определяет частоту обновления статистики. Если тик слишком редкий, страницы перестают различаться по времени доступа; если слишком частый — накладные расходы на обновление всех счётчиков в памяти станут избыточными.

#### **Почему Aging не различает порядок обращений внутри одного интервала, и когда это важно? ⭐⭐⭐**

Aging фиксирует лишь **факт наличия** хотя бы одного обращения (бит R) за весь интервал между тиками таймера. Если страница А использовалась в начале интервала, а страница Б — в самом конце, для алгоритма они будут **равноценны** (у обеих бит R станет 1). Это может быть критично в системах с очень высокой интенсивностью обращений, где за 20 мс (стандартный тик) происходит миллионы операций.

#### **Объясните, почему на практике часто достаточно 8-битного счётчика (с точки зрения «длины истории»). ⭐⭐**

При стандартном периоде тика таймера в **20 мс**, 8-битный счётчик хранит историю обращений за последние **160 мс** ($8 \times 20$ мс). На практике этого диапазона достаточно, чтобы надежно отличить активно используемые страницы от тех, которые уже вышли из текущей фазы работы программы.

#### **Дайте определение рабочего множества W(k,t) и объясните смысл параметра окна (k или Δ). ⭐⭐**

**Рабочее множество $W(k, t)$** — это набор страниц, к которым процесс обращался в течение **$k$ последних обращений** к памяти в момент времени $t$. Смысл окна (будь то количество обращений $k$ или интервал времени $\Delta$) заключается в определении **локальности** процесса: ОС стремится держать в памяти только те страницы, которые реально нужны программе прямо сейчас.

#### **Почему рабочее множество «меняется медленно» и как это связано с фазами выполнения программы? ⭐⭐**

Рабочее множество меняется медленно из-за **принципа локальности**: программы обычно концентрируются на выполнении определенного участка кода или обработке конкретного блока данных в течение некоторого времени. Резкие изменения рабочего множества происходят только при переходе между **фазами выполнения** (например, от парсинга текста к генерации кода в компиляторе).

#### **Как алгоритм Working Set решает, что страница «вышла» из рабочего множества? Какие данные ему нужны? ⭐⭐⭐**

Для принятия решения алгоритму нужны **бит R** и **время последнего использования** ( Time of last use), хранящееся в записи таблицы страниц.

- Если $R=1$, страница считается активной, и её время последнего использования обновляется на текущее виртуальное время.
- Если $R=0$, вычисляется «возраст» страницы (Текущее время - Время последнего использования). Если **возраст $>\Delta$**, страница считается вышедшей из рабочего множества и может быть выселена.

#### **Почему Working Set помогает предотвращать thrashing на уровне всей системы, а не только одного процесса? ⭐⭐⭐**

Алгоритм позволяет ОС контролировать **степень многозадачности**. Если суммарный размер рабочих множеств всех процессов превышает объем физической ОЗУ, система понимает, что наступит **thrashing (буксование)**, и может принять решение временно приостановить один из процессов, выгрузив его полностью, чтобы дать остальным работать эффективно.

#### **Что такое prepaging и почему знание рабочего множества делает его возможным? ⭐⭐**

**Prepaging (предварительная подкачка)** — это загрузка набора страниц в память **до** того, как процесс начнет их использовать (например, при возобновлении работы процесса после паузы). Зная рабочее множество процесса на момент его остановки, ОС может загрузить все эти страницы разом, предотвращая каскад неизбежных page faults при старте.

---
