#### **На каком предположении основан LRU и как это связано с локальностью? ⭐⭐**

Алгоритм **LRU (Least Recently Used)** основан на принципе **локальности обращений**. Он предполагает, что страницы, которые недавно использовались активно, с большой вероятностью понадобятся снова в ближайшем будущем. И наоборот: если к странице давно не обращались, она, скорее всего, не нужна.

---

#### **Почему LRU рассматривают как практическое приближение OPT? ⭐⭐**

Так как ОС не может знать будущее (OPT), она использует **прошлое как предсказатель будущего**. LRU — это попытка имитировать идеальный алгоритм, основываясь на предположении, что характер обращений к памяти в программе меняется плавно и предсказуемо.

---

#### **Как выглядела бы «идеальная» реализация LRU и что в ней дорого? ⭐⭐⭐**

Идеальный LRU требовал бы наличия в таблице страниц поля для хранения **точного времени (или номера инструкции)** последнего обращения. При каждом доступе к памяти (миллиарды раз в секунду) аппаратура должна была бы записывать текущее значение системного счетчика в это поле. Это требует огромных затрат на шину памяти и делает поиск «жертвы» (минимального значения среди всех страниц) крайне долгим.

---

#### **Почему чистый LRU редко реализуется без аппаратных механизмов? ⭐⭐⭐**

Без специальной поддержки в процессоре реализация LRU программным способом (например, через обновление связного списка при каждом обращении) снизила бы производительность системы в десятки и сотни раз. Поэтому ОС используют более дешевые **программные аппроксимации**, такие как Clock или Aging.

---

#### **На последовательности обращений `1, 2, 3, 1, 4, 2, 1, 5` объясните принцип выбора жертвы LRU (3 фрейма). ⭐⭐⭐**

1. `1, 2, 3` — память заполнена.
2. `1` — обращение к 1, она становится самой «свежей». Очередь (от старых к новым): `2, 3, 1`.
3. `4` — нужно выселить самую старую (`2`). Очередь: `3, 1, 4`.
4. `2` — нужно выселить самую старую (`3`). Очередь: `1, 4, 2`.
5. `1` — обращение к 1, она снова свежая. Очередь: `4, 2, 1`.
6. `5` — выселяется самая старая (`4`). Итог: `2, 1, 5`.

---

#### **Как работает NFU и какую «идею» он пытается использовать? ⭐⭐**

**NFU (Not Frequently Used)** использует идею **популярности (частоты)**. У каждой страницы есть программный счетчик. При каждом тике таймера ОС проверяет бит R: если он равен 1, значение счетчика увеличивается. При page fault выселяется страница с **наименьшим значением счетчика**.

---

#### **Почему NFU может сохранять страницы, которые больше не нужны? ⭐⭐⭐**

Проблема NFU в том, что он **«ничего не забывает»**. Если страница использовалась очень интенсивно в начале работы программы (например, при инициализации), её счетчик станет огромным. Даже если позже она перестанет быть нужной, NFU будет хранить её в памяти вечно, вытесняя более полезные новые страницы с меньшими счетчиками.

---

#### **Как фазовое поведение программы может «сломать» NFU? ⭐⭐⭐**

В многофазных программах (например, компиляторах) страницы первой фазы (лексического анализа) накопят высокие значения. Когда начнется вторая фаза (генерация кода), новые страницы будут иметь нулевые счетчики и станут **первыми кандидатами на выселение**, хотя именно они сейчас критически важны. Это вызывает катастрофический рост page faults.

---

#### **Способы «забывания прошлого» для улучшения NFU. ⭐⭐⭐**

Лучшим способом является алгоритм **Aging** (старение):

1. При каждом тике таймера все счетчики сначала **сдвигаются вправо на 1 бит** (значение делится на 2).
2. Затем бит **R** добавляется в качестве самого старшего бита счетчика. Это гарантирует, что недавние обращения имеют гораздо больший вес, чем старые, и неиспользуемые страницы быстро «теряют в цене».