#### **Почему виртуальный адрес логично делить на «номер страницы» и «смещение», и что делает каждую часть? ⭐⭐**

Деление виртуального адреса на две части позволяет эффективно сопоставлять логическое пространство программы с физической памятью.

- **Номер страницы (старшие биты):** используется процессором (MMU) как индекс для поиска соответствующей записи в таблице страниц. По этому индексу определяется, в каком физическом фрейме находятся данные.
- **Смещение (младшие биты):** определяет конкретную позицию байта внутри выбранной страницы. Оно не изменяется при трансляции и напрямую копируется из виртуального адреса в физический, так как размер страницы и фрейма всегда одинаков.

---

#### **Как вычисляется физический адрес после того, как найден номер физического фрейма? ⭐⭐**

Процесс вычисления (трансляции) происходит следующим образом: MMU берет **номер физического фрейма** из таблицы страниц и объединяет его с **12-битным смещением** (в случае страниц по 4 КБ) из исходного виртуального адреса. Фактически, номер фрейма заменяет номер виртуальной страницы, указывая на начало блока в ОЗУ, а смещение указывает на конкретный байт внутри этого блока.

---

#### **Какие ошибки проектирования могут возникать, если выбрать «слишком маленький» или «слишком большой» размер страницы? ⭐⭐⭐**

Выбор размера страницы — это всегда компромисс:

- **Слишком маленький размер:** приводит к резкому увеличению размеров самих таблиц страниц (overhead), так как для описания того же объема памяти требуется больше записей. Это увеличивает накладные расходы ресурсов системы.
- **Слишком большой размер:** вызывает значительную **внутреннюю фрагментацию**, так как в конце последнего выделенного сегмента памяти может оставаться много пустого, неиспользуемого пространства, которое помечено как занятое. Оптимальным для большинства современных систем считается размер 4 КБ.

---

#### **Что хранит таблица страниц и почему она является ключевой структурой виртуальной памяти? ⭐⭐**

Таблица страниц хранит соответствие между **номерами виртуальных страниц** процесса и **номерами физических фреймов** в оперативной памяти. Она является ключевой структурой, так как именно она обеспечивает абстракцию адресного пространства, позволяя ОС изолировать процессы друг от друга, защищать память ядра и запускать программы, размер которых превышает объем физической ОЗУ.

---

#### **Какие поля обычно есть в Page Table Entry (PTE) и зачем нужны: Present, Protection, Supervisor/User, Modified, Referenced? ⭐⭐⭐**

Каждая запись таблицы страниц (PTE) содержит служебные биты:

- **Present (Присутствие):** 1 — страница в ОЗУ; 0 — на диске (обращение вызовет _page fault_).
- **Protection (Защита):** определяет права доступа (чтение, запись, выполнение).
- **Supervisor/User:** ограничивает доступ к страницам ядра для обычных пользовательских процессов.
- **Modified (Dirty / Изменено):** устанавливается, если в страницу производилась запись; такая страница требует сохранения на диск перед выселением.
- **Referenced (Обращение):** устанавливается при любом обращении к странице, помогая алгоритмам замещения понять, что страница активна.

---

#### **Почему биты Modified и Referenced особенно важны для политики замещения страниц? ⭐⭐⭐**

Эти биты позволяют ОС классифицировать страницы по их «ценности». Бит **Referenced** помогает идентифицировать страницы, к которым давно не обращались (кандидаты на удаление), а бит **Modified** указывает, будет ли замена страницы «дешевой» (просто перезаписать) или «дорогой» (сначала нужно записать изменения на диск). Использование этих битов лежит в основе алгоритмов NRU, LRU и Clock.

---

#### **Объясните, как таблица страниц обеспечивает защиту: почему пользовательский процесс не может читать/писать страницы ядра. ⭐⭐⭐**

Защита реализуется через бит **Supervisor/User** в записи таблицы страниц. Если этот бит установлен в значение «только ядро», аппаратура (MMU) при попытке доступа к этой странице из пользовательского режима немедленно генерирует исключение (_fault_). Поскольку таблицы страниц находятся под управлением ОС, пользовательский процесс не может самостоятельно изменить свои права доступа.

---

#### **Почему многие ОС оставляют область около адреса 0 неотображённой (например, старт с 0x1000), и какие ошибки это помогает ловить? ⭐⭐**

Эта область намеренно оставляется пустой (не отображенной на физическую память), чтобы ловить ошибки **разыменования нулевого указателя** (NULL pointer dereference). Если программа попытается обратиться к адресу в диапазоне 0x0–0x1000, MMU не найдет записи в таблице страниц и вызовет исключение, что позволит немедленно остановить процесс и указать программисту на логическую ошибку в коде.

---

#### **Почему «одна плоская таблица страниц» становится неприемлемой в 64-битных адресных пространствах? ⭐⭐**

При 64-битной адресации и размере страницы 4 КБ общее число страниц составляет около $4,5 \times 10^{15}$. Если использовать одну плоскую таблицу, она заняла бы огромный объем оперативной памяти, значительно превышающий возможности любого современного компьютера, так как под каждую возможную страницу пришлось бы выделить запись, даже если она не используется.

---

#### **Объясните принцип многоуровневой таблицы страниц: почему «неиспользуемые подтаблицы не создаются» и как это экономит память. ⭐⭐⭐**

Многоуровневая таблица строится как иерархия (дерево). Таблица верхнего уровня указывает на таблицы нижних уровней. Если процесс не использует огромный диапазон виртуальных адресов, то в таблице верхнего уровня соответствующие записи помечаются как отсутствующие, и **подтаблицы для этих диапазонов не создаются вовсе**. Это позволяет описывать гигантские адресные пространства, физически храня в памяти лишь небольшие фрагменты таблиц для реально занятых областей кода и данных.

---

#### **Почему многоуровневость увеличивает число обращений к памяти при трансляции адреса, и как TLB уменьшает эту цену? ⭐⭐⭐**

При каждом доступе к данным процессору приходится последовательно считывать каждую таблицу в иерархии (в x86-64 это 4 обращения только к таблицам страниц), что замедляет работу в разы. **TLB (кэш трансляции адресов)** хранит результаты последних успешных преобразований «виртуальная страница — физический фрейм». При попадании в TLB (hit) трансляция происходит за 1–2 такта, полностью избавляя систему от необходимости многократных обращений к ОЗУ для чтения таблиц.

---

#### **Какие последствия для производительности даёт промах TLB (TLB miss) и почему переключение контекста связано с TLB? ⭐⭐⭐**

- **TLB miss:** вынуждает MMU выполнять медленный «обход страниц» (page walk) в оперативной памяти, что может стоить сотни тактов процессора и значительно снижать производительность программы.
- **Переключение контекста:** так как у каждого процесса своя уникальная таблица страниц, при смене процесса записи в TLB становятся неверными. Системе приходится либо полностью очищать TLB (_flush_), что приводит к его долгому повторному заполнению и падению скорости, либо использовать идентификаторы адресных пространств (ASID) для маркировки «своих» записей.