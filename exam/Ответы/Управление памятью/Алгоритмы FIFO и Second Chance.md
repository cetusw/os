#### **Как FIFO выбирает жертву и почему он почти не требует вычислений? ⭐⭐**

Алгоритм **FIFO (First-In, First-Out)** выселяет ту страницу, которая была **загружена в память раньше всех**. ОС просто поддерживает список (очередь) страниц в порядке их появления: новая страница добавляется в хвост, а жертва всегда берется из головы списка. Это требует минимума вычислений, так как не нужно анализировать биты обращения или время использования.

---

#### **В чём ключевой недостаток FIFO с точки зрения «актуальности» страниц? ⭐⭐**

Главный недостаток в том, что старейшая страница в памяти **может быть самой часто используемой**. Например, страница с кодом инициализации библиотек, загруженная в самом начале, может требоваться программе постоянно, но FIFO всё равно выселит её просто из-за её «возраста».

---

#### **Объясните аномалию Белади: почему увеличение числа фреймов может увеличить число page faults именно у FIFO? ⭐⭐⭐**

**Аномалия Белади** (открытая Ласло Белади) — это парадоксальная ситуация, когда при увеличении объема доступной физической памяти количество ошибок страниц не падает, а **растет**. Это происходит у FIFO, потому что порядок выселения страниц не зависит от их востребованности. При определенных паттернах доступа добавление нового фрейма меняет очередность выселения так, что из памяти начинают удаляться страницы, которые понадобятся буквально следующим шагом.

---

#### **Приведите интуитивный пример, как FIFO может вытеснить «полезную» страницу просто потому, что она старая. ⭐⭐**

Представьте программу, которая постоянно использует большой массив данных. Страница, содержащая **начало этого массива**, была загружена первой. Когда памяти перестает хватать, FIFO выселит именно её, так как она самая «старая», хотя программа обращается к ней в каждом цикле. В результате возникнет немедленная ошибка страницы для её возврата.

---

#### **Почему FIFO полезен как учебный алгоритм и как базовая линия для сравнения, но редко используется «в чистом виде»? ⭐⭐**

FIFO полезен для обучения благодаря своей **предельной простоте** и наглядности. Он служит «точкой отсчета»: любой более сложный алгоритм обязан показывать результаты лучше, чем FIFO, чтобы оправдать свою сложность. В чистом виде он не используется из-за низкой эффективности и риска возникновения аномалии Белади.

---

#### **Как Second Chance модифицирует FIFO и какую проблему FIFO он решает? ⭐⭐**

Алгоритм **Second Chance («второй шанс»)** добавляет к логике FIFO проверку **бита R**. Если самая старая страница имеет $R=1$, она не удаляется, а получает «второй шанс»: её бит R сбрасывается в 0, и она перемещается в конец очереди, как если бы была загружена только что. Это решает проблему FIFO, предотвращая удаление **активно используемых старых страниц**.

---

#### **Что происходит со страницей, у которой R=1, когда она рассматривается как кандидат на вытеснение? ⭐⭐**

Такая страница признается «недавно использовавшейся». Вместо удаления ОС **сбрасывает её бит R в 0** и переносит страницу в конец списка (очереди). Её «время загрузки» обновляется до текущего, и поиск кандидата на выселение продолжается со следующей по старшинству страницы в очереди.

---

#### **Почему Second Chance можно считать «мягкой» версией NRU? ⭐⭐**

Его можно считать «мягкой» версией **NRU**, так как он тоже использует бит R для принятия решения, но делает это в рамках строгой очереди. В отличие от NRU, который может выбрать любую страницу класса 0 случайно, Second Chance всегда ищет **самую старую** страницу, у которой нет признаков недавнего обращения.

---

#### **В каких условиях Second Chance вырождается по поведению почти в FIFO? ⭐⭐**

Алгоритм вырождается в FIFO в условиях **экстремально высокой активности**, когда ко всем страницам в памяти происходит обращение в каждом цикле проверки. В этом случае у всех страниц бит R всегда будет равен 1. ОС будет просто по кругу сбрасывать эти биты и переносить страницы в конец очереди, пока не вернется к самой первой, у которой бит станет 0 (если к ней не успели обратиться снова), и выселит её точно так же, как это сделал бы FIFO.

---

#### **Какие накладные расходы появляются у Second Chance по сравнению с FIFO и от чего они зависят? ⭐⭐⭐**

Накладные расходы включают:

1. **Манипуляции со списком:** необходимость часто перемещать узлы из начала в конец очереди.
2. **Проверка битов:** необходимость сканировать биты R в таблице страниц при каждой ошибке. Расходы зависят от **частоты page faults** и от того, как много страниц получают «второй шанс» — чем больше активных страниц, тем длиннее будет поиск «жертвы» по списку. Для минимизации этих расходов был разработан **алгоритм Clock**.