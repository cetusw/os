#### **Почему у каждого ядра свой набор управляющих регистров (CR0/CR3/IDTR и др.), и какие преимущества это даёт ОС? ⭐⭐**

Независимость регистров позволяет каждому ядру иметь собственный **контекст исполнения**. Это дает ОС возможность запускать на разных ядрах потоки разных процессов с разными таблицами страниц (разные **CR3**) или даже работать в разных режимах (одно ядро с paging, другое — без) в процессе загрузки.

#### **Как возможно, что одно ядро уже работает с PG=1, а другое — ещё с PG=0, и почему это важно при загрузке? ⭐⭐⭐**

После включения питания активным становится только **BSP (Bootstrap Processor)**, который первым инициализирует систему и включает paging. Остальные ядра (**AP**) в это время «спят» и пробуждаются позже в реальном режиме с **PG=0**. Это позволяет BSP подготовить все необходимые системные таблицы в памяти до того, как остальные ядра начнут их использовать.

#### **Почему paging включается каждым ядром отдельно, даже если ОС «одна»? ⭐⭐**

Поскольку бит **PG** находится в локальном регистре **CR0**, его установка влияет только на конкретное ядро. Каждое ядро должно самостоятельно активировать механизм трансляции, чтобы его внутренний MMU начал использовать таблицы страниц для преобразования адресов.

#### **Какие ошибки синхронизации могут возникнуть, если разные ядра имеют «разный взгляд» на память в раннем бутстрапе? ⭐⭐⭐**

Если одно ядро изменит запись в таблице страниц, а другое ядро не обновит свой **TLB**, возникнет ситуация несогласованности: ядра будут видеть разные данные по одному и тому же виртуальному адресу. Это может привести к повреждению данных или нарушению прав доступа.

#### **Объясните роль bootstrap-ядра (BSP): что именно оно обязано подготовить для остальных ядер? ⭐⭐⭐**

BSP обязан подготовить критическую инфраструктуру: инициализировать ОЗУ, создать **глобальную таблицу дескрипторов (GDT)**, **таблицу прерываний (IDT)** и **таблицы страниц**. Также BSP загружает основной код ядра ОС и рассылает сигналы пробуждения остальным ядрам.

#### **Почему после включения питания активным становится только BSP, а остальные ядра «спят»? ⭐⭐**

Это аппаратное ограничение, предназначенное для предотвращения хаоса при загрузке: если бы все ядра начали исполнять код одновременно из одной точки, возникли бы неуправляемые **состояния гонки** за общие ресурсы системы еще до того, как ОС успела бы настроить механизмы синхронизации.

#### **Что такое INIT IPI и SIPI, и почему требуется два разных сигнала для пробуждения AP? ⭐⭐**

- **INIT IPI** — это сигнал сброса ядра AP в начальное состояние.
- **SIPI (Startup IPI)** — это сигнал, указывающий физический адрес (вектор), с которого AP должно начать выполнение кода. Два сигнала нужны для надежного перевода ядра из состояния глубокого сна в режим исполнения по конкретному адресу.

#### **Почему адрес старта AP (в SIPI) должен быть < 1 МБ и как это связано с реальным режимом? ⭐⭐⭐**

Ядра AP всегда пробуждаются в **реальном режиме** (16-битном), где адресация ограничена первым мегабайтом памяти. Формула адреса в SIPI ($vector \times 4$ КБ) спроектирована так, чтобы точка входа всегда попадала в этот диапазон.

#### **Какие задачи должен выполнить BSP до пробуждения AP, чтобы те могли корректно стартовать? ⭐⭐**

BSP должен разместить в нижней памяти (ниже 1 МБ) специальный **bootstrap-код для AP**, настроить флаги готовности и подготовить указатели на общие структуры данных (GDT, таблицы страниц), чтобы AP могли быстро перейти в защищенный режим и включить paging.

#### **Что произойдёт, если AP начнёт исполнять код без корректно настроенного стека? ⭐⭐⭐**

Любая попытка выполнить инструкцию `CALL`, `PUSH` или дождаться прерывания приведет к краху, так как у процессора не будет валидного места в памяти для сохранения адреса возврата или регистров. AP обязан настроить свой **локальный стек** в самом начале исполнения своего bootstrap-кода.

#### **Опишите, в каком режиме находится AP сразу после SIPI и как формируется адресация в этот момент? ⭐⭐**

AP находится в **реальном режиме**. Адреса формируются по классической формуле: $Linear = Segment \times 16 + Offset$. Регистры сегментов инициализированы на основе вектора из сигнала SIPI.

#### **Почему у AP после пробуждения paging отключён и что это означает для доступа к памяти? ⭐⭐**

Paging отключен, так как регистр **CR0** сбрасывается в начальное состояние ($PG=0$). Это означает, что AP работает напрямую с **физическими адресами** и может исполнять только тот код, который BSP подготовил в физической памяти.

#### **Какие шаги должен выполнить bootstrap-код AP, чтобы привести ядро к общему «режиму ОС»? ⭐⭐⭐**

1. Перейти в **Protected Mode** (установить $CR0.PE=1$).
2. Загрузить **GDT** и **IDT**.
3. Загрузить адрес таблиц страниц в **CR3** и включить **Paging** ($CR0.PG=1$).
4. Настроить собственный стек и выполнить синхронизацию с BSP.

#### **Почему bootstrap-код AP обычно размещают в низкой памяти (например, 0x7000–0x8000)? ⭐⭐**

Потому что в момент старта AP находится в реальном режиме и может адресовать только **нижнюю память** (ниже 1 МБ). Адрес 0x7000 является стандартным и безопасным местом, которое гарантированно доступно AP сразу после SIPI.

#### **Как вы организовали бы синхронизацию AP с BSP? ⭐⭐⭐**

Синхронизация обычно строится на **флагах готовности** в общей памяти. BSP ждет, пока каждый AP не установит свой бит в переменной `ready_mask`, а AP ждут сигнала от BSP перед тем, как перейти к запуску основного планировщика задач.

#### **Почему «после инициализации все ядра равноправны», и что остаётся общим ресурсом? ⭐⭐**

После того как все ядра вошли в режим ОС и включили paging, они становятся **равноправными участниками** системы, способными исполнять любые задачи. Общими ресурсами остаются **физическая память**, системные шины и общая таблица страниц (для kernel space), несмотря на наличие у каждого ядра собственных регистров и кэшей.