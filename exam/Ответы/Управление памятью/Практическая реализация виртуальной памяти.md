#### **Какие задачи по памяти решает ОС на этапе создания процесса (таблицы страниц, swap, инициализация)? ⭐⭐**
1.  Создание и инициализация таблицы страниц.
2.  Выделение места в области подкачки (*swap*) для сегментов данных и стека.
3.  Заполнение записей в таблице страниц (пометка их как «находящихся на диске» в исполняемом файле).

#### **Почему код иногда подкачивается прямо из исполняемого файла, а не из swap, и что это даёт? ⭐⭐**
Код неизменяем. Нет смысла копировать его в *swap*, если он уже лежит в красивом виде в файле `program.exe`. Это экономит место в *swap* и ускоряет запуск.

#### **Что происходит при переключении процесса: роль MMU, загрузка указателя на таблицу страниц, очистка TLB и теги процессов. ⭐⭐⭐**
1.  Ядро сохраняет регистры старого процесса.
2.  Ядро загружает в специальный регистр CPU (например, `CR3` в x86) адрес таблицы страниц нового процесса.
3.  **MMU** теперь «видит» мир глазами нового процесса.
4.  **TLB:** Старые записи становятся неверными. Либо TLB полностью очищается (*flush*), либо, если процессор поддерживает *ASID* (теги процессов), записи просто игнорируются, пока мы не вернемся в нужный процесс.

#### **Что такое prepaging и когда он помогает, а когда может навредить? ⭐⭐⭐**
Это попытка ОС предугадать, какие страницы понадобятся процессу, и загрузить их до того, как случится *page fault*.
*   **Помогает:** При запуске процесса или возвращении его из свопа (загружаем сразу всё рабочее множество).
*   **Вредит:** Если предсказание неверно, мы тратим время диска и RAM на данные, которые не будут использованы.

#### **Какие шаги выполняются при завершении процесса и почему shared pages усложняют освобождение ресурсов? ⭐⭐**
1.  Освобождение таблиц страниц.
2.  Освобождение места в *swap*.
3.  **Сложность с shared pages:** Нельзя просто удалить страницу кода, так как она может использоваться другими. Нужно проверять счетчики ссылок (см. выше).

#### **Почему page fault можно назвать “контролируемым прерыванием”, и что делает CPU/ОС на границе user/kernel? ⭐⭐**
Это «контролируемая авария». Процессор не может продолжить инструкцию, он делает «стоп», сохраняет состояние и передает управление ядру ОС. ОС исправляет ситуацию (грузит страницу) и незаметно для процесса возвращает его к жизни.

#### **Какие проверки прав доступа выполняются при page fault и почему “недопустимый адрес” ведёт к завершению процесса? ⭐⭐**
Ядро проверяет:
1.  Адрес вообще принадлежит этому процессу?
2.  Тип операции (запись в Read-Only)?
Если адрес «в никуда» (например, разыменование NULL), ОС не может «подкачать» данные, так как их не существует. Это нарушение защиты, и ОС шлет `SIGSEGV` (*Segmentation Fault*).

#### **Опишите полный пайплайн page fault (от ловушки до повторного выполнения инструкции) и укажите, где возможны блокировки на I/O. ⭐⭐⭐**
1.  Hardware: Trap в ядро.
2.  OS: Проверка адреса на валидность.
3.  OS: Поиск свободного кадра. (**Блокировка**, если надо вытеснять и писать на диск).
4.  OS: Чтение данных с диска в кадр. (**Блокировка** на время I/O).
5.  OS: Обновление таблицы страниц (бит *Present=1*).
6.  OS: Возврат в user-mode.
7.  Hardware: Повторное выполнение той же инструкции.

#### **Почему запись dirty-страницы перед вытеснением может приостановить процесс и как это влияет на планирование? ⭐⭐⭐**
Запись на диск длится вечность по меркам CPU (миллисекунды). Процесс, вызвавший *fault*, не может продолжаться. Планировщик переводит его в состояние *Wait* и отдает CPU другому процессу, чтобы не терять время.

#### **Как ОС гарантирует, что после page fault выполнение продолжится “как ни в чём не бывало”, сохраняя изоляцию процессов? ⭐⭐⭐**
ОС сохраняет абсолютно все регистры CPU и состояние конвейера (по возможности). Когда страница загружена, состояние восстанавливается так точно, что процесс даже «не знает», что его прерывали. Изоляция сохраняется, так как управление возвращается в то же виртуальное пространство.

#### **Почему возобновление инструкции после fault — отдельная сложная проблема, а не “просто повторить instruction”? ⭐⭐⭐**
Некоторые инструкции имеют «побочные эффекты». Если инструкция успела изменить часть регистров перед тем, как вызвала *page fault*, простой повтор приведет к двойному изменению.

#### **Как автоинкремент/автодекремент регистров усложняет откат или повтор инструкции, и чем опасна ошибка восстановления? ⭐⭐⭐**
Пример: `MOV (R1)+, R2`. Если ошибка страницы произошла при записи в `R2`, но `R1` уже увеличился на 4. Если просто повторить, мы прочитаем данные уже по адресу `R1+4`, а не по исходному.
*   **Опасность:** Порча данных, которую почти невозможно отследить.

#### **Какие виды аппаратной поддержки могут помочь ОС корректно возобновлять сложные инструкции? ⭐⭐⭐**
1.  **Скрытые регистры:** Которые хранят копии значений до начала инструкции.
2.  **Микрокод:** Который умеет «отматывать» состояние назад.
3.  **Аппаратный стек состояний:** Сохраняющий все изменения внутри одной инструкции.

#### **Объясните “баланс между сложностью процессора и нагрузкой на ОС” на примере механизма восстановления инструкций. ⭐⭐⭐**
*   **Сложный CPU (CISC):** Берет на себя весь откат состояний. ОС просто говорит «повтори». Это дорого в производстве.
*   **Простой CPU (RISC):** Может просто сказать ОС: «Я упал посередине инструкции, вот тебе список того, что я успел изменить, разбирайся сама». Это упрощает железо, но делает обработчик *page fault* в ОС невероятно сложным.