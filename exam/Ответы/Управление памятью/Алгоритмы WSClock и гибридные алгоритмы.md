#### **В чём ключевая идея WSClock и почему он считается удачным компромиссом точности и скорости? ⭐⭐⭐**

Ключевая идея **WSClock** — объединить точность алгоритма рабочего множества с эффективностью структуры **Clock** (циклического списка фреймов). Он считается удачным компромиссом, так как не требует сканирования всей таблицы страниц при каждой ошибке; вместо этого он проверяет страницы последовательно «стрелкой часов», используя критерии рабочего множества для выбора жертвы.

#### **Какие поля хранит запись о странице в WSClock (R, M, время последнего использования) и зачем каждое нужно? ⭐⭐**

- **Бит R (Referenced):** указывает на недавнее использование; используется для сброса и обновления времени.
- **Бит M (Modified/Dirty):** указывает, нужно ли записывать страницу на диск перед освобождением фрейма.
- **Время последнего использования:** необходимо для расчета возраста страницы и определения её принадлежности к рабочему множеству.

#### **Что происходит, если WSClock находит «старую» страницу, но она dirty? Почему важна асинхронная запись? ⭐⭐⭐**

Если страница старая (возраст $>\Delta$), но помечена как **грязная (dirty)**, алгоритм не может мгновенно освободить фрейм. Он инициирует (назначает) **асинхронную запись** на диск и двигает стрелку дальше в поисках «чистой» старой страницы. Асинхронность критична, чтобы не блокировать процесс обработки page fault ожиданием медленного диска, позволяя найти другую жертву быстрее.

#### **Опишите два сценария после полного обхода круга WSClock: когда были назначены записи и когда нет. ⭐⭐⭐**

1. **Записи были назначены:** алгоритм продолжает вращение, пока не встретит страницу, запись которой на диск уже завершилась (она стала чистой), и выселяет её.
2. **Записи не были назначены:** это означает, что **все** страницы находятся в рабочем множестве. В этом случае ОС вынуждена выбрать любую чистую страницу (или текущую, предварительно дождавшись её записи), чтобы освободить место.

#### **Почему WSClock обычно уменьшает I/O по сравнению с простыми схемами, даже при высокой нагрузке? ⭐⭐⭐**

Благодаря учету рабочего множества и **отложенным записям** (алгоритм старается сначала найти чистую старую страницу), WSClock минимизирует количество экстренных записей на диск непосредственно в момент обработки ошибки страницы. Он эффективно использует фоновое время для очистки страниц через **paging daemon**.

#### **Почему современные ОС почти никогда не используют «чистые» алгоритмы, а строят гибриды (Clock/LRU/Working Set)? ⭐⭐⭐**

Чистые алгоритмы часто имеют «слабые места» в специфических сценариях. Современные ОС (Windows, Linux) используют гибриды, чтобы сочетать **скорость** циклического обхода (Clock) с **адаптивностью** к нагрузке (Working Set) и **точностью** истории использования (LRU). Это позволяет системе быть устойчивой как к последовательному сканированию данных, так и к фазовым переходам программ.

#### **Зачем Linux разделяет страницы на файловые и анонимные (split LRU), и почему их нужно вытеснять по-разному? ⭐⭐⭐**

- **Файловые страницы:** подкреплены файлами на диске (код, mmap). Их вытеснение «дешевле», так как чистые страницы можно просто отбросить.
- **Анонимные страницы:** это данные процесса (стек, куча), не имеющие копии на диске. Для их выселения **обязательно** требуется место в swap. Разделение (**split LRU**) позволяет ОС применять разные приоритеты: например, активнее вытеснять файловый кэш, чтобы сохранить в памяти критически важные данные приложений.

#### **Как бы вы объяснили, почему политика замещения страниц тесно связана с подсистемой ввода-вывода и кэшированием файлов? ⭐⭐⭐**

Замещение страниц — это всегда компромисс с производительностью диска. Почти любая выгрузка данных (особенно dirty-страниц) порождает I/O-трафик. Более того, современная ОС использует одну и ту же физическую память и для виртуальных страниц процессов, и для **кэширования дисковых блоков (Page Cache)**, поэтому менеджер памяти должен балансировать ресурсы между ними для минимизации общего времени ожидания I/O.

#### **Какие компромиссы возникают между справедливостью между процессами и глобальной оптимизацией page faults? ⭐⭐⭐**

- **Локальная политика (справедливость):** выделяет процессам фиксированные квоты. Это изолирует их (один процесс не «съест» память другого), но неэффективно, если одному процессу память нужнее, чем другому.
- **Глобальная политика (оптимизация):** отбирает страницы у любого процесса. Это дает лучший общий throughput системы, но может привести к тому, что один «прожорливый» процесс вызовет thrashing у всех остальных.

#### **Как бы вы спроектировали эксперимент, чтобы честно сравнить FIFO, Clock, Aging и WSClock на одной рабочей нагрузке? ⭐⭐⭐**

1. **Подготовка трассы:** собрать реальную последовательность (лог) обращений к страницам для конкретной программы.
2. **Симуляция:** запустить на этой трассе программные модели всех четырех алгоритмов.
3. **Варьирование параметров:** измерять количество page faults при разном объеме доступной физической памяти (от 10% до 100% от нужд программы).
4. **Метрики:** сравнить не только число ошибок, но и объем дисковых записей (учет dirty-бита) и вычислительную сложность (количество итераций алгоритма на одну ошибку).