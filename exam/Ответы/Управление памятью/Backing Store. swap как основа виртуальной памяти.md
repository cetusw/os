#### **Что такое backing store и почему без него виртуальная память теряет смысл (в общем случае)? ⭐⭐**
**Backing store** (резервное хранилище) — это место на диске, где хранятся страницы, не поместившиеся в RAM.
**Смысл:** Без него мы не смогли бы высвобождать память. Виртуальная память превратилась бы просто в механизм защиты, но мы все равно были бы ограничены физическим объемом RAM.

#### **Чем swap-раздел отличается от swap-файла с точки зрения адресации и управления блоками? ⭐⭐**
*   **Swap-раздел:** Сырые блоки диска. ОС сама управляет ими, адресация прямая («блок №1000»). Это быстрее.
*   **Swap-файл:** Находится внутри файловой системы. ОС должна сначала спросить у ФС, где лежат блоки этого файла. Это медленнее, но гибче (файл легко создать/удалить).

#### **Почему отдельный swap-раздел может быть быстрее и проще для ОС, чем файл подкачки? ⭐⭐**
Нет накладных расходов файловой системы (индексов, метаданных). ОС точно знает, что блоки раздела расположены последовательно, что минимизирует движения головок диска (seek time).

#### **В чём ограничение “классической схемы”, где процессу выделяют фиксированное место в swap заранее? ⭐⭐**
При создании процесса ОС сразу бронирует на диске место, равное его максимальному размеру.
**Ограничение:** Если у вас 10 процессов по 1 ГБ, вам нужно 10 ГБ на диске, даже если процессы реально используют по 10 МБ. Это нерациональное использование диска.

#### **Почему в фиксированной схеме сложно поддержать рост стека/данных процесса? ⭐⭐⭐**
Потому что место на диске выделено непрерывным блоком. Если стек вырос, а «соседний» блок на диске занят swap-ом другого процесса, расширяться некуда. Придется переносить весь swap процесса в новое место.

#### **Объясните идею разделения swap по областям (код/данные/стек). Какие плюсы это даёт? ⭐⭐⭐**
*   **Плюс:** Код не нужно писать в swap (он есть в исполняемом файле). Данные и стек — нужно.
*   **Плюс:** Можно использовать разные стратегии. Стек растет часто — его лучше держать в быстрых блоках. Данные меняются редко — их можно выпихнуть подальше.

#### **Что означает динамическая модель: “страница получает место в swap только при выгрузке”? ⭐⭐**
ОС не бронирует место заранее. Когда алгоритму замещения нужно выкинуть страницу, он только в этот момент ищет свободный блок на диске и записывает её туда.

#### **Почему динамическая модель экономит место на диске, но усложняет управление? ⭐⭐**
*   **Экономия:** Место тратится только под реально вытесненные данные.
*   **Сложность:** ОС должна вести сложную таблицу (disk map), чтобы помнить, какая виртуальная страница в какой блок диска улетела.

#### **Что такое disk map и какие данные он должен хранить, чтобы динамический swap работал корректно? ⭐⭐⭐**
Это структура данных ядра, отображающая пары `<Процесс, Виртуальная страница>` -> `<Номер блока на диске>`. Без неё при возникновении *page fault* ОС не поймет, откуда именно на диске забирать данные.

#### **Какие типы страниц обычно не нужно сохранять в swap (например, код программы/библиотеки) и почему? ⭐⭐**
Код программ и разделяемые библиотеки. Они **Read-Only**. Если нам нужна память, мы просто удаляем их из RAM. Если они понадобятся снова, мы просто прочитаем их из оригинального файла на диске. Это экономит время (не надо писать) и место в swap.

#### **Почему выгрузка кода и библиотек “без сохранения” может ускорить систему и уменьшить swap? ⭐⭐**
Запись на диск — самая медленная операция. Исключая запись кода, мы ускоряем процесс освобождения памяти в два раза.

#### **Как наличие memory-mapped файлов меняет роль swap и понятие “резервного хранилища”? ⭐⭐⭐**
Для данных в `mmap` сам файл становится «свопом». Это разгружает системный swap-раздел, так как измененные страницы файла пишутся в сам файл, а не в общую свалку подкачки.

#### **Сформулируйте принцип разделения политики и механизма применительно к подкачке страниц. ⭐⭐**
*   **Механизм:** То, *как* страница переносится (работа с MMU, запись на диск). Находится в ядре.
*   **Политика:** То, *какую* страницу выбрать (LRU, FIFO, частота). Может быть вынесена в отдельный модуль.

#### **Почему такой принцип повышает модульность и переносимость ОС? ⭐⭐**
Можно менять алгоритм замещения страниц под конкретные нужды (например, для базы данных или для мобилки) без переписывания сложного кода управления железом.

#### **Опишите архитектуру Mach: какие роли выполняют MMU handler, page fault handler и external pager? ⭐⭐⭐**
*   **MMU handler:** Минимальный код в ядре, ловящий прерывание.
*   **Page fault handler:** Код в ядре, который понимает, какой адрес нужен.
*   **External pager:** Пользовательский процесс, который решает, откуда взять данные (с диска, из сети) и сообщает ядру: «Вот кадр, положи его сюда».

#### **Как выглядит обработка page fault в Mach, если политика вынесена во внешний пейджер? ⭐⭐⭐**
1. Происходит fault.
2. Ядро посылает сообщение внешнему пейджеру.
3. Пейджер находит данные.
4. Пейджер вызывает системный вызов, отдавая данные ядру.
5. Ядро мапит данные в процесс и пробуждает его.

#### **Почему “идеально” было бы реализовать алгоритм замещения во внешнем пейджере? ⭐⭐**
Потому что пейджер может лучше знать специфику данных (например, что это видеопоток и его не надо кэшировать). Это разгружает ядро.

#### **Почему внешний пейджер не может напрямую реализовать LRU “как в учебнике”? (роль R/M битов) ⭐⭐⭐**
Потому что биты обращения (R) и модификации (M) находятся в таблицах страниц, к которым у пользовательского процесса (пейджера) нет доступа по соображениям безопасности. Пейджер «слеп» по отношению к активности процессора.

#### **Какие компромиссы возможны: ядро передаёт статистику или оставляет алгоритм замещения внутри себя? ⭐⭐⭐**
Ядро может периодически сбрасывать статистику использования страниц внешнему пейджеру, но это создает огромный поток сообщений (overhead). Чаще всего алгоритм замещения оставляют в ядре, а пейджер отвечает только за доставку данных.

#### **Почему обмен сообщениями между ядром и external pager снижает производительность? ⭐⭐**
Переключение контекста между ядром и процессом-пейджером при каждом *page fault* требует тысяч тактов CPU. Это в разы медленнее, чем обработка внутри ядра.

#### **Какие современные аналоги идеи внешнего управления page fault существуют (например, пользовательские обработчики событий), и зачем они нужны? ⭐⭐⭐**
Например, `userfaultfd` в Linux. Нужно для:
*   Виртуализации (миграция виртуалки между серверами в реальном времени).
*   Сборки мусора в высоконагруженных языках (Java/Go) с минимальными паузами.
