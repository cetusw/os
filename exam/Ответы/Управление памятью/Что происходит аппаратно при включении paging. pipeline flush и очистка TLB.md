#### **Почему при включении paging процессор выполняет pipeline flush, и что именно было бы «опасным» без этого шага? ⭐⭐⭐**

При установке бита **PG** в регистре **CR0** процессор автоматически выполняет **сброс конвейера (pipeline flush)**. Это необходимо, потому что конвейер содержит инструкции, которые уже были выбраны и декодированы на основе **старой модели адресации (физической)**. Без этого шага процессор попытался бы исполнить инструкции, чьи адреса операндов или переходов интерпретировались бы неверно в новом виртуальном режиме, что привело бы к непредсказуемому поведению или краху системы.

#### **Каким образом уже декодированные инструкции в конвейере могут стать некорректными после смены модели адресации? ⭐⭐⭐**

Инструкции в конвейере могут содержать абсолютные адреса, которые в физическом режиме указывали на конкретные ячейки памяти. После включения страничной адресации **все адреса становятся виртуальными** и требуют трансляции через MMU. Если инструкция была подготовлена для работы с физическим адресом $X$, а после включения paging этот адрес стал интерпретироваться как виртуальный, он может указывать на совершенно другие данные или даже на отсутствующую страницу.

#### **Почему при включении paging очищается TLB, и какие последствия были бы, если бы старые трансляции сохранились? ⭐⭐**

Очистка **TLB** необходима, так как этот кэш хранит старые сопоставления «виртуальный адрес — физический адрес», которые более не актуальны или вовсе отсутствовали в физическом режиме. Если бы старые записи сохранились, процессор мог бы использовать **неверные трансляции** или биты защиты, что привело бы к доступу к чужой памяти или возникновению ложных исключений.

#### **Объясните, почему «следующая инструкция выполняется уже по виртуальному адресу» и какие гарантии нужны, чтобы она действительно была доступна. ⭐⭐⭐**

Сразу после активации бита **PG** механизм трансляции включается для каждой последующей операции выборки. Чтобы процессор «не потерял» текущий поток исполнения, ОС обязана обеспечить **identity mapping** (тождественное отображение) — состояние, при котором виртуальный адрес следующей инструкции в точности совпадает с её физическим адресом. Это гарантирует непрерывность выполнения кода в момент перехода.

#### **Какие дополнительные аппаратные события (кроме TLB flush и pipeline flush) вы ожидаете при переходе в новый режим памяти? ⭐⭐⭐**

Помимо сброса конвейера и TLB, процессор начинает использовать значение из регистра **CR3** как физический адрес корневой таблицы страниц для выполнения **page walk** (обхода таблиц) при каждом промахе кэша трансляции. Также активируются проверки битов защиты (R/W, NX, U/S) в записях таблиц страниц при каждом обращении к памяти.

#### **Какие страницы ОС обязательно должна отобразить identity-mapping’ом, чтобы «не потерять себя» после включения paging? ⭐⭐⭐**

ОС должна отобразить как минимум те страницы, в которых находится **текущий исполняемый код** (bootstrap-код) и структуры данных, к которым этот код обращается сразу после переключения. Если этот «мостик» не будет создан, первая же попытка выбрать следующую инструкцию после `mov cr0, eax` вызовет **page fault**, так как MMU не сможет найти отображение для текущего адреса в памяти.

#### **Почему page fault сразу после включения paging особенно опасен, и как identity mapping помогает его избежать? ⭐⭐**

Это опасно тем, что обработчик **page fault** сам может оказаться не отображен в виртуальной памяти, что приведет к **double fault** и немедленной перезагрузке системы. **Identity mapping** гарантирует, что адреса кода загрузчика остаются валидными и неизменными при смене режима, позволяя ОС безопасно перейти к настройке полноценных адресных пространств.

#### **Какие недостатки и риски несёт слишком долгоживущий identity mapping? ⭐⭐⭐**

Долгоживущий identity mapping ограничивает гибкость использования виртуальной памяти, так как «закрепляет» определенные виртуальные адреса за конкретными физическими фреймами. Это может привести к конфликтам с адресным пространством пользователя или усложнить изоляцию ядра. Поэтому после успешного старта ОС обычно избавляется от этой временной карты.

#### **Почему после успешного старта ОС обычно меняет схему отображения (kernel space / user space) и избавляется от временной карты? ⭐⭐**

Это делается для обеспечения **безопасности и изоляции**: ядро переносится в верхние адреса (kernel space), доступные только в режиме супервизора, а нижние адреса выделяются под пользовательские процессы (user space). Удаление временной карты identity mapping освобождает адреса и предотвращает случайный доступ программ к физическим структурам загрузки.

---