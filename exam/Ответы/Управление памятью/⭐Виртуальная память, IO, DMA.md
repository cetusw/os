#### **Почему виртуальную память нельзя рассматривать “в изоляции” от ввода-вывода в реальной ОС? ⭐⭐**
Потому что эти подсистемы используют один и тот же физический ресурс — **оперативную память (RAM)**. Виртуальная память управляет тем, *где* данные лежат в RAM, а подсистема I/O управляет тем, как данные *попадают* в RAM из внешних устройств и обратно. Если они не будут скоординированы, алгоритм замещения страниц может «выкинуть» страницу именно в тот момент, когда контроллер диска пытается записать в неё данные.

#### **Опишите типичный сценарий: процесс делает read() в пользовательский буфер и блокируется. Какие риски для страниц этого буфера появляются, пока CPU выполняет другие процессы? ⭐⭐**
1. Процесс А вызывает `read(fd, buffer, size)`. Буфер находится на виртуальной странице $X$.
2. Страница $X$ отображена на физический кадр $F$.
3. Процесс А блокируется, ожидая данные с диска.
4. В это время процессу Б не хватает памяти. Алгоритм замещения (например, LRU) видит, что кадр $F$ давно не использовался (ведь процесс А спит).
5. ОС выгружает страницу $X$ в swap, а кадр $F$ отдает процессу Б.
6. **Риск:** Когда контроллер диска закончит чтение для процесса А, он запишет данные в кадр $F$, который теперь принадлежит процессу Б. Произойдет порча памяти процесса Б.

#### **Почему глобальная политика замещения повышает вероятность конфликтов между I/O и заменой страниц по сравнению с локальной? ⭐⭐**
В локальной политике процесс конкурирует сам с собой. Если он заблокирован на I/O, его страницы вряд ли будут выбраны «жертвами» (если только сам процесс не фолтит в другом потоке). В **глобальной политике** любой активный процесс может «украсть» кадр у заблокированного процесса, так как для алгоритма замещения страницы спящего процесса выглядят самыми «старыми» и неиспользуемыми.

#### **Какие события в системе могут привести к тому, что страница пользовательского буфера станет кандидатом на вытеснение во время I/O? ⭐⭐**
*   Запуск нового «тяжелого» процесса, требующего много RAM.
*   Активная работа другого процесса, вызывающая нехватку свободных кадров.
*   Срабатывание фонового демона очистки страниц (*paging daemon*), который ищет неиспользуемые страницы для поддержания резерва чистых кадров.

#### **Чем отличается I/O “в память процесса” от I/O “в буфер ядра” с точки зрения управления страницами и безопасности данных? ⭐⭐**
*   **В память процесса:** Данные идут напрямую в адресное пространство юзера. Это быстрее (нет лишнего копирования), но требует защиты/блокировки страниц процесса от вытеснения.
*   **В буфер ядра:** Устройство пишет в «безопасную» зону памяти, которая никогда не выгружается в swap. Затем ОС копирует данные пользователю. Это безопаснее и проще, но медленнее из-за лишней работы CPU по копированию байтов.

#### **Какие требования к ОС возникают из-за того, что I/O может длиться долго, а алгоритм замещения работает постоянно? ⭐⭐⭐**
ОС обязана иметь механизм **взаимного исключения** или **оповещения** между подсистемой I/O и менеджером памяти. Менеджер памяти должен знать, что страница «занята» операцией ввода-вывода и её нельзя трогать, пока устройство не пришлет прерывание о завершении.

#### **Почему задача “защитить буфер во время I/O” — это часть дизайна системы замещения страниц, а не отдельная оптимизация? ⭐⭐⭐**
Потому что если это не предусмотреть на уровне архитектуры, система будет принципиально нестабильной (недетерминированные краши при высокой нагрузке). Это базовое условие корректности: алгоритм выбора «жертвы» должен проверять состояние «заблокировано для I/O» прежде чем принимать решение.

#### **Что такое DMA и почему он радикально меняет роль CPU в передаче данных? ⭐**
**DMA (Direct Memory Access)** — прямой доступ к памяти. Это аппаратный контроллер, который умеет пересылать данные между устройством и RAM самостоятельно.
**Роль CPU:** Раньше CPU сам читал каждый байт из порта и писал в память (программный ввод-вывод). С DMA процессор просто говорит: «Скопируй 10 МБ с диска по этому адресу RAM» и идет заниматься другими делами. Роль CPU сменилась с «грузчика» на «менеджера».

#### **Почему DMA особенно важен при больших объёмах данных (диск, сеть, видео), а не только “для скорости вообще”? ⭐⭐**
Потому что без DMA при передаче данных на скорости 10 Гбит/с или при проигрывании 4K-видео процессор был бы занят на 100% только перекладыванием байтов из регистра в память, не оставляя времени на работу самой программы или ОС.

#### **Объясните, почему DMA создаёт принципиальную опасность при вытеснении страниц, даже если алгоритм замещения “правильный”. ⭐⭐⭐**
Контроллер DMA оперирует **физическими адресами**. Он не знает о существовании таблиц страниц и MMU. Если ОС решит, что страница «старая», и отдаст её физический кадр другому процессу, контроллер DMA «не заметит» подвоха и продолжит писать данные по старому физическому адресу, повреждая память нового владельца кадра.

#### **Что именно может произойти, если страница буфера выгружается во время DMA (опишите сценарий частичной записи и повреждения данных)? ⭐⭐⭐**
1. DMA начинает писать блок данных (4 КБ) в физический кадр $F$.
2. На середине процесса (записано 2 КБ) ОС вытесняет страницу и отдает кадр $F$ под таблицу дескрипторов другого процесса.
3. DMA записывает оставшиеся 2 КБ.
4. **Итог:** Половина кадра содержит «мусор» (данные I/O), затерев критические системные данные другого процесса. При попытке обращения к ним система упадет в Kernel Panic или выдаст непредсказуемую ошибку.

#### **Почему такая ошибка может проявляться как “случайная порча памяти” и быть крайне трудной для отладки? ⭐⭐⭐**
Потому что это состояние гонки (*race condition*). Ошибка возникает только тогда, когда запрос на память от одного процесса совпадает по времени с миллисекундным окном работы DMA для другого. Это случается редко, не воспроизводится стабильно и проявляется в случайных местах системы.

#### **Какой компонент (CPU/MMU/контроллер DMA/ядро ОС) “виноват” в том, что DMA не понимает виртуальные адреса? ⭐⭐**
«Виноват» дизайн архитектуры. DMA — это отдельное устройство на системной шине. Традиционно он подключается напрямую к контроллеру памяти, минуя MMU процессора. Поэтому он видит только «сырую» физическую RAM.

#### **Почему DMA работает с физическими адресами, и почему нельзя просто “дать ему виртуальные”? ⭐⭐**
Чтобы понимать виртуальные адреса, DMA-контроллеру пришлось бы иметь свою копию таблиц страниц или постоянно запрашивать трансляцию у MMU процессора, что усложнило бы железо и забило бы системную шину лишними запросами. *Примечание: современные IOMMU решают эту проблему, но классически DMA физичен.*

#### **Какие накладные расходы возникают, если отказаться от DMA и заставить CPU копировать данные вручную? ⭐⭐**
1.  **Загрузка CPU:** Процессор тратит циклы на каждую команду `MOV`.
2.  **Пропускная способность памяти:** Каждое слово данных проходит через CPU дважды (чтение из порта -> запись в RAM), что вдвое нагружает шину памяти.
3.  **Задержки:** Пока CPU занят копированием, он не может реагировать на прерывания.
