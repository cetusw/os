#### **Почему статическое связывание приводит к дублированию кода в памяти, даже если ядро поддерживает подкачку? ⭐⭐**
Потому что при статическом связывании код библиотеки (например, `printf`) физически вшивается в каждый исполняемый файл. Для ОС это разные куски данных в разных местах диска, она не понимает, что они идентичны, и загружает их в разные физические кадры.

#### **Опишите динамическое связывание: что такое “заглушки”, когда происходит связывание (при запуске/при первом вызове). ⭐⭐**
*   **Заглушки (stubs):** Маленькие куски кода в программе, которые говорят: «Я не знаю, где функция X, спроси у загрузчика».
*   **Связывание при запуске:** Загрузчик находит `.so` / `.dll` и прописывает реальные адреса в таблицу прыжков.
*   **Связывание при первом вызове (lazy binding):** Адрес ищется только тогда, когда программа реально вызвала функцию. Это ускоряет старт.

#### **Почему shared libraries дают выигрыш и по диску, и по RAM одновременно? ⭐⭐**
*   **Диск:** Код библиотеки хранится в одном файле на всю систему.
*   **RAM:** ОС загружает этот файл в память один раз и отображает его в адресные пространства всех процессов.

#### **Как shared libraries связаны с механизмом отображения файлов в память (mmap) на концептуальном уровне? ⭐⭐**
Общая библиотека — это просто файл, который ОС «проецирует» (*mmap*) в память каждого процесса. Механизм виртуальной памяти сам заботится о том, чтобы физически в RAM была только одна копия этого файла.

#### **Почему проблема адресации возникает, если библиотека может быть загружена по разным адресам в разных процессах? ⭐⭐**
В процессе А свободное место под библиотеку может быть с адреса 0x1000, а в процессе Б там уже занято, и её нужно грузить по адресу 0x5000. Если в коде библиотеки есть жесткий переход `JMP 0x1020`, в процессе Б он сработает неверно.

#### **Что такое position-independent code (PIC) и как относительная адресация решает проблему перемещения? ⭐⭐⭐**
**PIC** — это код, который не содержит абсолютных адресов.
*   **Решение:** Вместо «прыгни на адрес 0x1020», используется «прыгни на 20 байт вперед от текущего места» (`RIP-relative addressing`). Такой код работает одинаково, куда бы его ни «приклеили».

#### **Какие последствия для безопасности и обновлений даёт динамическая библиотека по сравнению со статической? ⭐⭐**
*   **Обновления:** Можно заменить один файл `libc.so`, и все программы в системе мгновенно начнут использовать исправленную версию (без перекомпиляции).
*   **Безопасность:** С одной стороны, легче закрыть уязвимость. С другой — подмена одной библиотеки может скомпрометировать всю систему.

#### **Что значит “файл отображается в виртуальное адресное пространство” и почему это меняет модель программирования? ⭐⭐**
Программист перестает использовать `read()` / `write()` и работу с буферами. Он просто получает указатель `char *ptr` на начало файла. Чтение из файла превращается в чтение из массива в памяти. Это намного проще и часто быстрее.

#### **Опишите, что происходит при первом обращении к отображённой странице файла (demand paging и page fault). ⭐⭐**
1.  Процесс читает адрес из области *mmap*.
2.  MMU видит, что страницы нет в RAM (*present bit = 0*).
3.  **Page fault**.
4.  ОС видит, что этот адрес привязан к файлу. Она находит нужный блок на диске, читает его в свободный кадр и обновляет таблицу страниц.
5.  Инструкция повторяется, данные теперь «в памяти».

#### **Как ОС использует файл как “резервное хранилище” для страниц и чем это отличается от swap? ⭐⭐⭐**
*   **Для mmap:** Резервным хранилищем является сам файл. При нехватке памяти ОС просто выбрасывает страницу (если она чистая) или пишет в исходный файл (если dirty).
*   **Отличие от swap:** Swap — это общая «свалка» для анонимных данных (стек, куча). Mmap работает с конкретным файлом-структурой.

#### **Почему memory-mapped I/O может быть быстрее, чем read/write, и когда может быть медленнее? ⭐⭐⭐**
*   **Быстрее:** Исключается лишнее копирование данных между буфером ядра и буфером пользователя.
*   **Медленнее:** На очень маленьких случайных доступах к файлу. Каждый *page fault* — это тяжелое прерывание. Обычный `read()` с системным кэшированием может быть эффективнее.

#### **Как обеспечивается запись изменений обратно в файл: что означает modified/dirty в этом контексте? ⭐⭐**
Если процесс изменил байт в отображенной памяти, страница становится *dirty*. ОС периодически (или по вызову `msync`) записывает все *dirty*-страницы обратно в файл на диск.

#### **Как два процесса могут использовать mmap одного файла как IPC: какие проблемы синхронизации/согласованности данных возникают? ⭐⭐⭐**
*   **Как IPC:** Оба процесса отображают один и тот же файл. Изменения, сделанные одним, мгновенно видны другому (через общий физический кадр).
*   **Проблемы:** Состояния гонки (*race conditions*). Нужно использовать мьютексы или семафоры в этой же области памяти, чтобы процессы не правили одно и то же одновременно.

#### **Почему shared libraries естественно реализуются через mmap, и что это даёт ОС? ⭐⭐**
Библиотека — это файл. Использование *mmap* позволяет ОС не грузить всю библиотеку целиком, а подкачивать только те функции, которые реально вызываются, экономя мегабайты RAM.
