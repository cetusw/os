#### **Какие проблемы остаются нерешёнными при base/limit, даже если изоляция процессов уже есть? ⭐⭐**

Хотя механизмы базового и ограничительного регистров обеспечивают защиту и простейшую релокацию, они не решают проблему **ограниченности физической памяти**. Современные программы могут занимать гигабайты пространства, что значительно превышает доступный объём ОЗУ в расчёте на один процесс при одновременной работе многих приложений. Кроме того, схема base/limit требует размещения процесса в памяти **единым непрерывным блоком**, что затрудняет эффективное использование ресурсов при сильной фрагментации.

---

#### **Почему рост размеров программ и желание держать «десятки программ открытыми» приводит к необходимости виртуальной памяти? ⭐⭐**

Программы растут в объёме быстрее, чем увеличивается ёмкость памяти. Поскольку пользователям необходимо держать открытыми множество ресурсоёмких приложений (браузеры, игры, редакторы), суммарные требования к памяти часто **превышают её физический объём**. Виртуальная память решает эту проблему, позволяя системе держать в ОЗУ только **активные части** программ, в то время как остальные хранятся на диске, создавая иллюзию обладания огромным ресурсом.

---

#### **Чем swapping принципиально отличается от виртуальной памяти с точки зрения гранулярности перемещения данных? ⭐⭐**

Принципиальное различие заключается в **объёме перемещаемых данных**:

- **Swapping (свопинг)** оперирует процессом целиком: для запуска программы её нужно полностью загрузить в ОЗУ, а при нехватке места — полностью выгрузить на диск.
- **Виртуальная память** имеет гораздо более мелкую гранулярность: она делит программу на небольшие фрагменты — **страницы** (обычно по 4 КБ) — и перемещает их между диском и памятью по отдельности, только по мере необходимости.

---

#### **Почему важно, что виртуальная память позволяет не блокировать систему целиком на долгих I/O-операциях (в сравнении с «грубыми» схемами)? ⭐⭐⭐**

В «грубых» схемах вроде свопинга ожидание загрузки всего процесса с диска занимает огромное количество времени процессора, в течение которого выполнение задачи невозможно. Виртуальная память позволяет реализовать **подкачку по требованию**: когда одному процессу требуется загрузка страницы с диска (возникает page fault), ОС приостанавливает только этот поток, позволяя другим процессам продолжать вычисления. Это значительно повышает **отзывчивость и общую пропускную способность** системы.

---

#### **Что такое overlays и почему в 1960-х их делали вручную? ⭐⭐**

**Overlays (оверлеи)** — это части программы, которые поочередно загружались в одну и ту же область памяти по мере необходимости. В 1960-х годах их приходилось делать вручную, потому что в операционных системах того времени **отсутствовали автоматизированные механизмы** управления виртуальной памятью. Программист должен был самостоятельно разбивать код на логические куски и писать команды для их подгрузки и выгрузки.

---

#### **Какие типичные ошибки возникали при ручном разбиении программы на overlays и управлении их подгрузкой? ⭐⭐⭐**

Ручное управление оверлеями было крайне сложным и чреватым ошибками процессом. Типичные проблемы включали **некорректное перекрытие** нужных частей кода, когда одна фаза программы случайно затирала данные, необходимые для другой, а также ошибки в логике вызова подпрограмм, находящихся в не подгруженных в данный момент сегментах. Это часто приводило к трудноотлаживаемым сбоям и нестабильности ПО.

---

#### **Почему overlays замедляли разработку и сопровождение программ, даже если экономили память? ⭐⭐**

Несмотря на экономию ОЗУ, оверлеи превращали разработку в кошмар, так как программист тратил больше времени на **планирование размещения кода**, чем на саму алгоритмическую часть. Любое изменение в программе (например, добавление новой функции) могло увеличить размер одного из сегментов, что требовало **полной переделки** всей структуры разбиения оверлеев и связей между ними.

---

#### **Какие идеи overlays «перекочевали» в современную виртуальную память, но уже автоматизированно? ⭐⭐⭐**

Главная идея оверлеев — **нахождение в памяти только тех частей программы, которые нужны прямо сейчас** — стала фундаментом современной виртуальной памяти. Механизмы разделения кода на фрагменты и их подкачки с диска в те же области памяти (фреймы) сохранились, но теперь этим занимается **ОС совместно с аппаратным MMU**, полностью освобождая программиста от рутинного управления ресурсами.

---

#### **Сформулируйте идею виртуальной памяти: что именно является «иллюзией» и за счёт чего она создаётся? ⭐⭐**

Идея виртуальной памяти заключается в предоставлении каждому процессу собственного изолированного **адресного пространства**, которое может быть намного больше физической ОЗУ. **Иллюзией** является представление программы о том, что она владеет огромным, непрерывным и быстрым массивом памяти. Эта иллюзия создаётся за счёт автоматического **отображения виртуальных адресов** в физические фреймы или на дисковое пространство, выполняемого прозрачно для программиста.

---

#### **Почему деление адресного пространства на страницы фиксированного размера упрощает управление памятью? ⭐⭐**

Использование страниц фиксированного размера (обычно 4 КБ) позволяет ОС избавиться от **внешней фрагментации**, так как любой свободный физический фрейм может принять любую виртуальную страницу. Это радикально упрощает алгоритмы выделения ресурсов: менеджеру памяти больше не нужно искать «дыру» строго определённого размера, достаточно просто вести **список свободных фреймов**.

---

#### **Как MMU участвует в преобразовании виртуального адреса в физический, и почему без аппаратной поддержки это было бы слишком медленно? ⭐⭐⭐**

**MMU (Memory Management Unit)** — это блок процессора, который на лету перехватывает виртуальный адрес и с помощью таблиц страниц заменяет его номер на номер физического фрейма. Без аппаратной поддержки ОС пришлось бы выполнять **несколько программных инструкций** (чтение таблиц, арифметика) при каждом (!) обращении к памяти, что замедлило бы работу компьютера в сотни раз. Аппаратный кэш **TLB** внутри MMU позволяет делать это почти мгновенно.

---

#### **Что такое page frame и почему он должен быть того же размера, что и страница? ⭐⭐**

**Page frame (страничный фрейм)** — это блок фиксированного размера в физической оперативной памяти. Фрейм обязан иметь тот же размер, что и виртуальная страница, чтобы отображение было максимально простым: при трансляции адреса MMU просто заменяет старшие биты (номер страницы) на номер фрейма, оставляя **младшие биты (смещение)** без изменений.

---

#### **Объясните механизм page fault: что его вызывает и какие шаги выполняет ОС после возникновения. ⭐⭐⭐**

**Page fault** вызывается попыткой программы обратиться к странице, у которой в таблице страниц бит присутствия установлен в 0 (страница на диске). **Шаги ОС:**

1. Ловушка (trap) передаёт управление ядру.
2. ОС сохраняет состояние прерванного процесса.
3. Определяется нужный виртуальный адрес и местоположение страницы на диске.
4. Ищется свободный фрейм (при необходимости вытесняется старая страница).
5. Инициируется чтение данных с диска в найденный фрейм.
6. Таблица страниц обновляется (бит присутствия становится 1).
7. Процесс возобновляется с повторного выполнения той же инструкции.

---

#### **Почему виртуальная память позволяет запускать программы, размер которых больше физической RAM? ⭐⭐**

Это возможно потому, что для работы программы в конкретный миг времени требуются лишь **несколько текущих инструкций** и обрабатываемые ими данные. Виртуальная память загружает в ОЗУ только этот «активный набор» страниц, а всё остальное оставляет в **резервном хранилище** на SSD или диске. По мере продвижения программы по коду старые страницы вытесняются, а новые подгружаются.

---

#### **Почему виртуальная память обычно эффективнее swapping: в чём выигрыш по времени и по использованию памяти? ⭐⭐**

Виртуальная память эффективнее за счёт **избирательности**:

- **По времени:** системе не нужно ждать долгой перекачки мегабайтов данных всего процесса; загрузка одной страницы в 4 КБ происходит значительно быстрее.
- **По памяти:** ОЗУ используется плотнее, так как в ней не простаивают неиспользуемые в данный момент части программ. Это позволяет поддерживать гораздо более **высокую степень многозадачности** на том же объёме «железа».