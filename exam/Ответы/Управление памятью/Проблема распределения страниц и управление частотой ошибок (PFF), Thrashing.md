#### **Почему вопрос “сколько памяти выделить каждому процессу” принципиально сложен в многозадачной системе? ⭐⭐**
Потому что потребности процессов меняются динамически. Выделишь мало — процесс уйдет в thrashing. Выделишь много — память будет простаивать, а другие процессы пострадают. Идеальный баланс — это движущаяся цель.

#### **Объясните идею Page Fault Frequency (PFF): что измеряем, какие решения принимаем, зачем. ⭐⭐**
**Идея:** Держать частоту ошибок страниц в определенных рамках $[L, U]$.
*   **Измеряем:** Количество Page Faults у процесса в единицу времени.
*   **Решения:**
    *   Если PF > $U$ (верхний порог): процессу явно не хватает памяти, **добавляем** ему кадров.
    *   Если PF < $L$ (нижний порог): у процесса избыток памяти, **отбираем** лишние кадры.
**Зачем:** Это саморегулирующаяся система для минимизации PF без излишних трат RAM.

#### **Какие “плохие” эффекты возможны, если агрессивно добавлять страницы процессу при высоком PFF? ⭐⭐⭐**
1.  **Голодание (Starvation):** Мы заберем память у других процессов, которые могут из-за этого сами начать «фолтить».
2.  **Over-allocation:** Процесс может иметь плохую локальность ссылок (например, сканирует огромный массив один раз), и мы отдадим ему всю RAM под данные, которые больше не понадобятся.

#### **А какие эффекты возможны, если агрессивно отбирать страницы при низком PFF? ⭐⭐⭐**
1.  **Ложный Thrashing:** Мы можем отобрать страницу, которая понадобится через миллисекунду, спровоцировав новый PF.
2.  **CPU Overhead:** Слишком частые изменения распределения кадров нагружают ядро ОС.

#### **Как выбрать пороги PFF (верхний/нижний) и почему это зависит от типа нагрузки? ⭐⭐⭐**
Выбор зависит от скорости диска (I/O). На SSD порог может быть выше (PF дешевле), на HDD — ниже. 
*   **Интерактивные задачи:** Ставим низкий верхний порог (чтобы быстрее давать память и не тормозить).
*   **Фоновые вычисления:** Можно терпеть высокий PF.

#### **Как PFF связан с понятием “рабочего множества”, даже если формально WS не вычисляется? ⭐⭐**
PFF — это практическая аппроксимация. Рост PFF сигнализирует о том, что текущее количество кадров меньше рабочего множества. Падение PFF — кадров больше, чем нужно для рабочего множества.

#### **Почему ситуация “всем процессам нужно больше памяти, но забрать не у кого” является тревожным сигналом? ⭐⭐**
Это признак того, что сумма рабочих множеств всех процессов превысила физический объем RAM. Система находится на грани **thrashing-а**. Единственный выход — свопинг (выгрузка процесса целиком) или OOM Killer.

#### **Какие источники “ложных” page faults могут искажать PFF (например, холодный старт, смена фаз программы)? ⭐⭐**
*   **Холодный старт:** В начале работы процесс всегда генерирует много PF, загружая код. Это не значит, что ему нужно бесконечно много памяти.
*   **Смена фаз:** Программа закончила считать и начала рисовать график. Старое рабочее множество не нужно, новое еще не загружено. Кратковременный всплеск PF здесь нормален.

#### **Чем отличается оптимизация распределения кадров “на уровне процессов” от оптимизации “на уровне страниц” (алгоритм замещения)? ⭐⭐**
*   **Уровень страниц:** Отвечает на вопрос «*Какую именно* страницу выкинуть, когда место закончилось?» (LRU, FIFO).
*   **Уровень процессов:** Отвечает на вопрос «*Сколько всего* страниц разрешить иметь этому процессу?» (PFF, WS).

#### **Дайте точное определение thrashing и объясните, почему он возможен даже при “идеальном” алгоритме замещения. ⭐⭐**
**Thrashing (буксование):** Состояние системы, при котором большая часть времени тратится на подкачку страниц с диска и обратно, а не на полезные вычисления.
**Почему возможен при «идеальном» алгоритме:** Если процессу для работы *минимум* нужно 100 страниц (рабочее множество), а вы дали ему 50, никакой алгоритм (даже предсказывающий будущее) не поможет — ему все равно придется постоянно бегать на диск.

#### **Почему причина thrashing-а — это часто суммарное рабочее множество, а не “плохой LRU”? ⭐⭐**
Потому что это проблема емкости. Если 10 человек пытаются сесть на 2 стула, неважно, по какой очереди они меняются («алгоритм») — 8 человек всегда будут стоять. Так и с памятью: если $\sum WS > RAM$, система умрет.

#### **Какие наблюдаемые симптомы в системе укажут на thrashing (CPU, диск, время отклика, очереди)? ⭐⭐**
1.  **CPU utilization падает:** Процессоры простаивают, так как все процессы ждут диск.
2.  **Disk I/O зашкаливает:** Очередь к диску огромная.
3.  **Latency:** Время отклика на действия пользователя измеряется секундами.
4.  **System Load Average:** Растет из-за очереди в состоянии Uninterruptible Sleep (D).

#### **Объясните, почему при thrashing CPU может быть “почти свободным”, а система при этом “умирает”. ⭐⭐**
Процессы порождают ошибки страниц. Обработка ошибки требует чтения с диска. Процесс блокируется. ОС переключается на другой процесс — он тоже блокируется на диске. В итоге все процессы ждут I/O, и планировщику CPU просто некого запускать.

#### **Почему увеличение степени мультипрограммирования (больше процессов) иногда снижает производительность? ⭐⭐**
Существует критическая точка. До неё добавление процессов загружает CPU. После неё каждому процессу достается так мало кадров, что их наборы становятся меньше их рабочих множеств. Начинается thrashing, и полезная работа падает почти до нуля.

#### **Как роль планировщика CPU пересекается с thrashing-ом (например, частые переключения контекста)? ⭐⭐**
Если планировщик продолжает запускать новые процессы в условиях нехватки памяти, он усугубляет ситуацию. Кроме того, частое переключение между «буксующими» процессами вымывает TLB и кэши, еще больше замедляя систему.

#### **Почему thrashing — это не только проблема конкретного процесса, но и системная? ⭐⭐**
Потому что диск (swap) — это общий ресурс. Один процесс, вошедший в thrashing, забивает очередь запросов к диску, из-за чего даже «нормальные» процессы не могут вовремя прочитать свои редкие страницы или файлы.

#### **Какие стратегии предотвращения thrashing вы считаете наиболее практичными в современных ОС и почему? ⭐⭐⭐**
1.  **Свопинг (Medium-term scheduling):** Принудительная выгрузка нескольких процессов целиком на диск, чтобы оставшимся хватило памяти для формирования WS.
2.  **Управление на основе PFF:** Динамическое изменение квот.
3.  **OOM Killer:** Как последняя черта, чтобы не дать зависнуть всему ядру.

