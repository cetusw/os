#### **Что происходит в ОС при page fault и почему почти всегда требуется освободить фрейм под новую страницу? ⭐⭐**

При page fault ОС приостанавливает процесс и инициирует загрузку нужной страницы с диска. Поскольку физическая память обычно заполнена почти полностью для максимальной эффективности, системе приходится **выбирать «жертву»** среди уже находящихся в ОЗУ страниц и освобождать её фрейм для новых данных. Если этого не сделать, запуск новых задач или расширение существующих станет невозможным.

---

#### **Чем принципиально отличается выселение dirty-страницы от clean-страницы с точки зрения стоимости? ⭐⭐**

- **Clean-страница** (не изменённая) идентична своей копии на диске, поэтому её можно просто **мгновенно перезаписать** новыми данными.
- **Dirty-страница** (изменённая) содержит данные, которых нет во внешней памяти, поэтому перед её выселением ОС обязана выполнить **дорогостоящую операцию записи на диск**. Это делает замещение «грязных» страниц значительно более медленным и ресурсозатратным.

---

#### **Какие метрики вы бы использовали, чтобы оценивать «качество» алгоритма замещения страниц (не только число page faults)? ⭐⭐⭐**

Помимо количества ошибок страниц, важными метриками являются:

1. **Суммарное время выполнения** задачи (учитывающее задержки I/O).
2. **Объём дискового трафика** (запись dirty-страниц против чтения).
3. **Накладные расходы CPU** на работу самого алгоритма (например, поддержание счетчиков Aging).
4. **Справедливость распределения** ресурсов между процессами.

---

#### **Почему «минимизировать page faults» не всегда означает «минимизировать время выполнения»? ⭐⭐⭐**

Алгоритм может минимизировать общее число ошибок, но при этом часто выбирать в качестве жертв **dirty-страницы**. Каждая такая ошибка вызовет долгую запись на диск перед чтением новых данных. В итоге система с чуть большим количеством ошибок, но выбирающая для замены только **clean-страницы**, может завершить работу быстрее за счёт отсутствия лишних операций записи.

---

#### **Объясните феномен thrashing: как он связан с неудачным выбором жертвы и с рабочим множеством процесса? ⭐⭐⭐**

**Thrashing (буксование)** возникает, когда суммарное **рабочее множество** (набор страниц, активно нужных процессу прямо сейчас) всех программ превышает объём физической памяти. В этой ситуации любое замещение страницы приводит к тому, что выселенная страница требуется системе почти немедленно. Процессор простаивает, так как ОС тратит всё время на бесконечную перекачку страниц между диском и RAM.

---

#### **Какие системные сигналы (кроме page fault) могут подсказать ОС, что память перегружена и политика вытеснения работает плохо? ⭐⭐⭐**

Сигналами перегрузки служат: рост очередей к диску, увеличение **времени ожидания I/O** (I/O wait), аномально высокая активность фонового процесса **paging daemon**. Также ОС может отслеживать глобальную частоту ошибок (PFF — Page Fault Frequency): если она резко растёт во всей системе, значит, политика вытеснения перестала справляться с объёмом задач.

---

#### **Почему случайное замещение страниц обычно даёт плохие результаты, даже если кажется «справедливым»? ⭐⭐**

Случайный выбор с высокой вероятностью может удалить **критически важную страницу**, которая использовалась всего миллисекунду назад и потребуется снова через мгновение. Это нарушает базовый принцип **локальности обращений**, согласно которому недавно использованные данные, скорее всего, понадобятся в ближайшем будущем.

---

#### **Приведите пример паттерна обращений, при котором случайный выбор почти гарантированно вызывает повторные page faults. ⭐⭐⭐**

Классический пример — **циклический обход** массива страниц, размер которого чуть больше доступной памяти (например, цикл по 101 странице при наличии 100 фреймов). В этом случае любой алгоритм, не учитывающий историю (включая случайный или FIFO), будет постоянно выселять страницу, которая станет нужна следующей, превращая каждое обращение в page fault.

---

#### **Какие свойства поведения программ (локальность, фазы) делают задачу замещения принципиально предсказуемой? ⭐⭐**

Программы обладают **локальностью обращений**: они концентрируются на небольшом наборе данных в течение определённого времени. Кроме того, выполнение программ делится на **фазы** (например, инициализация, вычисление, вывод), внутри которых набор активных страниц (**working set**) стабилен и меняется предсказуемо только при переходе между фазами.

---

#### **Почему при одинаковом объёме памяти два разных приложения могут радикально отличаться по частоте page faults? ⭐⭐**

Это связано с различием в их **рабочих множествах** и паттернах доступа. Одно приложение может работать с плотно упакованными данными (малая область памяти, высокая локальность), в то время как другое совершает случайные прыжки по огромному массиву данных, постоянно вызывая промахи TLB и ошибки страниц даже при больших объёмах доступной ОЗУ.