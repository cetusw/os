#### **В чём идея OPT и почему он «идеален» с точки зрения числа page faults? ⭐⭐**

Идея **оптимального алгоритма (OPT)** заключается в том, чтобы при возникновении ошибки страницы выбрать для выселения ту страницу, которая **понадобится позже всех остальных**. С точки зрения количества страничных прерываний он считается «идеальным», так как математически гарантирует **минимально возможное число page faults** для любой заданной последовательности обращений. Он служит теоретическим эталоном, позволяющим оценить эффективность любого другого реализуемого алгоритма.

---

#### **Почему OPT нереализуем в реальной ОС, но всё равно полезен на практике? ⭐⭐**

Алгоритм нереализуем, так как для его работы операционная система должна **точно знать будущее** — в какой именно момент времени в следующий раз потребуется каждая из страниц. Поскольку ОС не обладает способностью предсказывать поведение произвольных программ, она не может сделать безошибочный выбор «жертвы». На практике он полезен как **стандарт качества**: исследователи используют его для сравнения, чтобы понять, насколько далеко их разработки ушли от идеала.

---

#### **Как можно смоделировать OPT на трассе обращений и что это даёт исследователю/инженеру? ⭐⭐**

OPT можно смоделировать с помощью **симулятора**, работающего в два прохода. На первом проходе собирается **трасса (лог) всех обращений** программы к памяти. На втором проходе симулятор анализирует эту трассу с конца или заглядывает вперед по списку, имитируя «идеальное знание будущего» для выбора страниц на выселение. Это дает инженеру **верхнюю границу эффективности**, позволяя понять, стоит ли тратить ресурсы на улучшение текущего алгоритма, если он и так близок к пределу.

---

#### **Почему сравнение с OPT важно именно как «верхняя граница», а не как рецепт реализации? ⭐⭐**

Сравнение с OPT важно потому, что ни один реальный алгоритм не может показать результат лучше. Это **теоретический потолок**, который помогает инженерам не ставить невыполнимых задач. Он не является рецептом реализации, так как любая попытка воплотить его в жизнь в реальном времени потребует предсказания будущего, что технически невозможно.

---

#### **Что означает утверждение «если алгоритм хуже OPT на 1–2%, то он почти оптимален» — и когда это может быть неверно? ⭐⭐⭐**

Это утверждение означает, что алгоритм настолько эффективно использует статистику прошлого для предсказания будущего, что дополнительные сложности по его улучшению не принесут значимой выгоды. Однако это может быть неверно, если эти 1–2% разницы приходятся на **очень частые обращения** в высоконагруженных системах или если стоимость обработки каждого page fault (например, из-за медленного диска) критически велика. Также это не учитывает накладные расходы процессора на работу самого алгоритма.

---

#### **На последовательности обращений `` объясните логику выбора жертвы OPT при памяти на 3 страницы. ⭐⭐⭐**

При наличии трех фреймов работа будет выглядеть так:

1. Загружаются страницы ****.
2. При обращении к **4** нужно выбрать жертву среди 1, 2 и 3. Алгоритм смотрит вперед: 1 понадобится скоро, 2 — сразу за ней, а 3 понадобится значительно позже. Следовательно, **выселяется 3**, в памяти остаются ****.
3. При обращении к **5** снова смотрим вперед: 1 и 2 понадобятся почти сразу, а 3 и 4 — намного позже. Алгоритм **выселяет 4**, оставляя ****. **Принцип:** всегда выселяется та страница, индекс следующего появления которой в списке самый большой.

---

#### **Какие данные о странице отражают биты R (Referenced) и M (Modified), и почему их достаточно для базовой эвристики? ⭐⭐**

- **R (Referenced):** устанавливается аппаратно при любом обращении к странице (чтение или запись).
- **M (Modified):** устанавливается только при записи данных в страницу (страница становится «грязной»). Этих битов достаточно, так как они позволяют быстро оценить две вещи: **вероятность скорого использования** (бит R) и **стоимость выселения** (бит M — нужно ли тратить время на запись на диск).

---

#### **Зачем ОС периодически сбрасывает R-бит и почему выбор периода (например, 20 мс) влияет на качество алгоритма? ⭐⭐⭐**

Сброс бита R необходим, чтобы алгоритм мог различать страницы, к которым обращались **совсем недавно**, от тех, что использовались давно. Если бит не сбрасывать, со временем он установится у всех страниц, и они станут неразличимы для системы.

- Если период **слишком короткий**, страницы не успеют накопить обращения и будут выглядеть неиспользуемыми.
- Если период **слишком длинный**, статистика устареет, и ОС может посчитать активной страницу, которая уже не нужна.

---

#### **Объясните 4 класса NRU (R/M) и почему именно такой приоритет обычно рационален. ⭐⭐**

Алгоритм **NRU (Not Recently Used)** делит страницы на классы:

1. **Класс 0:** $R=0, M=0$ (не использовалась, не изменена) — лучшая жертва.
2. **Класс 1:** $R=0, M=1$ (не использовалась недавно, но была изменена) — возникнет, если бит R был сброшен по таймеру.
3. **Класс 2:** $R=1, M=0$ (использовалась, но чистая).
4. **Класс 3:** $R=1, M=1$ (использовалась и изменена) — худшая жертва. Приоритет рационален, так как выгоднее удалить **чистую страницу, которую давно не трогали**, чтобы избежать лишней записи на диск и сохранить в памяти активные данные.

---

#### **Почему NRU выбирает случайную страницу внутри класса, и чем это полезно с точки зрения накладных расходов? ⭐⭐**

NRU выбирает случайную страницу внутри самого низкого непустого класса, чтобы **минимизировать вычислительные затраты**. Поиск «самой лучшей» страницы потребовал бы сортировки или долгого сканирования, в то время как случайный выбор внутри подходящей категории дает приемлемый результат при **минимальной нагрузке на CPU**.

---

#### **В каких сценариях NRU может вести себя плохо из-за того, что не различает «давно» и «совсем недавно»? ⭐⭐⭐**

NRU может работать плохо при **интенсивной многозадачности**, когда за один период сброса R-битов (например, 20 мс) к большинству страниц успевают обратиться. В этом случае почти все страницы попадут в классы 2 или 3, и алгоритм фактически превратится в **случайный выбор**, не учитывая, что одна страница использовалась 1 мс назад, а другая — 19 мс назад.

---

#### **Как изменится поведение NRU, если система слишком редко сбрасывает R-биты? А если слишком часто? ⭐⭐⭐**

- **Редкий сброс:** почти у всех страниц бит R будет равен 1. Алгоритм не сможет эффективно выделять неактивные страницы, и выбор будет почти случайным среди классов 2 и 3.
- **Частый сброс:** страницы будут постоянно переходить в классы 0 и 1, даже если процесс активно с ними работает. Это приведет к риску выселения **активно используемых страниц**, что вызовет резкий рост page faults.

---

#### **Как можно реализовать/эмулировать R и M, если аппаратных битов нет? Почему это может быть дорого? ⭐⭐⭐**

ОС может эмулировать их через **права доступа**:

1. При загрузке страницы пометить её как **отсутствующую** или **только для чтения**, даже если она в RAM.
2. При первом обращении (чтение) возникнет fault: ОС установит программный бит R и разрешит чтение.
3. При первой записи возникнет fault: ОС установит программный бит M и разрешит запись. Это **дорого**, так как каждое «первое» действие вызывает дорогостоящее прерывание и переход в режим ядра.

---

#### **Почему M-бит обычно не сбрасывают периодически, в отличие от R? ⭐⭐**

Бит **M (Modified)** отражает физическое состояние данных: была ли страница изменена относительно своей копии на диске. Если его сбросить, ОС «забудет», что страницу нужно сохранить перед удалением, и при выселении данные будут **безвозвратно потеряны**. Бит M сбрасывается только тогда, когда страница реально записывается на диск фоновым процессом очистки.

---
