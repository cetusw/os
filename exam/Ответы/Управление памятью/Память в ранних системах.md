#### **Что означает «программа имеет доступ ко всем адресам физической памяти», и почему это опасно? ⭐**

В ранних компьютерных системах отсутствовала абстракция памяти, поэтому программы работали напрямую с **физическими адресами** оперативной памяти,. Это означает, что любое обращение к адресу в коде соответствовало конкретной ячейке в аппаратных чипах ОЗУ,. Такая модель крайне опасна, так как пользовательская программа может намеренно или из-за ошибки (например, неверного указателя) **перезаписать критические данные** другого процесса или даже коды самой операционной системы,. В результате одна нестабильная программа могла легко привести к краху всей машины.

---

#### **Почему при прямой адресации «две программы не могут существовать в памяти одновременно»? ⭐⭐**

При использовании прямой физической адресации программы часто полагаются на **абсолютные адреса**, жестко прописанные в их машинном коде для переходов или доступа к переменным. Если две такие программы попытаются занять одни и те же адреса или одна программа случайно запишет данные в область, используемую другой, возникнет неустранимый конфликт и порча данных,. Даже если они физически размещены в разных частях ОЗУ, отсутствие изоляции не позволяет им работать независимо, так как любая ошибка одной программы может уничтожить состояние другой,.

---

#### **Объясните, как ошибка в одной программе могла уничтожить данные другой программы или ОС в ранних системах. ⭐⭐**

В системах без аппаратной защиты любая инструкция записи (`MOVE`, `STORE`) могла быть выполнена по любому физическому адресу. Если программист допускал логическую ошибку, например, выходил за границы массива, процессор беспрепятственно выполнял запись в указанную ячейку, даже если там находился **код ядра ОС** или данные другого процесса,. Поскольку границ дозволенного на аппаратном уровне не существовало, некорректная команда могла затереть важные системные структуры, вызывая немедленную остановку или некорректное поведение всей системы,.

---

#### **Почему абсолютные адреса в коде делают программу негибкой при загрузке в другое место памяти? ⭐⭐**

Абсолютные адреса жестко привязывают команды (например, инструкции перехода `JMP`) и данные к конкретным числовым позициям в памяти. Если программа скомпилирована с расчетом на работу с адреса 0, а её физически загружают по адресу 16384, то все её внутренние ссылки на метки функций и переменные останутся **указывать на старые места** (в диапазоне от 0 до 16383),. Без специальной корректировки каждого такого адреса в коде программа просто не сможет корректно функционировать после перемещения.

---

#### **Какие преимущества и недостатки имеют системы без виртуальной памяти (например, во встраиваемых устройствах)? ⭐⭐⭐**

- **Преимущества:** такие системы отличаются **простотой реализации** и минимальными накладными расходами ресурсов процессора на управление памятью,. Это делает их идеальными для устройств с фиксированным программным обеспечением, таких как банковские карты, простые микроконтроллеры или бытовая техника,.
- **Недостатки:** программы в них **крайне уязвимы** к ошибкам, так как нет механизмов защиты и изоляции,. В таких системах невозможно безопасно запускать несколько независимых приложений от разных разработчиков, а пользователь не застрахован от того, что одна ошибка приведет к полной неработоспособности устройства.

---

#### **Какие варианты размещения ОС в памяти существовали исторически и почему? ⭐⭐**

Исторически сложилось три основных сценария компоновки ОЗУ:

1. **В нижних адресах ОЗУ:** этот вариант был характерен для ранних мейнфреймов, где системный код занимал начальный диапазон адресов.
2. **В верхних адресах ПЗУ (ROM):** часто встречается во встраиваемых системах, чтобы код ОС был защищен от записи и доступен сразу после включения.
3. **Драйверы в ПЗУ (BIOS), а основная ОС в ОЗУ:** модель, ставшая классической для ранних персональных компьютеров, где базовая инициализация зашита в чип, а сама система загружается в оперативную память.

---

#### **Почему размещение ОС в RAM без защиты приводило к риску её перезаписи пользователем? ⭐**

Оперативная память (RAM) по своей физической природе доступна как для чтения, так и для записи. В отсутствие аппаратных механизмов защиты и разделения режимов (пользователь/ядро) любая инструкция, запущенная от имени пользователя, имела те же привилегии, что и системный код. В результате обычная программа могла случайно или намеренно выполнить запись по адресу, где располагались **инструкции ОС**, тем самым повреждая систему.

---

#### **Зачем BIOS размещали в ROM в ранних ПК, и какие задачи он решал? ⭐⭐**

BIOS (базовая система ввода-вывода) размещали в **энергонезависимой памяти (ROM)**, чтобы его код был доступен процессору мгновенно после подачи питания, до загрузки чего-либо с диска,,. Он решал задачи **начальной инициализации** оборудования (проверка памяти, настройка контроллеров клавиатуры и дисков) и запуска процесса поиска и загрузки операционной системы с активного накопителя,.

---

#### **Почему даже размещение части ОС в ROM не решало проблему защиты пользовательской памяти полностью? ⭐⭐**

Хотя нахождение ядра в ROM защищало его код от стирания, это никак не ограничивало одну пользовательскую программу в её попытках **испортить память другого пользователя** в RAM,. Для полной безопасности системы требуются более сложные механизмы: разделение уровней привилегий процессора и аппаратный контроль доступа к страницам, который гарантирует, что каждый процесс работает только в своем разрешенном диапазоне адресов,.

---

#### **Какие требования к памяти появляются, когда система переходит от «одна программа в памяти» к многозадачности? ⭐⭐⭐**

При переходе к многозадачности критически важными становятся два требования:

1. **Защита (Protection):** аппаратная гарантия того, что ни один процесс не сможет изменить или прочитать данные другого процесса без разрешения,.
2. **Релокация (Relocation):** возможность операционной системы загружать и выполнять программу в **любом свободном участке** физической памяти, обеспечивая независимость её логических адресов от фактического места размещения в ОЗУ,.

---

#### **В чём идея swapping как раннего способа создать иллюзию многозадачности? ⭐⭐**

Идея **свопинга (swapping)** заключается в том, что в оперативной памяти физически находится только одна программа в конкретный момент времени,,. Когда требуется дать поработать другому процессу, текущая программа **полностью выгружается** на диск (сохраняется её «образ»), а на её место загружается код и данные следующей программы,. Это позволяло запускать больше приложений, чем мог вместить ограниченный объем физической ОЗУ, создавая видимость их одновременной работы.

---

#### **Как работали аппаратные ключи защиты памяти в IBM/360 и что именно они предотвращали? ⭐⭐⭐**

В системе IBM/360 физическая память делилась на блоки по **2 КБ**, и каждому блоку назначался специальный **4-битный ключ защиты**,. Текущий ключ работающего процесса хранился в специальном регистре процессора (PSW). При попытке записи или чтения процессор сравнивал ключ процесса с ключом блока памяти: если они не совпадали, возникало аппаратное прерывание, что предотвращало попытки программ вмешаться в чужую память,.

---

#### **Почему механизм ключей защиты решал задачу безопасности, но не решал проблему релокации? ⭐⭐**

Ключи защиты эффективно проверяли только **права доступа** к конкретному физическому адресу, выступая в роли «замка»,. Однако программа внутри себя по-прежнему использовала **абсолютные физические адреса**. Если ОС перемещала программу в другой свободный блок памяти, все её внутренние переходы и обращения к данным становились неверными, так как ключи не умели автоматически преобразовывать (сдвигать) адреса в коде,.

---

#### **Что такое PSW и какую роль он играет в контроле доступа к памяти (на концептуальном уровне)? ⭐⭐**

**PSW (Program Status Word)** — это важный регистр состояния программы, который содержит управляющие биты, такие как режим работы процессора (пользователь/ядро), приоритет и коды условий,. В контексте контроля памяти PSW выступал хранителем **активного ключа защиты**, который определял, к каким именно сегментам или блокам физической памяти процессу разрешен доступ в текущий момент времени,.

---

#### **Какие ограничения у схемы защиты памяти «ключами», если сравнивать с полноценными адресными пространствами? ⭐⭐⭐**

Главное ограничение «ключевой» схемы — отсутствие **изоляции адресных пространств** на логическом уровне: все процессы продолжали видеть одну и ту же физическую память (адрес 100 был одним и тем же для всех),. Полноценные адресные пространства позволяют каждому процессу иметь свой независимый набор адресов, где **один и тот же виртуальный адрес** в разных процессах прозрачно для них отображается на разные физические ячейки, что обеспечивает настоящую независимость и удобство программирования,.