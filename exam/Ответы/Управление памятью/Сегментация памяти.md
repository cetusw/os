#### **Почему одномерная (линейная) модель виртуальной памяти неудобна для программ с независимыми растущими областями (код/данные/стек)? ⭐⭐**
В линейной памяти вы должны заранее решить, где кончается стек и начинаются данные. Если они растут навстречу друг другу, они рано или поздно столкнутся, хотя свободная память в системе еще может быть. Приходится постоянно «двигать» границы.

#### **Что такое сегментация и как адрес вида <номер сегмента, смещение> меняет мышление об адресах? ⭐⭐**
**Сегментация** — это деление памяти на логические части (сегменты) разной длины (сегмент кода, сегмент стека).
**Мышление:** Адрес перестает быть просто числом от 0 до $N$. Он становится двумерным. Это как адрес в городе: «Улица (сегмент), дом (смещение)». Вы можете расширять одну улицу, не двигая дома на другой.

#### **Какие преимущества сегментации дают реальную пользу компоновке, модульности и защите? ⭐⭐⭐**
*   **Компоновка:** Каждый модуль/библиотека может быть в своем сегменте.
*   **Защита:** Можно пометить сегмент кода как «Только выполнение», а сегмент данных как «Только чтение/запись». Нарушить это аппаратно невозможно.
*   **Модульность:** Изменение размера одного сегмента не влияет на адреса в других.

#### **Почему сегментация естественно поддерживает разделение кода между процессами? ⭐⭐**
Потому что процессы могут просто иметь в своих таблицах сегментов ссылку на один и тот же физический сегмент кода.

#### **Какие трудности возникают с указателями при сегментации (арифметика, сравнение, передача между модулями)? ⭐⭐⭐**
Арифметика указателей становится сложной. Что такое `ptr + 1`, если мы дошли до конца сегмента? Сравнение двух указателей из разных сегментов бессмысленно. Передача указателя другому модулю требует передачи и номера сегмента, и смещения.

#### **Почему near/far pointers в старых x86 были “болью программиста”, и что это говорит о цене гибкости? ⭐⭐⭐**
`near` — только смещение (быстро, но в рамках 64 КБ). `far` — сегмент + смещение (медленно, но везде). Программистам приходилось постоянно следить за типами указателей. Это говорит о том, что сложная модель памяти сильно усложняет разработку ПО.

#### **Объясните происхождение термина “segmentation fault” и почему он остался, хотя механизмы изменились. ⭐⭐**
Термин пошел от систем с сегментацией: процессор генерировал ошибку, когда программа пыталась обратиться к адресу вне границ своего сегмента или с неверными правами. В современных ОС с пейджингом (где сегментов по сути нет) термин остался как дань традиции для обозначения любой ошибки доступа к памяти.

#### **Приведите несколько типичных причин segfault в современных ОС и объясните их на уровне защиты памяти. ⭐⭐**
*   **Разыменование NULL:** Обращение к странице 0, которая специально помечена как «отсутствующая».
*   **Запись в Read-Only:** Попытка изменить строковую константу (лежит в сегменте кода).
*   **Переполнение стека:** Выход за пределы страницы, выделенной под стек.

#### **Почему сегменты переменного размера приводят к появлению “дыр” в памяти со временем? ⭐⭐**
Когда сегмент удаляется, на его месте остается дыра. Если новый сегмент чуть меньше, останется «хвостик». Со временем память превращается в решето из маленьких дырок.

#### **Что такое внешняя фрагментация и почему общий объём свободной памяти может быть достаточным, но всё равно не хватать места? ⭐⭐**
Это ситуация, когда суммарно свободно 100 МБ, но они разбиты на 1000 кусков по 100 КБ. Если программе нужен непрерывный кусок в 1 МБ, она его не получит.

#### **Что такое checkerboarding и оно связано с деградацией использования памяти? ⭐⭐⭐**
Это и есть крайняя степень внешней фрагментации (память похожа на шахматную доску). Деградация в том, что огромные объемы RAM простаивают, так как куски слишком малы для полезного использования.

#### **Как работает компактизация: какие действия должна выполнить ОС, чтобы собрать свободную память в один блок? ⭐⭐⭐**
1. Приостановить все процессы.
2. Физически скопировать занятые блоки памяти так, чтобы они лежали вплотную друг к другу.
3. Обновить все базовые адреса в таблицах сегментов.
4. Возобновить процессы.

#### **Почему компактизация дорогая (приостановка процессов, обновление таблиц, пересчёт адресов)? ⭐⭐⭐**
Копирование Гб данных занимает много времени CPU. В это время система «висит» (паузы в секунды). Это недопустимо для интерактивных и реального времени систем.

#### **Почему чистая сегментация редко используется “в лоб” в современных ОС? ⭐⭐**
Из-за внешней фрагментации и сложности управления. Пейджинг (страничная организация) гораздо эффективнее решает вопрос распределения физической памяти.
