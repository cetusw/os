#### **Какие ограничения единого адресного пространства были критичны в 16-битных системах? ⭐⭐**
В 16-битных системах (например, PDP-11) максимальный адрес — 65535 ($2^{16}$). Это значит, что программа вместе со всеми своими данными должна была втиснуться в **64 КБ**. Этого катастрофически не хватало для сложных задач.

#### **Объясните идею разделения I-space и D-space: как это “удваивает” доступное адресное пространство. ⭐⭐**
Идея: выделить 64 КБ чисто под код (Instructions) и еще 64 КБ чисто под данные (Data).
Процессор понимает контекст: если он выбирает следующую инструкцию — он лезет в I-space. Если он выполняет `LOAD` — он лезет в D-space. Таким образом, лимит расширяется до 128 КБ без изменения разрядности адреса.

#### **Как аппаратно и системно реализуются два пространства (две таблицы страниц, выбор по типу доступа)? ⭐⭐**
*   **Аппаратно:** В процессоре есть два регистра-указателя на таблицы страниц. MMU переключается между ними в зависимости от типа цикла шины (Instruction Fetch vs Data Access).
*   **Системно:** ОС ведет две разные таблицы страниц для одного процесса.

#### **Почему раздельные пространства позволяют “независимую подкачку” инструкций и данных, и зачем это могло быть полезно? ⭐⭐**
Поскольку это разные таблицы, ОС может вытеснить неиспользуемые данные, оставив код в памяти, или наоборот. Это полезно, так как код — Read-Only (его не надо писать на диск при вытеснении), а данные часто меняются.

#### **Почему сегодня эта идея “не нужна” для адресов, но продолжает жить в I-cache/D-cache и I-TLB/D-TLB? ⭐⭐**
*   **Не нужна для адресов:** 64-битные адреса настолько велики, что искусственно удваивать их нет смысла.
*   **Живет в кэшах:** Разделение кэша инструкций и данных позволяет CPU параллельно считывать код и операнды, не создавая конфликтов на шине кэша.

#### **Какие типичные конфликты/потери производительности уменьшаются при разделении кэшей для кода и данных? ⭐⭐⭐**
Исключается «вымывание» кода данными. В едином кэше цикл, обрабатывающий огромный массив, может вытеснить сам код этого цикла из кэша. Разделение гарантирует, что данные не «затрут» инструкции.

#### **Почему код программы обычно безопасно шарить между процессами, а данные — нет? ⭐⭐**
*   **Код:** Не меняется во время выполнения (re-entrant). Если 10 человек запустили `ls`, всем нужен один и тот же набор инструкций.
*   **Данные:** Содержат состояние конкретного пользователя (пароли, переменные). Если их расшарить, процессы будут портить данные друг друга и возникнет дыра в безопасности.

#### **Если несколько процессов используют общие страницы кода, какие механизмы учёта нужны ОС, чтобы корректно освобождать память? ⭐⭐**
Нужен **счетчик ссылок (reference count)** для каждого физического кадра. ОС удаляет страницу из RAM только тогда, когда счетчик становится равным 0 (т.е. последний процесс, использовавший этот код, завершился).

#### **Почему “поиск по всем таблицам страниц” дорог, и какие структуры данных логично использовать для учёта разделяемых страниц? ⭐⭐⭐**
*   **Почему дорог:** В системе могут быть тысячи процессов. Проверять каждую таблицу — колоссальные затраты CPU.
*   **Структуры:** Используется **инвертированная таблица страниц** или системная таблица кадров (*Core Map*), где для каждого физического кадра указано, какими процессами он занят.

#### **Что должно произойти при завершении процесса, который делил страницы с другими: какие проверки обязательны? ⭐⭐**
1.  Уменьшить счетчик ссылок на все разделяемые кадры.
2.  Если счетчик > 0 — просто забыть про страницу (она нужна другим).
3.  Если счетчик == 0 — освободить кадр.
4.  Проверить, не была ли страница «грязной» (если это данные, а не код), и нужно ли её сохранить.

#### **Объясните, как fork() может давать “общие данные” безопасно с помощью Read-Only + trap + COW. ⭐⭐**
1.  `fork()` копирует таблицу страниц родителя.
2.  Все страницы (и кода, и данных) помечаются как **Read-Only**.
3.  Если процесс пытается писать, возникает **trap** (нарушение защиты).
4.  Ядро видит: «Ага, это попытка записи в общую страницу данных». Оно копирует её в новый кадр (**Copy-on-Write**) и помечает как Read-Write только для этого процесса.

#### **Приведите пример, когда COW может неожиданно привести к большому потреблению памяти (worst-case). ⭐⭐⭐**
Процесс-родитель занимает 10 ГБ. Он делает `fork()`. Если потомок (или родитель) решит пройтись циклом по всему массиву и изменить по одному байту в каждой странице, ОС придется физически скопировать все 10 ГБ. Память мгновенно закончится.
