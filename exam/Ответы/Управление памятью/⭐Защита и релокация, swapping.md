#### **Объясните принцип работы base register и limit register и как они обеспечивают защиту процесса. ⭐⭐**

При использовании этой схемы каждому процессу выделяются два специальных аппаратных регистра: **base register** (базовый регистр), хранящий физический адрес начала области памяти процесса, и **limit register** (регистр границы), содержащий длину этой области. При каждом обращении к памяти аппаратное обеспечение автоматически прибавляет значение базового регистра к виртуальному адресу, генерируемому программой, и одновременно проверяет, не превышает ли полученный результат или исходный адрес значение в регистре границы. Если адрес выходит за установленные пределы, процессор генерирует аппаратное прерывание, предотвращая несанкционированный доступ.

---

#### **Почему при base/limit программа может «думать», что начинается с адреса 0, даже если в физической памяти она размещена иначе? ⭐⭐**

Это происходит благодаря автоматическому преобразованию адресов на уровне «железа»: программа работает с **логическими адресами**, которые всегда начинаются с 0 и идут до значения `limit`. Процессор прозрачно для самой программы прибавляет значение **base** к каждому адресу перед тем, как отправить его на шину памяти. Например, если в коде указана команда перехода `JMP 28`, а программа загружена по базовому адресу 16384, аппаратура сама преобразует этот вызов в обращение к физической ячейке 16412.

---

#### **Что происходит при попытке обращения за пределы limit, и почему это важно для устойчивости системы? ⭐⭐**

Если программа пытается прочитать или записать данные по адресу, который больше значения, установленного в **limit register**, процессор немедленно блокирует эту операцию и вызывает **аппаратное прерывание** (trap). Это критически важно для устойчивости, так как гарантирует, что ошибка в одной программе (например, неверный указатель) не позволит ей «испортить» память другого процесса или коды самой операционной системы. Без такой защиты один нестабильный процесс мог бы вызвать крах всей вычислительной машины.

---

#### **Почему изменять base/limit должна иметь право только ОС? Какие угрозы возникают иначе? ⭐⭐⭐**

Управление этими регистрами является **привилегированной операцией**, доступной только в режиме ядра, чтобы обычные приложения не могли самостоятельно расширять свои границы памяти. Если бы пользовательский процесс имел доступ к изменению `base` и `limit`, он мог бы установить значения, позволяющие ему **читать и записывать данные любого другого процесса** или самого ядра системы. Это полностью уничтожило бы механизмы безопасности и изоляции, делая систему беззащитной перед вредоносным кодом.

---

#### **Какие недостатки у схемы base/limit с точки зрения производительности и почему они проявляются при каждом обращении к памяти? ⭐⭐⭐**

Основной недостаток заключается в необходимости выполнения **арифметической операции сложения и проверки условия** при абсолютно каждом обращении процессора к памяти для выборки инструкций или данных. Это создает постоянную дополнительную нагрузку на логические цепи процессора, что может замедлять выполнение программ. Хотя современные процессоры оптимизируют этот процесс, в исторической перспективе такая обязательная арифметика считалась серьезным накладным расходом.

---

#### **Почему в современных ОС возникает необходимость выгружать процессы на диск, даже при наличии больших объёмов RAM? ⭐⭐**

Несмотря на рост объема ОЗУ, современные приложения также стремительно увеличиваются в размерах, потребляя сотни мегабайт или гигабайты памяти. Кроме того, пользователи одновременно запускают десятки процессов, и в определенный момент суммарных требований всех программ начинает **не хватать физической емкости RAM**. В таких ситуациях ОС вынуждена временно перемещать неактивные данные или процессы целиком на жесткий диск или SSD, чтобы освободить место для активных задач.

---

#### **Опишите полный цикл swapping: загрузка → выполнение → выгрузка → возврат. Какие данные должны сохраняться? ⭐⭐⭐**

Цикл начинается с **загрузки** образа процесса с диска в свободный блок оперативной памяти, после чего процесс получает квант времени и переходит в стадию **выполнения**. Когда памяти становится недостаточно или процесс долго бездействует, происходит его **выгрузка** (swap out) — всё текущее состояние памяти процесса (core image) записывается обратно на диск. При **возврате** (swap in) образ снова считывается в RAM, при этом должны сохраняться не только данные и код, но и состояние регистров (PC, SP, PSW) в таблице процессов, чтобы выполнение возобновилось с прерванного места.

---

#### **Почему при возврате процесса из swap он может оказаться в другом месте памяти, и что нужно для корректной работы? ⭐⭐**

За время нахождения процесса на диске карта занятости оперативной памяти может измениться: старое место может быть занято другими программами, или в памяти могут появиться новые свободные участки. Для корректной работы при возврате в другое место необходима **динамическая релокация**, которая обычно реализуется аппаратно через механизмы базовых регистров или таблиц страниц. Программа продолжает использовать свои логические адреса, а ОС просто обновляет значение в **base register** процесса, указывая на его новое физическое положение.

---

#### **Что такое «дыры» (holes) в памяти и почему swapping усиливает фрагментацию? ⭐⭐**

**«Дыры» (holes)** — это фрагменты неиспользуемой (свободной) памяти, которые образуются между блоками, занятыми активными процессами. Swapping усиливает фрагментацию, потому что процессы имеют разные размеры и загружаются/выгружаются в разное время, оставляя после себя пустые участки случайной длины. Со временем память превращается в «шахматную доску» из мелких занятых и свободных блоков, в результате чего система может не найти одного достаточно большого непрерывного участка для загрузки новой крупной программы, даже если суммарно свободной памяти много.

---

#### **Объясните, что такое memory compaction, почему она дорогая, и в каких ситуациях может быть оправдана. ⭐⭐⭐**

**Memory compaction** (уплотнение памяти) — это метод борьбы с фрагментацией, при котором ОС перемещает все работающие процессы в одну сторону (обычно «вниз» к началу адресов), объединяя все разрозненные «дыры» в один большой свободный блок. Эта операция считается **чрезвычайно дорогой**, так как требует копирования огромных массивов данных в памяти и существенных затрат времени процессора. Она может быть оправдана только в критических ситуациях, когда фрагментация достигла такого уровня, что запуск новых важных задач стал невозможен, несмотря на наличие свободного объема памяти.